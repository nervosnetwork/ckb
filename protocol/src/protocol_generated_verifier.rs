//! This file is auto-generated by cfbc.
use super::protocol_generated as reader;

pub mod ckb {
    #![allow(unused_imports)]

    use super::reader::ckb as reader;
    use flatbuffers::{self, Follow};
    use flatbuffers_verifier::{
        try_follow_uoffset, Error, Result, StringVerifier, VectorVerifier, Verify,
        MAX_OFFSET_LOC,
    };
    pub mod protocol {
        #![allow(unused_imports)]

        use super::reader::protocol as reader;
        use flatbuffers::{self, Follow};
        use flatbuffers_verifier::{
            try_follow_uoffset, Error, Result, StringVerifier, VectorVerifier, Verify,
            MAX_OFFSET_LOC,
        };

        impl<'a> Verify for reader::AddFilter<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_FILTER as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_FILTER) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let filter_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        filter_verifier.verify_scalar_elements(1)?;
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::Alert<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_ID as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_ID) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 4 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_CANCEL as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_CANCEL) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 4 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_MIN_VERSION as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_MIN_VERSION) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.min_version() {
                            f.verify()?;
                        }
                    }
                }

                if Self::VT_MAX_VERSION as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_MAX_VERSION) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.max_version() {
                            f.verify()?;
                        }
                    }
                }

                if Self::VT_PRIORITY as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PRIORITY) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 4 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_SIGNATURES as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_SIGNATURES) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let signatures_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        signatures_verifier
                            .verify_reference_elements::<reader::Bytes>()?;
                    }
                }

                if Self::VT_NOTICE_UNTIL as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_NOTICE_UNTIL) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 8 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_MESSAGE as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_MESSAGE) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.message() {
                            f.verify()?;
                        }
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::AlertMessage<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_PAYLOAD as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PAYLOAD) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.payload() {
                            f.verify()?;
                        }
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::Block<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_HEADER as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_HEADER) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.header() {
                            f.verify()?;
                        }
                    }
                }

                if Self::VT_UNCLES as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_UNCLES) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let uncles_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        uncles_verifier
                            .verify_reference_elements::<reader::UncleBlock>()?;
                    }
                }

                if Self::VT_TRANSACTIONS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_TRANSACTIONS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let transactions_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        transactions_verifier
                            .verify_reference_elements::<reader::Transaction>()?;
                    }
                }

                if Self::VT_PROPOSALS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PROPOSALS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let proposals_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        proposals_verifier.verify_scalar_elements(10)?;
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::BlockProposal<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_TRANSACTIONS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_TRANSACTIONS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let transactions_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        transactions_verifier
                            .verify_reference_elements::<reader::Transaction>()?;
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::BlockTransactions<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_BLOCK_HASH as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_BLOCK_HASH) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 32 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_TRANSACTIONS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_TRANSACTIONS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let transactions_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        transactions_verifier
                            .verify_reference_elements::<reader::Transaction>()?;
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::Bytes<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_SEQ as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_SEQ) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let seq_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        seq_verifier.verify_scalar_elements(1)?;
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::CellInput<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_BLOCK_HASH as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_BLOCK_HASH) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 32 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_TX_HASH as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_TX_HASH) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 32 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_INDEX as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_INDEX) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 4 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_SINCE as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_SINCE) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 8 {
                        return Err(Error::OutOfBounds);
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::CellOutput<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_CAPACITY as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_CAPACITY) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 8 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_DATA as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_DATA) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.data() {
                            f.verify()?;
                        }
                    }
                }

                if Self::VT_LOCK as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_LOCK) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.lock() {
                            f.verify()?;
                        }
                    }
                }

                if Self::VT_TYPE_ as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_TYPE_) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.type_() {
                            f.verify()?;
                        }
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::ClearFilter<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::CompactBlock<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_HEADER as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_HEADER) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.header() {
                            f.verify()?;
                        }
                    }
                }

                if Self::VT_NONCE as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_NONCE) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 8 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_SHORT_IDS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_SHORT_IDS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let short_ids_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        short_ids_verifier
                            .verify_reference_elements::<reader::Bytes>()?;
                    }
                }

                if Self::VT_PREFILLED_TRANSACTIONS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PREFILLED_TRANSACTIONS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let prefilled_transactions_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        prefilled_transactions_verifier
                            .verify_reference_elements::<reader::IndexTransaction>()?;
                    }
                }

                if Self::VT_UNCLES as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_UNCLES) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let uncles_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        uncles_verifier
                            .verify_reference_elements::<reader::UncleBlock>()?;
                    }
                }

                if Self::VT_PROPOSALS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PROPOSALS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let proposals_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        proposals_verifier.verify_scalar_elements(10)?;
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::FilteredBlock<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_HEADER as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_HEADER) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.header() {
                            f.verify()?;
                        }
                    }
                }

                if Self::VT_TRANSACTIONS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_TRANSACTIONS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let transactions_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        transactions_verifier
                            .verify_reference_elements::<reader::Transaction>()?;
                    }
                }

                if Self::VT_PROOF as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PROOF) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.proof() {
                            f.verify()?;
                        }
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::GetBlockProposal<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_BLOCK_NUMBER as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_BLOCK_NUMBER) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 8 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_PROPOSALS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PROPOSALS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let proposals_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        proposals_verifier.verify_scalar_elements(10)?;
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::GetBlockTransactions<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_BLOCK_HASH as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_BLOCK_HASH) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 32 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_INDEXES as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_INDEXES) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let indexes_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        indexes_verifier.verify_scalar_elements(4)?;
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::GetBlocks<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_BLOCK_HASHES as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_BLOCK_HASHES) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let block_hashes_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        block_hashes_verifier.verify_scalar_elements(32)?;
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::GetHeaders<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_VERSION as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_VERSION) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 4 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_BLOCK_LOCATOR_HASHES as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_BLOCK_LOCATOR_HASHES) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let block_locator_hashes_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        block_locator_hashes_verifier.verify_scalar_elements(32)?;
                    }
                }

                if Self::VT_HASH_STOP as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_HASH_STOP) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 32 {
                        return Err(Error::OutOfBounds);
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::GetRelayTransaction<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_TX_HASH as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_TX_HASH) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 32 {
                        return Err(Error::OutOfBounds);
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::Header<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_VERSION as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_VERSION) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 4 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_PARENT_HASH as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PARENT_HASH) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 32 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_TIMESTAMP as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_TIMESTAMP) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 8 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_NUMBER as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_NUMBER) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 8 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_TRANSACTIONS_ROOT as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_TRANSACTIONS_ROOT) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 32 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_WITNESSES_ROOT as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_WITNESSES_ROOT) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 32 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_PROPOSALS_HASH as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PROPOSALS_HASH) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 32 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_DIFFICULTY as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_DIFFICULTY) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.difficulty() {
                            f.verify()?;
                        }
                    }
                }

                if Self::VT_NONCE as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_NONCE) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 8 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_PROOF as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PROOF) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.proof() {
                            f.verify()?;
                        }
                    }
                }

                if Self::VT_UNCLES_HASH as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_UNCLES_HASH) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 32 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_UNCLES_COUNT as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_UNCLES_COUNT) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 4 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_EPOCH as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_EPOCH) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 8 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_DAO as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_DAO) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.dao() {
                            f.verify()?;
                        }
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::Headers<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_HEADERS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_HEADERS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let headers_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        headers_verifier
                            .verify_reference_elements::<reader::Header>()?;
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::Identify<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_NAME as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_NAME) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        StringVerifier::follow(buf, try_follow_uoffset(buf, tab.loc + voffset)?).verify()?;
                    }
                }

                if Self::VT_FLAG as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_FLAG) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 8 {
                        return Err(Error::OutOfBounds);
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::IndexTransaction<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_INDEX as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_INDEX) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 4 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_TRANSACTION as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_TRANSACTION) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.transaction() {
                            f.verify()?;
                        }
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::MerkleProof<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_INDICES as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_INDICES) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let indices_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        indices_verifier.verify_scalar_elements(4)?;
                    }
                }

                if Self::VT_LEMMAS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_LEMMAS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let lemmas_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        lemmas_verifier.verify_scalar_elements(32)?;
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::OutPoint<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_BLOCK_HASH as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_BLOCK_HASH) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 32 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_TX_HASH as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_TX_HASH) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 32 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_INDEX as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_INDEX) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 4 {
                        return Err(Error::OutOfBounds);
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::RelayMessage<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_PAYLOAD_TYPE as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PAYLOAD_TYPE) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 1 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_PAYLOAD as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PAYLOAD) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        match self.payload_type() {
                            reader::RelayPayload::CompactBlock => self
                                .payload_as_compact_block()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::RelayPayload::RelayTransaction => self
                                .payload_as_relay_transaction()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::RelayPayload::RelayTransactionHash => self
                                .payload_as_relay_transaction_hash()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::RelayPayload::GetRelayTransaction => self
                                .payload_as_get_relay_transaction()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::RelayPayload::GetBlockTransactions => self
                                .payload_as_get_block_transactions()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::RelayPayload::BlockTransactions => self
                                .payload_as_block_transactions()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::RelayPayload::GetBlockProposal => self
                                .payload_as_get_block_proposal()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::RelayPayload::BlockProposal => self
                                .payload_as_block_proposal()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::RelayPayload::NONE => return Err(Error::UnmatchedUnion),
                        }
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::RelayTransaction<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_CYCLES as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_CYCLES) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 8 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_TRANSACTION as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_TRANSACTION) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.transaction() {
                            f.verify()?;
                        }
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::RelayTransactionHash<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_TX_HASH as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_TX_HASH) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 32 {
                        return Err(Error::OutOfBounds);
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::Script<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_ARGS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_ARGS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let args_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        args_verifier
                            .verify_reference_elements::<reader::Bytes>()?;
                    }
                }

                if Self::VT_CODE_HASH as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_CODE_HASH) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 32 {
                        return Err(Error::OutOfBounds);
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::SetFilter<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_FILTER as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_FILTER) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let filter_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        filter_verifier.verify_scalar_elements(1)?;
                    }
                }

                if Self::VT_NUM_HASHES as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_NUM_HASHES) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 1 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_HASH_SEED as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_HASH_SEED) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 4 {
                        return Err(Error::OutOfBounds);
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::SyncMessage<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_PAYLOAD_TYPE as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PAYLOAD_TYPE) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 1 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_PAYLOAD as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PAYLOAD) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        match self.payload_type() {
                            reader::SyncPayload::GetHeaders => self
                                .payload_as_get_headers()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::SyncPayload::Headers => self
                                .payload_as_headers()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::SyncPayload::GetBlocks => self
                                .payload_as_get_blocks()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::SyncPayload::Block => self
                                .payload_as_block()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::SyncPayload::SetFilter => self
                                .payload_as_set_filter()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::SyncPayload::AddFilter => self
                                .payload_as_add_filter()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::SyncPayload::ClearFilter => self
                                .payload_as_clear_filter()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::SyncPayload::FilteredBlock => self
                                .payload_as_filtered_block()
                                .ok_or(Error::UnmatchedUnion)?
                                .verify()?,
                            reader::SyncPayload::NONE => return Err(Error::UnmatchedUnion),
                        }
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::Time<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_TIMESTAMP as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_TIMESTAMP) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 8 {
                        return Err(Error::OutOfBounds);
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::TimeMessage<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_PAYLOAD as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PAYLOAD) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.payload() {
                            f.verify()?;
                        }
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::Transaction<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_VERSION as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_VERSION) as usize;
                    if voffset > 0 && object_inline_num_bytes - voffset < 4 {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_DEPS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_DEPS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let deps_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        deps_verifier
                            .verify_reference_elements::<reader::OutPoint>()?;
                    }
                }

                if Self::VT_INPUTS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_INPUTS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let inputs_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        inputs_verifier
                            .verify_reference_elements::<reader::CellInput>()?;
                    }
                }

                if Self::VT_OUTPUTS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_OUTPUTS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let outputs_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        outputs_verifier
                            .verify_reference_elements::<reader::CellOutput>()?;
                    }
                }

                if Self::VT_WITNESSES as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_WITNESSES) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let witnesses_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        witnesses_verifier
                            .verify_reference_elements::<reader::Witness>()?;
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::UncleBlock<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_HEADER as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_HEADER) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        if let Some(f) = self.header() {
                            f.verify()?;
                        }
                    }
                }

                if Self::VT_PROPOSALS as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_PROPOSALS) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let proposals_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        proposals_verifier.verify_scalar_elements(10)?;
                    }
                }

                Ok(())
            }
        }

        impl<'a> Verify for reader::Witness<'a> {
            fn verify(&self) -> Result {
                let tab = self._tab;
                let buf = tab.buf;
                let buf_len = buf.len();

                if tab.loc > MAX_OFFSET_LOC || tab.loc + flatbuffers::SIZE_SOFFSET > buf_len {
                    return Err(Error::OutOfBounds);
                }

                let vtab_loc = {
                    let soffset_slice = &buf[tab.loc..];
                    let soffset = flatbuffers::read_scalar::<flatbuffers::SOffsetT>(soffset_slice);
                    if soffset >= 0 {
                        tab.loc.checked_sub(soffset as usize)
                    } else {
                        soffset
                            .checked_neg()
                            .and_then(|foffset| tab.loc.checked_add(foffset as usize))
                    }
                }
                .ok_or(Error::OutOfBounds)?;
                if vtab_loc
                    .checked_add(flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                let vtab = tab.vtable();
                let vtab_num_bytes = vtab.num_bytes();
                let object_inline_num_bytes = vtab.object_inline_num_bytes();
                if vtab_num_bytes < flatbuffers::SIZE_VOFFSET + flatbuffers::SIZE_VOFFSET
                    || object_inline_num_bytes < flatbuffers::SIZE_SOFFSET
                {
                    return Err(Error::OutOfBounds);
                }
                if vtab_loc
                    .checked_add(vtab_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }
                if tab
                    .loc
                    .checked_add(object_inline_num_bytes)
                    .filter(|loc| *loc <= buf_len)
                    .is_none()
                {
                    return Err(Error::OutOfBounds);
                }

                for i in 0..vtab.num_fields() {
                    let voffset = vtab.get_field(i) as usize;
                    if (voffset > 0 && voffset < flatbuffers::SIZE_SOFFSET)
                        || voffset >= object_inline_num_bytes
                    {
                        return Err(Error::OutOfBounds);
                    }
                }

                if Self::VT_DATA as usize + flatbuffers::SIZE_VOFFSET
                    <= vtab_num_bytes
                {
                    let voffset = vtab.get(Self::VT_DATA) as usize;
                    if voffset > 0 {
                        if voffset + 4 > object_inline_num_bytes {
                            return Err(Error::OutOfBounds);
                        }

                        let data_verifier = VectorVerifier::follow(
                            buf,
                            try_follow_uoffset(buf, tab.loc + voffset)?,
                        );
                        data_verifier
                            .verify_reference_elements::<reader::Bytes>()?;
                    }
                }

                Ok(())
            }
        }
    }

}
