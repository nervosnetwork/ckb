// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod ckb {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
#[allow(unused_imports, dead_code)]
pub mod protocol {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum SyncPayload {
  NONE = 0,
  GetHeaders = 1,
  Headers = 2,
  GetBlocks = 3,
  Block = 4,
  SetFilter = 5,
  AddFilter = 6,
  ClearFilter = 7,
  FilteredBlock = 8,
  InIBD = 9,

}

const ENUM_MIN_SYNC_PAYLOAD: u8 = 0;
const ENUM_MAX_SYNC_PAYLOAD: u8 = 9;

impl<'a> flatbuffers::Follow<'a> for SyncPayload {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for SyncPayload {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const SyncPayload;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const SyncPayload;
    unsafe { *p }
  }
}

impl flatbuffers::Push for SyncPayload {
    type Output = SyncPayload;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<SyncPayload>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_SYNC_PAYLOAD:[SyncPayload; 10] = [
  SyncPayload::NONE,
  SyncPayload::GetHeaders,
  SyncPayload::Headers,
  SyncPayload::GetBlocks,
  SyncPayload::Block,
  SyncPayload::SetFilter,
  SyncPayload::AddFilter,
  SyncPayload::ClearFilter,
  SyncPayload::FilteredBlock,
  SyncPayload::InIBD
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_SYNC_PAYLOAD:[&'static str; 10] = [
    "NONE",
    "GetHeaders",
    "Headers",
    "GetBlocks",
    "Block",
    "SetFilter",
    "AddFilter",
    "ClearFilter",
    "FilteredBlock",
    "InIBD"
];

pub fn enum_name_sync_payload(e: SyncPayload) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_SYNC_PAYLOAD[index as usize]
}

pub struct SyncPayloadUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum RelayPayload {
  NONE = 0,
  CompactBlock = 1,
  RelayTransactions = 2,
  RelayTransactionHashes = 3,
  GetRelayTransactions = 4,
  GetBlockTransactions = 5,
  BlockTransactions = 6,
  GetBlockProposal = 7,
  BlockProposal = 8,

}

const ENUM_MIN_RELAY_PAYLOAD: u8 = 0;
const ENUM_MAX_RELAY_PAYLOAD: u8 = 8;

impl<'a> flatbuffers::Follow<'a> for RelayPayload {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for RelayPayload {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const RelayPayload;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const RelayPayload;
    unsafe { *p }
  }
}

impl flatbuffers::Push for RelayPayload {
    type Output = RelayPayload;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<RelayPayload>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_RELAY_PAYLOAD:[RelayPayload; 9] = [
  RelayPayload::NONE,
  RelayPayload::CompactBlock,
  RelayPayload::RelayTransactions,
  RelayPayload::RelayTransactionHashes,
  RelayPayload::GetRelayTransactions,
  RelayPayload::GetBlockTransactions,
  RelayPayload::BlockTransactions,
  RelayPayload::GetBlockProposal,
  RelayPayload::BlockProposal
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_RELAY_PAYLOAD:[&'static str; 9] = [
    "NONE",
    "CompactBlock",
    "RelayTransactions",
    "RelayTransactionHashes",
    "GetRelayTransactions",
    "GetBlockTransactions",
    "BlockTransactions",
    "GetBlockProposal",
    "BlockProposal"
];

pub fn enum_name_relay_payload(e: RelayPayload) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_RELAY_PAYLOAD[index as usize]
}

pub struct RelayPayloadUnionTableOffset {}
// struct ProposalShortId, aligned to 1
#[repr(C, align(1))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct ProposalShortId {
  u0_: u8,
  u1_: u8,
  u2_: u8,
  u3_: u8,
  u4_: u8,
  u5_: u8,
  u6_: u8,
  u7_: u8,
  u8__: u8,
  u9_: u8,
} // pub struct ProposalShortId
impl flatbuffers::SafeSliceAccess for ProposalShortId {}
impl<'a> flatbuffers::Follow<'a> for ProposalShortId {
  type Inner = &'a ProposalShortId;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a ProposalShortId>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a ProposalShortId {
  type Inner = &'a ProposalShortId;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<ProposalShortId>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for ProposalShortId {
    type Output = ProposalShortId;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const ProposalShortId as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b ProposalShortId {
    type Output = ProposalShortId;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const ProposalShortId as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl ProposalShortId {
  pub fn new<'a>(_u0: u8, _u1: u8, _u2: u8, _u3: u8, _u4: u8, _u5: u8, _u6: u8, _u7: u8, _u8_: u8, _u9: u8) -> Self {
    ProposalShortId {
      u0_: _u0.to_little_endian(),
      u1_: _u1.to_little_endian(),
      u2_: _u2.to_little_endian(),
      u3_: _u3.to_little_endian(),
      u4_: _u4.to_little_endian(),
      u5_: _u5.to_little_endian(),
      u6_: _u6.to_little_endian(),
      u7_: _u7.to_little_endian(),
      u8__: _u8_.to_little_endian(),
      u9_: _u9.to_little_endian(),

    }
  }
  pub fn u0<'a>(&'a self) -> u8 {
    self.u0_.from_little_endian()
  }
  pub fn u1<'a>(&'a self) -> u8 {
    self.u1_.from_little_endian()
  }
  pub fn u2<'a>(&'a self) -> u8 {
    self.u2_.from_little_endian()
  }
  pub fn u3<'a>(&'a self) -> u8 {
    self.u3_.from_little_endian()
  }
  pub fn u4<'a>(&'a self) -> u8 {
    self.u4_.from_little_endian()
  }
  pub fn u5<'a>(&'a self) -> u8 {
    self.u5_.from_little_endian()
  }
  pub fn u6<'a>(&'a self) -> u8 {
    self.u6_.from_little_endian()
  }
  pub fn u7<'a>(&'a self) -> u8 {
    self.u7_.from_little_endian()
  }
  pub fn u8_<'a>(&'a self) -> u8 {
    self.u8__.from_little_endian()
  }
  pub fn u9<'a>(&'a self) -> u8 {
    self.u9_.from_little_endian()
  }
}

// struct H256, aligned to 1
#[repr(C, align(1))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct H256 {
  u0_: u8,
  u1_: u8,
  u2_: u8,
  u3_: u8,
  u4_: u8,
  u5_: u8,
  u6_: u8,
  u7_: u8,
  u8__: u8,
  u9_: u8,
  u10_: u8,
  u11_: u8,
  u12_: u8,
  u13_: u8,
  u14_: u8,
  u15_: u8,
  u16__: u8,
  u17_: u8,
  u18_: u8,
  u19_: u8,
  u20_: u8,
  u21_: u8,
  u22_: u8,
  u23_: u8,
  u24_: u8,
  u25_: u8,
  u26_: u8,
  u27_: u8,
  u28_: u8,
  u29_: u8,
  u30_: u8,
  u31_: u8,
} // pub struct H256
impl flatbuffers::SafeSliceAccess for H256 {}
impl<'a> flatbuffers::Follow<'a> for H256 {
  type Inner = &'a H256;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a H256>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a H256 {
  type Inner = &'a H256;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<H256>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for H256 {
    type Output = H256;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const H256 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b H256 {
    type Output = H256;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const H256 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl H256 {
  pub fn new<'a>(_u0: u8, _u1: u8, _u2: u8, _u3: u8, _u4: u8, _u5: u8, _u6: u8, _u7: u8, _u8_: u8, _u9: u8, _u10: u8, _u11: u8, _u12: u8, _u13: u8, _u14: u8, _u15: u8, _u16_: u8, _u17: u8, _u18: u8, _u19: u8, _u20: u8, _u21: u8, _u22: u8, _u23: u8, _u24: u8, _u25: u8, _u26: u8, _u27: u8, _u28: u8, _u29: u8, _u30: u8, _u31: u8) -> Self {
    H256 {
      u0_: _u0.to_little_endian(),
      u1_: _u1.to_little_endian(),
      u2_: _u2.to_little_endian(),
      u3_: _u3.to_little_endian(),
      u4_: _u4.to_little_endian(),
      u5_: _u5.to_little_endian(),
      u6_: _u6.to_little_endian(),
      u7_: _u7.to_little_endian(),
      u8__: _u8_.to_little_endian(),
      u9_: _u9.to_little_endian(),
      u10_: _u10.to_little_endian(),
      u11_: _u11.to_little_endian(),
      u12_: _u12.to_little_endian(),
      u13_: _u13.to_little_endian(),
      u14_: _u14.to_little_endian(),
      u15_: _u15.to_little_endian(),
      u16__: _u16_.to_little_endian(),
      u17_: _u17.to_little_endian(),
      u18_: _u18.to_little_endian(),
      u19_: _u19.to_little_endian(),
      u20_: _u20.to_little_endian(),
      u21_: _u21.to_little_endian(),
      u22_: _u22.to_little_endian(),
      u23_: _u23.to_little_endian(),
      u24_: _u24.to_little_endian(),
      u25_: _u25.to_little_endian(),
      u26_: _u26.to_little_endian(),
      u27_: _u27.to_little_endian(),
      u28_: _u28.to_little_endian(),
      u29_: _u29.to_little_endian(),
      u30_: _u30.to_little_endian(),
      u31_: _u31.to_little_endian(),

    }
  }
  pub fn u0<'a>(&'a self) -> u8 {
    self.u0_.from_little_endian()
  }
  pub fn u1<'a>(&'a self) -> u8 {
    self.u1_.from_little_endian()
  }
  pub fn u2<'a>(&'a self) -> u8 {
    self.u2_.from_little_endian()
  }
  pub fn u3<'a>(&'a self) -> u8 {
    self.u3_.from_little_endian()
  }
  pub fn u4<'a>(&'a self) -> u8 {
    self.u4_.from_little_endian()
  }
  pub fn u5<'a>(&'a self) -> u8 {
    self.u5_.from_little_endian()
  }
  pub fn u6<'a>(&'a self) -> u8 {
    self.u6_.from_little_endian()
  }
  pub fn u7<'a>(&'a self) -> u8 {
    self.u7_.from_little_endian()
  }
  pub fn u8_<'a>(&'a self) -> u8 {
    self.u8__.from_little_endian()
  }
  pub fn u9<'a>(&'a self) -> u8 {
    self.u9_.from_little_endian()
  }
  pub fn u10<'a>(&'a self) -> u8 {
    self.u10_.from_little_endian()
  }
  pub fn u11<'a>(&'a self) -> u8 {
    self.u11_.from_little_endian()
  }
  pub fn u12<'a>(&'a self) -> u8 {
    self.u12_.from_little_endian()
  }
  pub fn u13<'a>(&'a self) -> u8 {
    self.u13_.from_little_endian()
  }
  pub fn u14<'a>(&'a self) -> u8 {
    self.u14_.from_little_endian()
  }
  pub fn u15<'a>(&'a self) -> u8 {
    self.u15_.from_little_endian()
  }
  pub fn u16_<'a>(&'a self) -> u8 {
    self.u16__.from_little_endian()
  }
  pub fn u17<'a>(&'a self) -> u8 {
    self.u17_.from_little_endian()
  }
  pub fn u18<'a>(&'a self) -> u8 {
    self.u18_.from_little_endian()
  }
  pub fn u19<'a>(&'a self) -> u8 {
    self.u19_.from_little_endian()
  }
  pub fn u20<'a>(&'a self) -> u8 {
    self.u20_.from_little_endian()
  }
  pub fn u21<'a>(&'a self) -> u8 {
    self.u21_.from_little_endian()
  }
  pub fn u22<'a>(&'a self) -> u8 {
    self.u22_.from_little_endian()
  }
  pub fn u23<'a>(&'a self) -> u8 {
    self.u23_.from_little_endian()
  }
  pub fn u24<'a>(&'a self) -> u8 {
    self.u24_.from_little_endian()
  }
  pub fn u25<'a>(&'a self) -> u8 {
    self.u25_.from_little_endian()
  }
  pub fn u26<'a>(&'a self) -> u8 {
    self.u26_.from_little_endian()
  }
  pub fn u27<'a>(&'a self) -> u8 {
    self.u27_.from_little_endian()
  }
  pub fn u28<'a>(&'a self) -> u8 {
    self.u28_.from_little_endian()
  }
  pub fn u29<'a>(&'a self) -> u8 {
    self.u29_.from_little_endian()
  }
  pub fn u30<'a>(&'a self) -> u8 {
    self.u30_.from_little_endian()
  }
  pub fn u31<'a>(&'a self) -> u8 {
    self.u31_.from_little_endian()
  }
}

pub enum SyncMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SyncMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SyncMessage<'a> {
    type Inner = SyncMessage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SyncMessage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SyncMessage {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SyncMessageArgs) -> flatbuffers::WIPOffset<SyncMessage<'bldr>> {
      let mut builder = SyncMessageBuilder::new(_fbb);
      if let Some(x) = args.payload { builder.add_payload(x); }
      builder.add_payload_type(args.payload_type);
      builder.finish()
    }

    pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn payload_type(&self) -> SyncPayload {
    self._tab.get::<SyncPayload>(SyncMessage::VT_PAYLOAD_TYPE, Some(SyncPayload::NONE)).unwrap()
  }
  #[inline]
  pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(SyncMessage::VT_PAYLOAD, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_get_headers(&self) -> Option<GetHeaders<'a>> {
    if self.payload_type() == SyncPayload::GetHeaders {
      self.payload().map(|u| GetHeaders::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_headers(&self) -> Option<Headers<'a>> {
    if self.payload_type() == SyncPayload::Headers {
      self.payload().map(|u| Headers::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_get_blocks(&self) -> Option<GetBlocks<'a>> {
    if self.payload_type() == SyncPayload::GetBlocks {
      self.payload().map(|u| GetBlocks::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_block(&self) -> Option<Block<'a>> {
    if self.payload_type() == SyncPayload::Block {
      self.payload().map(|u| Block::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_set_filter(&self) -> Option<SetFilter<'a>> {
    if self.payload_type() == SyncPayload::SetFilter {
      self.payload().map(|u| SetFilter::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_add_filter(&self) -> Option<AddFilter<'a>> {
    if self.payload_type() == SyncPayload::AddFilter {
      self.payload().map(|u| AddFilter::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_clear_filter(&self) -> Option<ClearFilter<'a>> {
    if self.payload_type() == SyncPayload::ClearFilter {
      self.payload().map(|u| ClearFilter::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_filtered_block(&self) -> Option<FilteredBlock<'a>> {
    if self.payload_type() == SyncPayload::FilteredBlock {
      self.payload().map(|u| FilteredBlock::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_in_ibd(&self) -> Option<InIBD<'a>> {
    if self.payload_type() == SyncPayload::InIBD {
      self.payload().map(|u| InIBD::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct SyncMessageArgs {
    pub payload_type: SyncPayload,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SyncMessageArgs {
    #[inline]
    fn default() -> Self {
        SyncMessageArgs {
            payload_type: SyncPayload::NONE,
            payload: None,
        }
    }
}
pub struct SyncMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SyncMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_payload_type(&mut self, payload_type: SyncPayload) {
    self.fbb_.push_slot::<SyncPayload>(SyncMessage::VT_PAYLOAD_TYPE, payload_type, SyncPayload::NONE);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SyncMessage::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SyncMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SyncMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SyncMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BytesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Bytes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bytes<'a> {
    type Inner = Bytes<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Bytes<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Bytes {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BytesArgs<'args>) -> flatbuffers::WIPOffset<Bytes<'bldr>> {
      let mut builder = BytesBuilder::new(_fbb);
      if let Some(x) = args.seq { builder.add_seq(x); }
      builder.finish()
    }

    pub const VT_SEQ: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn seq(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Bytes::VT_SEQ, None).map(|v| v.safe_slice())
  }
}

pub struct BytesArgs<'a> {
    pub seq: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for BytesArgs<'a> {
    #[inline]
    fn default() -> Self {
        BytesArgs {
            seq: None,
        }
    }
}
pub struct BytesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BytesBuilder<'a, 'b> {
  #[inline]
  pub fn add_seq(&mut self, seq: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bytes::VT_SEQ, seq);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BytesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BytesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Bytes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GetHeadersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetHeaders<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetHeaders<'a> {
    type Inner = GetHeaders<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetHeaders<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetHeaders {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetHeadersArgs<'args>) -> flatbuffers::WIPOffset<GetHeaders<'bldr>> {
      let mut builder = GetHeadersBuilder::new(_fbb);
      if let Some(x) = args.hash_stop { builder.add_hash_stop(x); }
      if let Some(x) = args.block_locator_hashes { builder.add_block_locator_hashes(x); }
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_BLOCK_LOCATOR_HASHES: flatbuffers::VOffsetT = 6;
    pub const VT_HASH_STOP: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(GetHeaders::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn block_locator_hashes(&self) -> Option<&'a [H256]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<H256>>>(GetHeaders::VT_BLOCK_LOCATOR_HASHES, None).map(|v| v.safe_slice() )
  }
  #[inline]
  pub fn hash_stop(&self) -> Option<&'a H256> {
    self._tab.get::<H256>(GetHeaders::VT_HASH_STOP, None)
  }
}

pub struct GetHeadersArgs<'a> {
    pub version: u32,
    pub block_locator_hashes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , H256>>>,
    pub hash_stop: Option<&'a  H256>,
}
impl<'a> Default for GetHeadersArgs<'a> {
    #[inline]
    fn default() -> Self {
        GetHeadersArgs {
            version: 0,
            block_locator_hashes: None,
            hash_stop: None,
        }
    }
}
pub struct GetHeadersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetHeadersBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(GetHeaders::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_block_locator_hashes(&mut self, block_locator_hashes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , H256>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetHeaders::VT_BLOCK_LOCATOR_HASHES, block_locator_hashes);
  }
  #[inline]
  pub fn add_hash_stop(&mut self, hash_stop: &'b  H256) {
    self.fbb_.push_slot_always::<&H256>(GetHeaders::VT_HASH_STOP, hash_stop);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetHeadersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetHeadersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetHeaders<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GetBlocksOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetBlocks<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetBlocks<'a> {
    type Inner = GetBlocks<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetBlocks<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetBlocks {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetBlocksArgs<'args>) -> flatbuffers::WIPOffset<GetBlocks<'bldr>> {
      let mut builder = GetBlocksBuilder::new(_fbb);
      if let Some(x) = args.block_hashes { builder.add_block_hashes(x); }
      builder.finish()
    }

    pub const VT_BLOCK_HASHES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn block_hashes(&self) -> Option<&'a [H256]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<H256>>>(GetBlocks::VT_BLOCK_HASHES, None).map(|v| v.safe_slice() )
  }
}

pub struct GetBlocksArgs<'a> {
    pub block_hashes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , H256>>>,
}
impl<'a> Default for GetBlocksArgs<'a> {
    #[inline]
    fn default() -> Self {
        GetBlocksArgs {
            block_hashes: None,
        }
    }
}
pub struct GetBlocksBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetBlocksBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_hashes(&mut self, block_hashes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , H256>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetBlocks::VT_BLOCK_HASHES, block_hashes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetBlocksBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetBlocksBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetBlocks<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HeadersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Headers<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Headers<'a> {
    type Inner = Headers<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Headers<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Headers {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HeadersArgs<'args>) -> flatbuffers::WIPOffset<Headers<'bldr>> {
      let mut builder = HeadersBuilder::new(_fbb);
      if let Some(x) = args.headers { builder.add_headers(x); }
      builder.finish()
    }

    pub const VT_HEADERS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn headers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Header<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Header<'a>>>>>(Headers::VT_HEADERS, None)
  }
}

pub struct HeadersArgs<'a> {
    pub headers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Header<'a >>>>>,
}
impl<'a> Default for HeadersArgs<'a> {
    #[inline]
    fn default() -> Self {
        HeadersArgs {
            headers: None,
        }
    }
}
pub struct HeadersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HeadersBuilder<'a, 'b> {
  #[inline]
  pub fn add_headers(&mut self, headers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Header<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Headers::VT_HEADERS, headers);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HeadersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HeadersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Headers<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum HeaderOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Header<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Header<'a> {
    type Inner = Header<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Header<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Header {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HeaderArgs<'args>) -> flatbuffers::WIPOffset<Header<'bldr>> {
      let mut builder = HeaderBuilder::new(_fbb);
      builder.add_epoch(args.epoch);
      builder.add_nonce(args.nonce);
      builder.add_number(args.number);
      builder.add_timestamp(args.timestamp);
      if let Some(x) = args.dao { builder.add_dao(x); }
      builder.add_uncles_count(args.uncles_count);
      if let Some(x) = args.uncles_hash { builder.add_uncles_hash(x); }
      if let Some(x) = args.proof { builder.add_proof(x); }
      if let Some(x) = args.difficulty { builder.add_difficulty(x); }
      if let Some(x) = args.proposals_hash { builder.add_proposals_hash(x); }
      if let Some(x) = args.witnesses_root { builder.add_witnesses_root(x); }
      if let Some(x) = args.transactions_root { builder.add_transactions_root(x); }
      if let Some(x) = args.parent_hash { builder.add_parent_hash(x); }
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_PARENT_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 8;
    pub const VT_NUMBER: flatbuffers::VOffsetT = 10;
    pub const VT_TRANSACTIONS_ROOT: flatbuffers::VOffsetT = 12;
    pub const VT_WITNESSES_ROOT: flatbuffers::VOffsetT = 14;
    pub const VT_PROPOSALS_HASH: flatbuffers::VOffsetT = 16;
    pub const VT_DIFFICULTY: flatbuffers::VOffsetT = 18;
    pub const VT_NONCE: flatbuffers::VOffsetT = 20;
    pub const VT_PROOF: flatbuffers::VOffsetT = 22;
    pub const VT_UNCLES_HASH: flatbuffers::VOffsetT = 24;
    pub const VT_UNCLES_COUNT: flatbuffers::VOffsetT = 26;
    pub const VT_EPOCH: flatbuffers::VOffsetT = 28;
    pub const VT_DAO: flatbuffers::VOffsetT = 30;

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(Header::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn parent_hash(&self) -> Option<&'a H256> {
    self._tab.get::<H256>(Header::VT_PARENT_HASH, None)
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    self._tab.get::<u64>(Header::VT_TIMESTAMP, Some(0)).unwrap()
  }
  #[inline]
  pub fn number(&self) -> u64 {
    self._tab.get::<u64>(Header::VT_NUMBER, Some(0)).unwrap()
  }
  #[inline]
  pub fn transactions_root(&self) -> Option<&'a H256> {
    self._tab.get::<H256>(Header::VT_TRANSACTIONS_ROOT, None)
  }
  #[inline]
  pub fn witnesses_root(&self) -> Option<&'a H256> {
    self._tab.get::<H256>(Header::VT_WITNESSES_ROOT, None)
  }
  #[inline]
  pub fn proposals_hash(&self) -> Option<&'a H256> {
    self._tab.get::<H256>(Header::VT_PROPOSALS_HASH, None)
  }
  #[inline]
  pub fn difficulty(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Header::VT_DIFFICULTY, None)
  }
  #[inline]
  pub fn nonce(&self) -> u64 {
    self._tab.get::<u64>(Header::VT_NONCE, Some(0)).unwrap()
  }
  #[inline]
  pub fn proof(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Header::VT_PROOF, None)
  }
  #[inline]
  pub fn uncles_hash(&self) -> Option<&'a H256> {
    self._tab.get::<H256>(Header::VT_UNCLES_HASH, None)
  }
  #[inline]
  pub fn uncles_count(&self) -> u32 {
    self._tab.get::<u32>(Header::VT_UNCLES_COUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn epoch(&self) -> u64 {
    self._tab.get::<u64>(Header::VT_EPOCH, Some(0)).unwrap()
  }
  #[inline]
  pub fn dao(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Header::VT_DAO, None)
  }
}

pub struct HeaderArgs<'a> {
    pub version: u32,
    pub parent_hash: Option<&'a  H256>,
    pub timestamp: u64,
    pub number: u64,
    pub transactions_root: Option<&'a  H256>,
    pub witnesses_root: Option<&'a  H256>,
    pub proposals_hash: Option<&'a  H256>,
    pub difficulty: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub nonce: u64,
    pub proof: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub uncles_hash: Option<&'a  H256>,
    pub uncles_count: u32,
    pub epoch: u64,
    pub dao: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
}
impl<'a> Default for HeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        HeaderArgs {
            version: 0,
            parent_hash: None,
            timestamp: 0,
            number: 0,
            transactions_root: None,
            witnesses_root: None,
            proposals_hash: None,
            difficulty: None,
            nonce: 0,
            proof: None,
            uncles_hash: None,
            uncles_count: 0,
            epoch: 0,
            dao: None,
        }
    }
}
pub struct HeaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HeaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(Header::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_parent_hash(&mut self, parent_hash: &'b  H256) {
    self.fbb_.push_slot_always::<&H256>(Header::VT_PARENT_HASH, parent_hash);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(Header::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_number(&mut self, number: u64) {
    self.fbb_.push_slot::<u64>(Header::VT_NUMBER, number, 0);
  }
  #[inline]
  pub fn add_transactions_root(&mut self, transactions_root: &'b  H256) {
    self.fbb_.push_slot_always::<&H256>(Header::VT_TRANSACTIONS_ROOT, transactions_root);
  }
  #[inline]
  pub fn add_witnesses_root(&mut self, witnesses_root: &'b  H256) {
    self.fbb_.push_slot_always::<&H256>(Header::VT_WITNESSES_ROOT, witnesses_root);
  }
  #[inline]
  pub fn add_proposals_hash(&mut self, proposals_hash: &'b  H256) {
    self.fbb_.push_slot_always::<&H256>(Header::VT_PROPOSALS_HASH, proposals_hash);
  }
  #[inline]
  pub fn add_difficulty(&mut self, difficulty: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Header::VT_DIFFICULTY, difficulty);
  }
  #[inline]
  pub fn add_nonce(&mut self, nonce: u64) {
    self.fbb_.push_slot::<u64>(Header::VT_NONCE, nonce, 0);
  }
  #[inline]
  pub fn add_proof(&mut self, proof: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Header::VT_PROOF, proof);
  }
  #[inline]
  pub fn add_uncles_hash(&mut self, uncles_hash: &'b  H256) {
    self.fbb_.push_slot_always::<&H256>(Header::VT_UNCLES_HASH, uncles_hash);
  }
  #[inline]
  pub fn add_uncles_count(&mut self, uncles_count: u32) {
    self.fbb_.push_slot::<u32>(Header::VT_UNCLES_COUNT, uncles_count, 0);
  }
  #[inline]
  pub fn add_epoch(&mut self, epoch: u64) {
    self.fbb_.push_slot::<u64>(Header::VT_EPOCH, epoch, 0);
  }
  #[inline]
  pub fn add_dao(&mut self, dao: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Header::VT_DAO, dao);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HeaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Header<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Block<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Block<'a> {
    type Inner = Block<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Block<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Block {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockArgs<'args>) -> flatbuffers::WIPOffset<Block<'bldr>> {
      let mut builder = BlockBuilder::new(_fbb);
      if let Some(x) = args.proposals { builder.add_proposals(x); }
      if let Some(x) = args.transactions { builder.add_transactions(x); }
      if let Some(x) = args.uncles { builder.add_uncles(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_UNCLES: flatbuffers::VOffsetT = 6;
    pub const VT_TRANSACTIONS: flatbuffers::VOffsetT = 8;
    pub const VT_PROPOSALS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn header(&self) -> Option<Header<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Header<'a>>>(Block::VT_HEADER, None)
  }
  #[inline]
  pub fn uncles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UncleBlock<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<UncleBlock<'a>>>>>(Block::VT_UNCLES, None)
  }
  #[inline]
  pub fn transactions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Transaction<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>>>>(Block::VT_TRANSACTIONS, None)
  }
  #[inline]
  pub fn proposals(&self) -> Option<&'a [ProposalShortId]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<ProposalShortId>>>(Block::VT_PROPOSALS, None).map(|v| v.safe_slice() )
  }
}

pub struct BlockArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a >>>,
    pub uncles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<UncleBlock<'a >>>>>,
    pub transactions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Transaction<'a >>>>>,
    pub proposals: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , ProposalShortId>>>,
}
impl<'a> Default for BlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockArgs {
            header: None,
            uncles: None,
            transactions: None,
            proposals: None,
        }
    }
}
pub struct BlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Header>>(Block::VT_HEADER, header);
  }
  #[inline]
  pub fn add_uncles(&mut self, uncles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<UncleBlock<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_UNCLES, uncles);
  }
  #[inline]
  pub fn add_transactions(&mut self, transactions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Transaction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_TRANSACTIONS, transactions);
  }
  #[inline]
  pub fn add_proposals(&mut self, proposals: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ProposalShortId>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_PROPOSALS, proposals);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Block<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum UncleBlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct UncleBlock<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UncleBlock<'a> {
    type Inner = UncleBlock<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> UncleBlock<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UncleBlock {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UncleBlockArgs<'args>) -> flatbuffers::WIPOffset<UncleBlock<'bldr>> {
      let mut builder = UncleBlockBuilder::new(_fbb);
      if let Some(x) = args.proposals { builder.add_proposals(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_PROPOSALS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn header(&self) -> Option<Header<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Header<'a>>>(UncleBlock::VT_HEADER, None)
  }
  #[inline]
  pub fn proposals(&self) -> Option<&'a [ProposalShortId]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<ProposalShortId>>>(UncleBlock::VT_PROPOSALS, None).map(|v| v.safe_slice() )
  }
}

pub struct UncleBlockArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a >>>,
    pub proposals: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , ProposalShortId>>>,
}
impl<'a> Default for UncleBlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        UncleBlockArgs {
            header: None,
            proposals: None,
        }
    }
}
pub struct UncleBlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UncleBlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Header>>(UncleBlock::VT_HEADER, header);
  }
  #[inline]
  pub fn add_proposals(&mut self, proposals: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ProposalShortId>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UncleBlock::VT_PROPOSALS, proposals);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UncleBlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UncleBlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UncleBlock<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TransactionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Transaction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Transaction<'a> {
    type Inner = Transaction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Transaction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Transaction {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TransactionArgs<'args>) -> flatbuffers::WIPOffset<Transaction<'bldr>> {
      let mut builder = TransactionBuilder::new(_fbb);
      if let Some(x) = args.witnesses { builder.add_witnesses(x); }
      if let Some(x) = args.outputs_data { builder.add_outputs_data(x); }
      if let Some(x) = args.outputs { builder.add_outputs(x); }
      if let Some(x) = args.inputs { builder.add_inputs(x); }
      if let Some(x) = args.deps { builder.add_deps(x); }
      builder.add_version(args.version);
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_DEPS: flatbuffers::VOffsetT = 6;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 8;
    pub const VT_OUTPUTS: flatbuffers::VOffsetT = 10;
    pub const VT_OUTPUTS_DATA: flatbuffers::VOffsetT = 12;
    pub const VT_WITNESSES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(Transaction::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn deps(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutPoint<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<OutPoint<'a>>>>>(Transaction::VT_DEPS, None)
  }
  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CellInput<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CellInput<'a>>>>>(Transaction::VT_INPUTS, None)
  }
  #[inline]
  pub fn outputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CellOutput<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CellOutput<'a>>>>>(Transaction::VT_OUTPUTS, None)
  }
  #[inline]
  pub fn outputs_data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>>>(Transaction::VT_OUTPUTS_DATA, None)
  }
  #[inline]
  pub fn witnesses(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Witness<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Witness<'a>>>>>(Transaction::VT_WITNESSES, None)
  }
}

pub struct TransactionArgs<'a> {
    pub version: u32,
    pub deps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<OutPoint<'a >>>>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CellInput<'a >>>>>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CellOutput<'a >>>>>,
    pub outputs_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Bytes<'a >>>>>,
    pub witnesses: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Witness<'a >>>>>,
}
impl<'a> Default for TransactionArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransactionArgs {
            version: 0,
            deps: None,
            inputs: None,
            outputs: None,
            outputs_data: None,
            witnesses: None,
        }
    }
}
pub struct TransactionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransactionBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(Transaction::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_deps(&mut self, deps: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<OutPoint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_DEPS, deps);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CellInput<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CellOutput<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_OUTPUTS, outputs);
  }
  #[inline]
  pub fn add_outputs_data(&mut self, outputs_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bytes<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_OUTPUTS_DATA, outputs_data);
  }
  #[inline]
  pub fn add_witnesses(&mut self, witnesses: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Witness<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_WITNESSES, witnesses);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransactionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TransactionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Transaction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum WitnessOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Witness<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Witness<'a> {
    type Inner = Witness<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Witness<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Witness {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WitnessArgs<'args>) -> flatbuffers::WIPOffset<Witness<'bldr>> {
      let mut builder = WitnessBuilder::new(_fbb);
      if let Some(x) = args.data { builder.add_data(x); }
      builder.finish()
    }

    pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>>>(Witness::VT_DATA, None)
  }
}

pub struct WitnessArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Bytes<'a >>>>>,
}
impl<'a> Default for WitnessArgs<'a> {
    #[inline]
    fn default() -> Self {
        WitnessArgs {
            data: None,
        }
    }
}
pub struct WitnessBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WitnessBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bytes<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Witness::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WitnessBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WitnessBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Witness<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum OutPointOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct OutPoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OutPoint<'a> {
    type Inner = OutPoint<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> OutPoint<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OutPoint {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OutPointArgs<'args>) -> flatbuffers::WIPOffset<OutPoint<'bldr>> {
      let mut builder = OutPointBuilder::new(_fbb);
      builder.add_index(args.index);
      if let Some(x) = args.tx_hash { builder.add_tx_hash(x); }
      if let Some(x) = args.block_hash { builder.add_block_hash(x); }
      builder.finish()
    }

    pub const VT_BLOCK_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_TX_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_INDEX: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn block_hash(&self) -> Option<&'a H256> {
    self._tab.get::<H256>(OutPoint::VT_BLOCK_HASH, None)
  }
  #[inline]
  pub fn tx_hash(&self) -> Option<&'a H256> {
    self._tab.get::<H256>(OutPoint::VT_TX_HASH, None)
  }
  #[inline]
  pub fn index(&self) -> u32 {
    self._tab.get::<u32>(OutPoint::VT_INDEX, Some(0)).unwrap()
  }
}

pub struct OutPointArgs<'a> {
    pub block_hash: Option<&'a  H256>,
    pub tx_hash: Option<&'a  H256>,
    pub index: u32,
}
impl<'a> Default for OutPointArgs<'a> {
    #[inline]
    fn default() -> Self {
        OutPointArgs {
            block_hash: None,
            tx_hash: None,
            index: 0,
        }
    }
}
pub struct OutPointBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OutPointBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_hash(&mut self, block_hash: &'b  H256) {
    self.fbb_.push_slot_always::<&H256>(OutPoint::VT_BLOCK_HASH, block_hash);
  }
  #[inline]
  pub fn add_tx_hash(&mut self, tx_hash: &'b  H256) {
    self.fbb_.push_slot_always::<&H256>(OutPoint::VT_TX_HASH, tx_hash);
  }
  #[inline]
  pub fn add_index(&mut self, index: u32) {
    self.fbb_.push_slot::<u32>(OutPoint::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OutPointBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OutPointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OutPoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CellInputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CellInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CellInput<'a> {
    type Inner = CellInput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CellInput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CellInput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CellInputArgs<'args>) -> flatbuffers::WIPOffset<CellInput<'bldr>> {
      let mut builder = CellInputBuilder::new(_fbb);
      builder.add_since(args.since);
      builder.add_index(args.index);
      if let Some(x) = args.tx_hash { builder.add_tx_hash(x); }
      if let Some(x) = args.block_hash { builder.add_block_hash(x); }
      builder.finish()
    }

    pub const VT_BLOCK_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_TX_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_INDEX: flatbuffers::VOffsetT = 8;
    pub const VT_SINCE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn block_hash(&self) -> Option<&'a H256> {
    self._tab.get::<H256>(CellInput::VT_BLOCK_HASH, None)
  }
  #[inline]
  pub fn tx_hash(&self) -> Option<&'a H256> {
    self._tab.get::<H256>(CellInput::VT_TX_HASH, None)
  }
  #[inline]
  pub fn index(&self) -> u32 {
    self._tab.get::<u32>(CellInput::VT_INDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn since(&self) -> u64 {
    self._tab.get::<u64>(CellInput::VT_SINCE, Some(0)).unwrap()
  }
}

pub struct CellInputArgs<'a> {
    pub block_hash: Option<&'a  H256>,
    pub tx_hash: Option<&'a  H256>,
    pub index: u32,
    pub since: u64,
}
impl<'a> Default for CellInputArgs<'a> {
    #[inline]
    fn default() -> Self {
        CellInputArgs {
            block_hash: None,
            tx_hash: None,
            index: 0,
            since: 0,
        }
    }
}
pub struct CellInputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CellInputBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_hash(&mut self, block_hash: &'b  H256) {
    self.fbb_.push_slot_always::<&H256>(CellInput::VT_BLOCK_HASH, block_hash);
  }
  #[inline]
  pub fn add_tx_hash(&mut self, tx_hash: &'b  H256) {
    self.fbb_.push_slot_always::<&H256>(CellInput::VT_TX_HASH, tx_hash);
  }
  #[inline]
  pub fn add_index(&mut self, index: u32) {
    self.fbb_.push_slot::<u32>(CellInput::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_since(&mut self, since: u64) {
    self.fbb_.push_slot::<u64>(CellInput::VT_SINCE, since, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CellInputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CellInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CellInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CellOutputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CellOutput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CellOutput<'a> {
    type Inner = CellOutput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CellOutput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CellOutput {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CellOutputArgs<'args>) -> flatbuffers::WIPOffset<CellOutput<'bldr>> {
      let mut builder = CellOutputBuilder::new(_fbb);
      builder.add_capacity(args.capacity);
      if let Some(x) = args.type_ { builder.add_type_(x); }
      if let Some(x) = args.lock { builder.add_lock(x); }
      if let Some(x) = args.data_hash { builder.add_data_hash(x); }
      builder.finish()
    }

    pub const VT_CAPACITY: flatbuffers::VOffsetT = 4;
    pub const VT_DATA_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_LOCK: flatbuffers::VOffsetT = 8;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn capacity(&self) -> u64 {
    self._tab.get::<u64>(CellOutput::VT_CAPACITY, Some(0)).unwrap()
  }
  #[inline]
  pub fn data_hash(&self) -> Option<&'a H256> {
    self._tab.get::<H256>(CellOutput::VT_DATA_HASH, None)
  }
  #[inline]
  pub fn lock(&self) -> Option<Script<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Script<'a>>>(CellOutput::VT_LOCK, None)
  }
  #[inline]
  pub fn type_(&self) -> Option<Script<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Script<'a>>>(CellOutput::VT_TYPE_, None)
  }
}

pub struct CellOutputArgs<'a> {
    pub capacity: u64,
    pub data_hash: Option<&'a  H256>,
    pub lock: Option<flatbuffers::WIPOffset<Script<'a >>>,
    pub type_: Option<flatbuffers::WIPOffset<Script<'a >>>,
}
impl<'a> Default for CellOutputArgs<'a> {
    #[inline]
    fn default() -> Self {
        CellOutputArgs {
            capacity: 0,
            data_hash: None,
            lock: None,
            type_: None,
        }
    }
}
pub struct CellOutputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CellOutputBuilder<'a, 'b> {
  #[inline]
  pub fn add_capacity(&mut self, capacity: u64) {
    self.fbb_.push_slot::<u64>(CellOutput::VT_CAPACITY, capacity, 0);
  }
  #[inline]
  pub fn add_data_hash(&mut self, data_hash: &'b  H256) {
    self.fbb_.push_slot_always::<&H256>(CellOutput::VT_DATA_HASH, data_hash);
  }
  #[inline]
  pub fn add_lock(&mut self, lock: flatbuffers::WIPOffset<Script<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Script>>(CellOutput::VT_LOCK, lock);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<Script<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Script>>(CellOutput::VT_TYPE_, type_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CellOutputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CellOutputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CellOutput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ScriptOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Script<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Script<'a> {
    type Inner = Script<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Script<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Script {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ScriptArgs<'args>) -> flatbuffers::WIPOffset<Script<'bldr>> {
      let mut builder = ScriptBuilder::new(_fbb);
      if let Some(x) = args.code_hash { builder.add_code_hash(x); }
      if let Some(x) = args.args { builder.add_args(x); }
      builder.add_hash_type(args.hash_type);
      builder.finish()
    }

    pub const VT_ARGS: flatbuffers::VOffsetT = 4;
    pub const VT_CODE_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_HASH_TYPE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn args(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>>>(Script::VT_ARGS, None)
  }
  #[inline]
  pub fn code_hash(&self) -> Option<&'a H256> {
    self._tab.get::<H256>(Script::VT_CODE_HASH, None)
  }
  #[inline]
  pub fn hash_type(&self) -> u8 {
    self._tab.get::<u8>(Script::VT_HASH_TYPE, Some(0)).unwrap()
  }
}

pub struct ScriptArgs<'a> {
    pub args: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Bytes<'a >>>>>,
    pub code_hash: Option<&'a  H256>,
    pub hash_type: u8,
}
impl<'a> Default for ScriptArgs<'a> {
    #[inline]
    fn default() -> Self {
        ScriptArgs {
            args: None,
            code_hash: None,
            hash_type: 0,
        }
    }
}
pub struct ScriptBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ScriptBuilder<'a, 'b> {
  #[inline]
  pub fn add_args(&mut self, args: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bytes<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Script::VT_ARGS, args);
  }
  #[inline]
  pub fn add_code_hash(&mut self, code_hash: &'b  H256) {
    self.fbb_.push_slot_always::<&H256>(Script::VT_CODE_HASH, code_hash);
  }
  #[inline]
  pub fn add_hash_type(&mut self, hash_type: u8) {
    self.fbb_.push_slot::<u8>(Script::VT_HASH_TYPE, hash_type, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ScriptBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ScriptBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Script<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RelayMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RelayMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RelayMessage<'a> {
    type Inner = RelayMessage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RelayMessage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RelayMessage {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RelayMessageArgs) -> flatbuffers::WIPOffset<RelayMessage<'bldr>> {
      let mut builder = RelayMessageBuilder::new(_fbb);
      if let Some(x) = args.payload { builder.add_payload(x); }
      builder.add_payload_type(args.payload_type);
      builder.finish()
    }

    pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn payload_type(&self) -> RelayPayload {
    self._tab.get::<RelayPayload>(RelayMessage::VT_PAYLOAD_TYPE, Some(RelayPayload::NONE)).unwrap()
  }
  #[inline]
  pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(RelayMessage::VT_PAYLOAD, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_compact_block(&self) -> Option<CompactBlock<'a>> {
    if self.payload_type() == RelayPayload::CompactBlock {
      self.payload().map(|u| CompactBlock::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_relay_transactions(&self) -> Option<RelayTransactions<'a>> {
    if self.payload_type() == RelayPayload::RelayTransactions {
      self.payload().map(|u| RelayTransactions::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_relay_transaction_hashes(&self) -> Option<RelayTransactionHashes<'a>> {
    if self.payload_type() == RelayPayload::RelayTransactionHashes {
      self.payload().map(|u| RelayTransactionHashes::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_get_relay_transactions(&self) -> Option<GetRelayTransactions<'a>> {
    if self.payload_type() == RelayPayload::GetRelayTransactions {
      self.payload().map(|u| GetRelayTransactions::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_get_block_transactions(&self) -> Option<GetBlockTransactions<'a>> {
    if self.payload_type() == RelayPayload::GetBlockTransactions {
      self.payload().map(|u| GetBlockTransactions::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_block_transactions(&self) -> Option<BlockTransactions<'a>> {
    if self.payload_type() == RelayPayload::BlockTransactions {
      self.payload().map(|u| BlockTransactions::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_get_block_proposal(&self) -> Option<GetBlockProposal<'a>> {
    if self.payload_type() == RelayPayload::GetBlockProposal {
      self.payload().map(|u| GetBlockProposal::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn payload_as_block_proposal(&self) -> Option<BlockProposal<'a>> {
    if self.payload_type() == RelayPayload::BlockProposal {
      self.payload().map(|u| BlockProposal::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct RelayMessageArgs {
    pub payload_type: RelayPayload,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RelayMessageArgs {
    #[inline]
    fn default() -> Self {
        RelayMessageArgs {
            payload_type: RelayPayload::NONE,
            payload: None,
        }
    }
}
pub struct RelayMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RelayMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_payload_type(&mut self, payload_type: RelayPayload) {
    self.fbb_.push_slot::<RelayPayload>(RelayMessage::VT_PAYLOAD_TYPE, payload_type, RelayPayload::NONE);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelayMessage::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RelayMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RelayMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RelayMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CompactBlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CompactBlock<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CompactBlock<'a> {
    type Inner = CompactBlock<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CompactBlock<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CompactBlock {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CompactBlockArgs<'args>) -> flatbuffers::WIPOffset<CompactBlock<'bldr>> {
      let mut builder = CompactBlockBuilder::new(_fbb);
      if let Some(x) = args.proposals { builder.add_proposals(x); }
      if let Some(x) = args.uncles { builder.add_uncles(x); }
      if let Some(x) = args.prefilled_transactions { builder.add_prefilled_transactions(x); }
      if let Some(x) = args.short_ids { builder.add_short_ids(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_SHORT_IDS: flatbuffers::VOffsetT = 6;
    pub const VT_PREFILLED_TRANSACTIONS: flatbuffers::VOffsetT = 8;
    pub const VT_UNCLES: flatbuffers::VOffsetT = 10;
    pub const VT_PROPOSALS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn header(&self) -> Option<Header<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Header<'a>>>(CompactBlock::VT_HEADER, None)
  }
  #[inline]
  pub fn short_ids(&self) -> Option<&'a [ProposalShortId]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<ProposalShortId>>>(CompactBlock::VT_SHORT_IDS, None).map(|v| v.safe_slice() )
  }
  #[inline]
  pub fn prefilled_transactions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IndexTransaction<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<IndexTransaction<'a>>>>>(CompactBlock::VT_PREFILLED_TRANSACTIONS, None)
  }
  #[inline]
  pub fn uncles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UncleBlock<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<UncleBlock<'a>>>>>(CompactBlock::VT_UNCLES, None)
  }
  #[inline]
  pub fn proposals(&self) -> Option<&'a [ProposalShortId]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<ProposalShortId>>>(CompactBlock::VT_PROPOSALS, None).map(|v| v.safe_slice() )
  }
}

pub struct CompactBlockArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a >>>,
    pub short_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , ProposalShortId>>>,
    pub prefilled_transactions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<IndexTransaction<'a >>>>>,
    pub uncles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<UncleBlock<'a >>>>>,
    pub proposals: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , ProposalShortId>>>,
}
impl<'a> Default for CompactBlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        CompactBlockArgs {
            header: None,
            short_ids: None,
            prefilled_transactions: None,
            uncles: None,
            proposals: None,
        }
    }
}
pub struct CompactBlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CompactBlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Header>>(CompactBlock::VT_HEADER, header);
  }
  #[inline]
  pub fn add_short_ids(&mut self, short_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ProposalShortId>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompactBlock::VT_SHORT_IDS, short_ids);
  }
  #[inline]
  pub fn add_prefilled_transactions(&mut self, prefilled_transactions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IndexTransaction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompactBlock::VT_PREFILLED_TRANSACTIONS, prefilled_transactions);
  }
  #[inline]
  pub fn add_uncles(&mut self, uncles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<UncleBlock<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompactBlock::VT_UNCLES, uncles);
  }
  #[inline]
  pub fn add_proposals(&mut self, proposals: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ProposalShortId>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CompactBlock::VT_PROPOSALS, proposals);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CompactBlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CompactBlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CompactBlock<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IndexTransactionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct IndexTransaction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IndexTransaction<'a> {
    type Inner = IndexTransaction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> IndexTransaction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IndexTransaction {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IndexTransactionArgs<'args>) -> flatbuffers::WIPOffset<IndexTransaction<'bldr>> {
      let mut builder = IndexTransactionBuilder::new(_fbb);
      if let Some(x) = args.transaction { builder.add_transaction(x); }
      builder.add_index(args.index);
      builder.finish()
    }

    pub const VT_INDEX: flatbuffers::VOffsetT = 4;
    pub const VT_TRANSACTION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn index(&self) -> u32 {
    self._tab.get::<u32>(IndexTransaction::VT_INDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn transaction(&self) -> Option<Transaction<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Transaction<'a>>>(IndexTransaction::VT_TRANSACTION, None)
  }
}

pub struct IndexTransactionArgs<'a> {
    pub index: u32,
    pub transaction: Option<flatbuffers::WIPOffset<Transaction<'a >>>,
}
impl<'a> Default for IndexTransactionArgs<'a> {
    #[inline]
    fn default() -> Self {
        IndexTransactionArgs {
            index: 0,
            transaction: None,
        }
    }
}
pub struct IndexTransactionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IndexTransactionBuilder<'a, 'b> {
  #[inline]
  pub fn add_index(&mut self, index: u32) {
    self.fbb_.push_slot::<u32>(IndexTransaction::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<Transaction<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Transaction>>(IndexTransaction::VT_TRANSACTION, transaction);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IndexTransactionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IndexTransactionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IndexTransaction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RelayTransactionHashesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RelayTransactionHashes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RelayTransactionHashes<'a> {
    type Inner = RelayTransactionHashes<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RelayTransactionHashes<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RelayTransactionHashes {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RelayTransactionHashesArgs<'args>) -> flatbuffers::WIPOffset<RelayTransactionHashes<'bldr>> {
      let mut builder = RelayTransactionHashesBuilder::new(_fbb);
      if let Some(x) = args.tx_hashes { builder.add_tx_hashes(x); }
      builder.finish()
    }

    pub const VT_TX_HASHES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn tx_hashes(&self) -> Option<&'a [H256]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<H256>>>(RelayTransactionHashes::VT_TX_HASHES, None).map(|v| v.safe_slice() )
  }
}

pub struct RelayTransactionHashesArgs<'a> {
    pub tx_hashes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , H256>>>,
}
impl<'a> Default for RelayTransactionHashesArgs<'a> {
    #[inline]
    fn default() -> Self {
        RelayTransactionHashesArgs {
            tx_hashes: None,
        }
    }
}
pub struct RelayTransactionHashesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RelayTransactionHashesBuilder<'a, 'b> {
  #[inline]
  pub fn add_tx_hashes(&mut self, tx_hashes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , H256>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelayTransactionHashes::VT_TX_HASHES, tx_hashes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RelayTransactionHashesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RelayTransactionHashesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RelayTransactionHashes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GetRelayTransactionsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetRelayTransactions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetRelayTransactions<'a> {
    type Inner = GetRelayTransactions<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetRelayTransactions<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetRelayTransactions {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetRelayTransactionsArgs<'args>) -> flatbuffers::WIPOffset<GetRelayTransactions<'bldr>> {
      let mut builder = GetRelayTransactionsBuilder::new(_fbb);
      if let Some(x) = args.tx_hashes { builder.add_tx_hashes(x); }
      builder.finish()
    }

    pub const VT_TX_HASHES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn tx_hashes(&self) -> Option<&'a [H256]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<H256>>>(GetRelayTransactions::VT_TX_HASHES, None).map(|v| v.safe_slice() )
  }
}

pub struct GetRelayTransactionsArgs<'a> {
    pub tx_hashes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , H256>>>,
}
impl<'a> Default for GetRelayTransactionsArgs<'a> {
    #[inline]
    fn default() -> Self {
        GetRelayTransactionsArgs {
            tx_hashes: None,
        }
    }
}
pub struct GetRelayTransactionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetRelayTransactionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_tx_hashes(&mut self, tx_hashes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , H256>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetRelayTransactions::VT_TX_HASHES, tx_hashes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetRelayTransactionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetRelayTransactionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetRelayTransactions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RelayTransactionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RelayTransaction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RelayTransaction<'a> {
    type Inner = RelayTransaction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RelayTransaction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RelayTransaction {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RelayTransactionArgs<'args>) -> flatbuffers::WIPOffset<RelayTransaction<'bldr>> {
      let mut builder = RelayTransactionBuilder::new(_fbb);
      builder.add_cycles(args.cycles);
      if let Some(x) = args.transaction { builder.add_transaction(x); }
      builder.finish()
    }

    pub const VT_CYCLES: flatbuffers::VOffsetT = 4;
    pub const VT_TRANSACTION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn cycles(&self) -> u64 {
    self._tab.get::<u64>(RelayTransaction::VT_CYCLES, Some(0)).unwrap()
  }
  #[inline]
  pub fn transaction(&self) -> Option<Transaction<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Transaction<'a>>>(RelayTransaction::VT_TRANSACTION, None)
  }
}

pub struct RelayTransactionArgs<'a> {
    pub cycles: u64,
    pub transaction: Option<flatbuffers::WIPOffset<Transaction<'a >>>,
}
impl<'a> Default for RelayTransactionArgs<'a> {
    #[inline]
    fn default() -> Self {
        RelayTransactionArgs {
            cycles: 0,
            transaction: None,
        }
    }
}
pub struct RelayTransactionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RelayTransactionBuilder<'a, 'b> {
  #[inline]
  pub fn add_cycles(&mut self, cycles: u64) {
    self.fbb_.push_slot::<u64>(RelayTransaction::VT_CYCLES, cycles, 0);
  }
  #[inline]
  pub fn add_transaction(&mut self, transaction: flatbuffers::WIPOffset<Transaction<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Transaction>>(RelayTransaction::VT_TRANSACTION, transaction);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RelayTransactionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RelayTransactionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RelayTransaction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RelayTransactionsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RelayTransactions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RelayTransactions<'a> {
    type Inner = RelayTransactions<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RelayTransactions<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RelayTransactions {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RelayTransactionsArgs<'args>) -> flatbuffers::WIPOffset<RelayTransactions<'bldr>> {
      let mut builder = RelayTransactionsBuilder::new(_fbb);
      if let Some(x) = args.transactions { builder.add_transactions(x); }
      builder.finish()
    }

    pub const VT_TRANSACTIONS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn transactions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RelayTransaction<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<RelayTransaction<'a>>>>>(RelayTransactions::VT_TRANSACTIONS, None)
  }
}

pub struct RelayTransactionsArgs<'a> {
    pub transactions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<RelayTransaction<'a >>>>>,
}
impl<'a> Default for RelayTransactionsArgs<'a> {
    #[inline]
    fn default() -> Self {
        RelayTransactionsArgs {
            transactions: None,
        }
    }
}
pub struct RelayTransactionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RelayTransactionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_transactions(&mut self, transactions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RelayTransaction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelayTransactions::VT_TRANSACTIONS, transactions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RelayTransactionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RelayTransactionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RelayTransactions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GetBlockTransactionsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetBlockTransactions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetBlockTransactions<'a> {
    type Inner = GetBlockTransactions<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetBlockTransactions<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetBlockTransactions {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetBlockTransactionsArgs<'args>) -> flatbuffers::WIPOffset<GetBlockTransactions<'bldr>> {
      let mut builder = GetBlockTransactionsBuilder::new(_fbb);
      if let Some(x) = args.indexes { builder.add_indexes(x); }
      if let Some(x) = args.block_hash { builder.add_block_hash(x); }
      builder.finish()
    }

    pub const VT_BLOCK_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_INDEXES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn block_hash(&self) -> Option<&'a H256> {
    self._tab.get::<H256>(GetBlockTransactions::VT_BLOCK_HASH, None)
  }
  #[inline]
  pub fn indexes(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(GetBlockTransactions::VT_INDEXES, None)
  }
}

pub struct GetBlockTransactionsArgs<'a> {
    pub block_hash: Option<&'a  H256>,
    pub indexes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u32>>>,
}
impl<'a> Default for GetBlockTransactionsArgs<'a> {
    #[inline]
    fn default() -> Self {
        GetBlockTransactionsArgs {
            block_hash: None,
            indexes: None,
        }
    }
}
pub struct GetBlockTransactionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetBlockTransactionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_hash(&mut self, block_hash: &'b  H256) {
    self.fbb_.push_slot_always::<&H256>(GetBlockTransactions::VT_BLOCK_HASH, block_hash);
  }
  #[inline]
  pub fn add_indexes(&mut self, indexes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetBlockTransactions::VT_INDEXES, indexes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetBlockTransactionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetBlockTransactionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetBlockTransactions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BlockTransactionsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BlockTransactions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockTransactions<'a> {
    type Inner = BlockTransactions<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BlockTransactions<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BlockTransactions {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockTransactionsArgs<'args>) -> flatbuffers::WIPOffset<BlockTransactions<'bldr>> {
      let mut builder = BlockTransactionsBuilder::new(_fbb);
      if let Some(x) = args.transactions { builder.add_transactions(x); }
      if let Some(x) = args.block_hash { builder.add_block_hash(x); }
      builder.finish()
    }

    pub const VT_BLOCK_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_TRANSACTIONS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn block_hash(&self) -> Option<&'a H256> {
    self._tab.get::<H256>(BlockTransactions::VT_BLOCK_HASH, None)
  }
  #[inline]
  pub fn transactions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Transaction<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>>>>(BlockTransactions::VT_TRANSACTIONS, None)
  }
}

pub struct BlockTransactionsArgs<'a> {
    pub block_hash: Option<&'a  H256>,
    pub transactions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Transaction<'a >>>>>,
}
impl<'a> Default for BlockTransactionsArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockTransactionsArgs {
            block_hash: None,
            transactions: None,
        }
    }
}
pub struct BlockTransactionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockTransactionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_hash(&mut self, block_hash: &'b  H256) {
    self.fbb_.push_slot_always::<&H256>(BlockTransactions::VT_BLOCK_HASH, block_hash);
  }
  #[inline]
  pub fn add_transactions(&mut self, transactions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Transaction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BlockTransactions::VT_TRANSACTIONS, transactions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockTransactionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockTransactionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockTransactions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GetBlockProposalOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GetBlockProposal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetBlockProposal<'a> {
    type Inner = GetBlockProposal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GetBlockProposal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetBlockProposal {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetBlockProposalArgs<'args>) -> flatbuffers::WIPOffset<GetBlockProposal<'bldr>> {
      let mut builder = GetBlockProposalBuilder::new(_fbb);
      if let Some(x) = args.proposals { builder.add_proposals(x); }
      if let Some(x) = args.block_hash { builder.add_block_hash(x); }
      builder.finish()
    }

    pub const VT_BLOCK_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_PROPOSALS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn block_hash(&self) -> Option<&'a H256> {
    self._tab.get::<H256>(GetBlockProposal::VT_BLOCK_HASH, None)
  }
  #[inline]
  pub fn proposals(&self) -> Option<&'a [ProposalShortId]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<ProposalShortId>>>(GetBlockProposal::VT_PROPOSALS, None).map(|v| v.safe_slice() )
  }
}

pub struct GetBlockProposalArgs<'a> {
    pub block_hash: Option<&'a  H256>,
    pub proposals: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , ProposalShortId>>>,
}
impl<'a> Default for GetBlockProposalArgs<'a> {
    #[inline]
    fn default() -> Self {
        GetBlockProposalArgs {
            block_hash: None,
            proposals: None,
        }
    }
}
pub struct GetBlockProposalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetBlockProposalBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_hash(&mut self, block_hash: &'b  H256) {
    self.fbb_.push_slot_always::<&H256>(GetBlockProposal::VT_BLOCK_HASH, block_hash);
  }
  #[inline]
  pub fn add_proposals(&mut self, proposals: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ProposalShortId>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetBlockProposal::VT_PROPOSALS, proposals);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetBlockProposalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GetBlockProposalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetBlockProposal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BlockProposalOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BlockProposal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockProposal<'a> {
    type Inner = BlockProposal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BlockProposal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BlockProposal {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockProposalArgs<'args>) -> flatbuffers::WIPOffset<BlockProposal<'bldr>> {
      let mut builder = BlockProposalBuilder::new(_fbb);
      if let Some(x) = args.transactions { builder.add_transactions(x); }
      builder.finish()
    }

    pub const VT_TRANSACTIONS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn transactions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Transaction<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>>>>(BlockProposal::VT_TRANSACTIONS, None)
  }
}

pub struct BlockProposalArgs<'a> {
    pub transactions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Transaction<'a >>>>>,
}
impl<'a> Default for BlockProposalArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockProposalArgs {
            transactions: None,
        }
    }
}
pub struct BlockProposalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockProposalBuilder<'a, 'b> {
  #[inline]
  pub fn add_transactions(&mut self, transactions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Transaction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BlockProposal::VT_TRANSACTIONS, transactions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockProposalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockProposalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockProposal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SetFilterOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct SetFilter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetFilter<'a> {
    type Inner = SetFilter<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> SetFilter<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetFilter {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetFilterArgs<'args>) -> flatbuffers::WIPOffset<SetFilter<'bldr>> {
      let mut builder = SetFilterBuilder::new(_fbb);
      builder.add_hash_seed(args.hash_seed);
      if let Some(x) = args.filter { builder.add_filter(x); }
      builder.add_num_hashes(args.num_hashes);
      builder.finish()
    }

    pub const VT_FILTER: flatbuffers::VOffsetT = 4;
    pub const VT_NUM_HASHES: flatbuffers::VOffsetT = 6;
    pub const VT_HASH_SEED: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn filter(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SetFilter::VT_FILTER, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn num_hashes(&self) -> u8 {
    self._tab.get::<u8>(SetFilter::VT_NUM_HASHES, Some(0)).unwrap()
  }
  #[inline]
  pub fn hash_seed(&self) -> u32 {
    self._tab.get::<u32>(SetFilter::VT_HASH_SEED, Some(0)).unwrap()
  }
}

pub struct SetFilterArgs<'a> {
    pub filter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub num_hashes: u8,
    pub hash_seed: u32,
}
impl<'a> Default for SetFilterArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetFilterArgs {
            filter: None,
            num_hashes: 0,
            hash_seed: 0,
        }
    }
}
pub struct SetFilterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetFilterBuilder<'a, 'b> {
  #[inline]
  pub fn add_filter(&mut self, filter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SetFilter::VT_FILTER, filter);
  }
  #[inline]
  pub fn add_num_hashes(&mut self, num_hashes: u8) {
    self.fbb_.push_slot::<u8>(SetFilter::VT_NUM_HASHES, num_hashes, 0);
  }
  #[inline]
  pub fn add_hash_seed(&mut self, hash_seed: u32) {
    self.fbb_.push_slot::<u32>(SetFilter::VT_HASH_SEED, hash_seed, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetFilterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SetFilterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SetFilter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum AddFilterOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct AddFilter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AddFilter<'a> {
    type Inner = AddFilter<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> AddFilter<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AddFilter {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AddFilterArgs<'args>) -> flatbuffers::WIPOffset<AddFilter<'bldr>> {
      let mut builder = AddFilterBuilder::new(_fbb);
      if let Some(x) = args.filter { builder.add_filter(x); }
      builder.finish()
    }

    pub const VT_FILTER: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn filter(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(AddFilter::VT_FILTER, None).map(|v| v.safe_slice())
  }
}

pub struct AddFilterArgs<'a> {
    pub filter: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for AddFilterArgs<'a> {
    #[inline]
    fn default() -> Self {
        AddFilterArgs {
            filter: None,
        }
    }
}
pub struct AddFilterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AddFilterBuilder<'a, 'b> {
  #[inline]
  pub fn add_filter(&mut self, filter: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AddFilter::VT_FILTER, filter);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddFilterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AddFilterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AddFilter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ClearFilterOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ClearFilter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ClearFilter<'a> {
    type Inner = ClearFilter<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ClearFilter<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ClearFilter {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args ClearFilterArgs) -> flatbuffers::WIPOffset<ClearFilter<'bldr>> {
      let mut builder = ClearFilterBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct ClearFilterArgs {
}
impl<'a> Default for ClearFilterArgs {
    #[inline]
    fn default() -> Self {
        ClearFilterArgs {
        }
    }
}
pub struct ClearFilterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ClearFilterBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ClearFilterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ClearFilterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ClearFilter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InIBDOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InIBD<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InIBD<'a> {
    type Inner = InIBD<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InIBD<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InIBD {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args InIBDArgs) -> flatbuffers::WIPOffset<InIBD<'bldr>> {
      let mut builder = InIBDBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct InIBDArgs {
}
impl<'a> Default for InIBDArgs {
    #[inline]
    fn default() -> Self {
        InIBDArgs {
        }
    }
}
pub struct InIBDBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InIBDBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InIBDBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InIBDBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InIBD<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FilteredBlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FilteredBlock<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FilteredBlock<'a> {
    type Inner = FilteredBlock<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FilteredBlock<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FilteredBlock {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FilteredBlockArgs<'args>) -> flatbuffers::WIPOffset<FilteredBlock<'bldr>> {
      let mut builder = FilteredBlockBuilder::new(_fbb);
      if let Some(x) = args.proof { builder.add_proof(x); }
      if let Some(x) = args.transactions { builder.add_transactions(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_TRANSACTIONS: flatbuffers::VOffsetT = 6;
    pub const VT_PROOF: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn header(&self) -> Option<Header<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Header<'a>>>(FilteredBlock::VT_HEADER, None)
  }
  #[inline]
  pub fn transactions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Transaction<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>>>>(FilteredBlock::VT_TRANSACTIONS, None)
  }
  #[inline]
  pub fn proof(&self) -> Option<MerkleProof<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<MerkleProof<'a>>>(FilteredBlock::VT_PROOF, None)
  }
}

pub struct FilteredBlockArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a >>>,
    pub transactions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Transaction<'a >>>>>,
    pub proof: Option<flatbuffers::WIPOffset<MerkleProof<'a >>>,
}
impl<'a> Default for FilteredBlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        FilteredBlockArgs {
            header: None,
            transactions: None,
            proof: None,
        }
    }
}
pub struct FilteredBlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FilteredBlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Header>>(FilteredBlock::VT_HEADER, header);
  }
  #[inline]
  pub fn add_transactions(&mut self, transactions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Transaction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FilteredBlock::VT_TRANSACTIONS, transactions);
  }
  #[inline]
  pub fn add_proof(&mut self, proof: flatbuffers::WIPOffset<MerkleProof<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MerkleProof>>(FilteredBlock::VT_PROOF, proof);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FilteredBlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FilteredBlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FilteredBlock<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum MerkleProofOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct MerkleProof<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MerkleProof<'a> {
    type Inner = MerkleProof<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> MerkleProof<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MerkleProof {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MerkleProofArgs<'args>) -> flatbuffers::WIPOffset<MerkleProof<'bldr>> {
      let mut builder = MerkleProofBuilder::new(_fbb);
      if let Some(x) = args.lemmas { builder.add_lemmas(x); }
      if let Some(x) = args.indices { builder.add_indices(x); }
      builder.finish()
    }

    pub const VT_INDICES: flatbuffers::VOffsetT = 4;
    pub const VT_LEMMAS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn indices(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(MerkleProof::VT_INDICES, None)
  }
  #[inline]
  pub fn lemmas(&self) -> Option<&'a [H256]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<H256>>>(MerkleProof::VT_LEMMAS, None).map(|v| v.safe_slice() )
  }
}

pub struct MerkleProofArgs<'a> {
    pub indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u32>>>,
    pub lemmas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , H256>>>,
}
impl<'a> Default for MerkleProofArgs<'a> {
    #[inline]
    fn default() -> Self {
        MerkleProofArgs {
            indices: None,
            lemmas: None,
        }
    }
}
pub struct MerkleProofBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MerkleProofBuilder<'a, 'b> {
  #[inline]
  pub fn add_indices(&mut self, indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MerkleProof::VT_INDICES, indices);
  }
  #[inline]
  pub fn add_lemmas(&mut self, lemmas: flatbuffers::WIPOffset<flatbuffers::Vector<'b , H256>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MerkleProof::VT_LEMMAS, lemmas);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MerkleProofBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MerkleProofBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MerkleProof<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TimeMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TimeMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TimeMessage<'a> {
    type Inner = TimeMessage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TimeMessage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TimeMessage {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TimeMessageArgs<'args>) -> flatbuffers::WIPOffset<TimeMessage<'bldr>> {
      let mut builder = TimeMessageBuilder::new(_fbb);
      if let Some(x) = args.payload { builder.add_payload(x); }
      builder.finish()
    }

    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn payload(&self) -> Option<Time<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Time<'a>>>(TimeMessage::VT_PAYLOAD, None)
  }
}

pub struct TimeMessageArgs<'a> {
    pub payload: Option<flatbuffers::WIPOffset<Time<'a >>>,
}
impl<'a> Default for TimeMessageArgs<'a> {
    #[inline]
    fn default() -> Self {
        TimeMessageArgs {
            payload: None,
        }
    }
}
pub struct TimeMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TimeMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<Time<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Time>>(TimeMessage::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TimeMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TimeMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TimeMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TimeOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Time<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Time<'a> {
    type Inner = Time<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Time<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Time {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TimeArgs) -> flatbuffers::WIPOffset<Time<'bldr>> {
      let mut builder = TimeBuilder::new(_fbb);
      builder.add_timestamp(args.timestamp);
      builder.finish()
    }

    pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn timestamp(&self) -> u64 {
    self._tab.get::<u64>(Time::VT_TIMESTAMP, Some(0)).unwrap()
  }
}

pub struct TimeArgs {
    pub timestamp: u64,
}
impl<'a> Default for TimeArgs {
    #[inline]
    fn default() -> Self {
        TimeArgs {
            timestamp: 0,
        }
    }
}
pub struct TimeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TimeBuilder<'a, 'b> {
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(Time::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TimeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TimeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Time<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum AlertMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct AlertMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AlertMessage<'a> {
    type Inner = AlertMessage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> AlertMessage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AlertMessage {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AlertMessageArgs<'args>) -> flatbuffers::WIPOffset<AlertMessage<'bldr>> {
      let mut builder = AlertMessageBuilder::new(_fbb);
      if let Some(x) = args.payload { builder.add_payload(x); }
      builder.finish()
    }

    pub const VT_PAYLOAD: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn payload(&self) -> Option<Alert<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Alert<'a>>>(AlertMessage::VT_PAYLOAD, None)
  }
}

pub struct AlertMessageArgs<'a> {
    pub payload: Option<flatbuffers::WIPOffset<Alert<'a >>>,
}
impl<'a> Default for AlertMessageArgs<'a> {
    #[inline]
    fn default() -> Self {
        AlertMessageArgs {
            payload: None,
        }
    }
}
pub struct AlertMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AlertMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<Alert<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Alert>>(AlertMessage::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AlertMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AlertMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AlertMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum AlertOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Alert<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Alert<'a> {
    type Inner = Alert<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Alert<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Alert {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AlertArgs<'args>) -> flatbuffers::WIPOffset<Alert<'bldr>> {
      let mut builder = AlertBuilder::new(_fbb);
      builder.add_notice_until(args.notice_until);
      if let Some(x) = args.message { builder.add_message(x); }
      if let Some(x) = args.signatures { builder.add_signatures(x); }
      builder.add_priority(args.priority);
      if let Some(x) = args.max_version { builder.add_max_version(x); }
      if let Some(x) = args.min_version { builder.add_min_version(x); }
      builder.add_cancel(args.cancel);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_CANCEL: flatbuffers::VOffsetT = 6;
    pub const VT_MIN_VERSION: flatbuffers::VOffsetT = 8;
    pub const VT_MAX_VERSION: flatbuffers::VOffsetT = 10;
    pub const VT_PRIORITY: flatbuffers::VOffsetT = 12;
    pub const VT_SIGNATURES: flatbuffers::VOffsetT = 14;
    pub const VT_NOTICE_UNTIL: flatbuffers::VOffsetT = 16;
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(Alert::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn cancel(&self) -> u32 {
    self._tab.get::<u32>(Alert::VT_CANCEL, Some(0)).unwrap()
  }
  #[inline]
  pub fn min_version(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Alert::VT_MIN_VERSION, None)
  }
  #[inline]
  pub fn max_version(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Alert::VT_MAX_VERSION, None)
  }
  #[inline]
  pub fn priority(&self) -> u32 {
    self._tab.get::<u32>(Alert::VT_PRIORITY, Some(0)).unwrap()
  }
  #[inline]
  pub fn signatures(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>>>(Alert::VT_SIGNATURES, None)
  }
  #[inline]
  pub fn notice_until(&self) -> u64 {
    self._tab.get::<u64>(Alert::VT_NOTICE_UNTIL, Some(0)).unwrap()
  }
  #[inline]
  pub fn message(&self) -> Option<Bytes<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Alert::VT_MESSAGE, None)
  }
}

pub struct AlertArgs<'a> {
    pub id: u32,
    pub cancel: u32,
    pub min_version: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub max_version: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
    pub priority: u32,
    pub signatures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Bytes<'a >>>>>,
    pub notice_until: u64,
    pub message: Option<flatbuffers::WIPOffset<Bytes<'a >>>,
}
impl<'a> Default for AlertArgs<'a> {
    #[inline]
    fn default() -> Self {
        AlertArgs {
            id: 0,
            cancel: 0,
            min_version: None,
            max_version: None,
            priority: 0,
            signatures: None,
            notice_until: 0,
            message: None,
        }
    }
}
pub struct AlertBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AlertBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(Alert::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_cancel(&mut self, cancel: u32) {
    self.fbb_.push_slot::<u32>(Alert::VT_CANCEL, cancel, 0);
  }
  #[inline]
  pub fn add_min_version(&mut self, min_version: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Alert::VT_MIN_VERSION, min_version);
  }
  #[inline]
  pub fn add_max_version(&mut self, max_version: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Alert::VT_MAX_VERSION, max_version);
  }
  #[inline]
  pub fn add_priority(&mut self, priority: u32) {
    self.fbb_.push_slot::<u32>(Alert::VT_PRIORITY, priority, 0);
  }
  #[inline]
  pub fn add_signatures(&mut self, signatures: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bytes<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Alert::VT_SIGNATURES, signatures);
  }
  #[inline]
  pub fn add_notice_until(&mut self, notice_until: u64) {
    self.fbb_.push_slot::<u64>(Alert::VT_NOTICE_UNTIL, notice_until, 0);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<Bytes<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Alert::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AlertBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AlertBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Alert<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum IdentifyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Identify<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Identify<'a> {
    type Inner = Identify<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Identify<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Identify {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IdentifyArgs<'args>) -> flatbuffers::WIPOffset<Identify<'bldr>> {
      let mut builder = IdentifyBuilder::new(_fbb);
      builder.add_flag(args.flag);
      if let Some(x) = args.client_version { builder.add_client_version(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_FLAG: flatbuffers::VOffsetT = 6;
    pub const VT_CLIENT_VERSION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Identify::VT_NAME, None)
  }
  #[inline]
  pub fn flag(&self) -> u64 {
    self._tab.get::<u64>(Identify::VT_FLAG, Some(0)).unwrap()
  }
  #[inline]
  pub fn client_version(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Identify::VT_CLIENT_VERSION, None)
  }
}

pub struct IdentifyArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub flag: u64,
    pub client_version: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for IdentifyArgs<'a> {
    #[inline]
    fn default() -> Self {
        IdentifyArgs {
            name: None,
            flag: 0,
            client_version: None,
        }
    }
}
pub struct IdentifyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IdentifyBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Identify::VT_NAME, name);
  }
  #[inline]
  pub fn add_flag(&mut self, flag: u64) {
    self.fbb_.push_slot::<u64>(Identify::VT_FLAG, flag, 0);
  }
  #[inline]
  pub fn add_client_version(&mut self, client_version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Identify::VT_CLIENT_VERSION, client_version);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IdentifyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IdentifyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Identify<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_sync_message<'a>(buf: &'a [u8]) -> SyncMessage<'a> {
  flatbuffers::get_root::<SyncMessage<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_sync_message<'a>(buf: &'a [u8]) -> SyncMessage<'a> {
  flatbuffers::get_size_prefixed_root::<SyncMessage<'a>>(buf)
}

#[inline]
pub fn finish_sync_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<SyncMessage<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_sync_message_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<SyncMessage<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Protocol
}  // pub mod Ckb

