# Config generated by `ckb init` # {{
# see => resource/src/template.rs
# testnet => # Config generated by `ckb init --chain testnet`
# }}

data_dir = "data"

[chain]
# Choose the kind of chains to run, possible values:
# - { file = "specs/dev.toml" }
# - { bundled = "specs/testnet.toml" }
spec = { file = "specs/dev.toml" } # {{
# testnet => spec = { bundled = "specs/testnet.toml" }
# integration => spec = { file = "specs/integration.toml" }
# }}

[logger]
filter = "info" # {{
# integration => filter = "info,ckb-network=trace,ckb-rpc=debug,ckb-sync=debug,ckb-relay=debug,ckb-tx-pool=debug,ckb-chain=debug"
# }}
color = true
log_to_file = true # {{
# _ => log_to_file = {log_to_file}
# }}
log_to_stdout = true # {{
# _ => log_to_stdout = {log_to_stdout}
# }}

[sentry]
# set to blank to disable sentry error collection
dsn = "" # {{
# testnet => dsn = "https://48c6a88d92e246478e2d53b5917a887c@sentry.io/1422795"
# }}
# if you are willing to help us to improve,
# please leave a way to contact you when we have troubles to reproduce the errors.
# org_contact = ""

[network]
listen_addresses = ["/ip4/0.0.0.0/tcp/8115"] # {{
# _ => listen_addresses = ["/ip4/0.0.0.0/tcp/{p2p_port}"]
# }}
public_addresses = []

# Node connects to nodes listed here to discovery other peers when there's no local stored peers.
# When chain.spec is changed, this usually should also be changed to the bootnodes in the new chain.
bootnodes = [] # {{
# testnet => bootnodes = [\n  # Hangzhou (China)\n  "/ip4/47.111.169.36/tcp/8111/p2p/QmNQ4jky6uVqLDrPU7snqxARuNGWNLgSrTnssbRuy3ij2W",\n  # Ohio (USA)\n  "/ip4/18.217.146.65/tcp/8111/p2p/QmT6DFfm18wtbJz3y4aPNn3ac86N4d4p4xtfQRRPf73frC",\n  # Singapore\n  "/ip4/18.136.60.221/tcp/8111/p2p/QmTt6HeNakL8Fpmevrhdna7J4NzEMf9pLchf1CXtmtSrwb",\n  # London\n  "/ip4/35.176.207.239/tcp/8111/p2p/QmSJTsMsMGBjzv1oBNwQU36VhQRxc2WQpFoRu1ZifYKrjZ",\n]
# }}

reserved_peers = []
reserved_only = false
max_peers = 125
max_outbound_peers = 8
# 2 minutes
ping_interval_secs = 120
# 20 minutes
ping_timeout_secs = 1200
connect_outbound_interval_secs = 15
# If set to true, try to register upnp
upnp = false
# If set to true, network service will add discovered local address to peer store, it's helpful for private net development
discovery_local_address = false # {{
# dev => discovery_local_address = true
# }}

[rpc]
listen_address = "127.0.0.1:8114" # {{
# _ => listen_address = "127.0.0.1:{rpc_port}"
# }}

# Default is 10MiB = 10 * 1024 * 1024
max_request_body_size = 10485760

# List of API modules: ["Net", "Pool", "Miner", "Chain", "Stats", "Indexer", "Experiment"]
modules = ["Net", "Pool", "Miner", "Chain", "Stats", "Experiment"] # {{
# integration => modules = ["Net", "Pool", "Miner", "Chain", "Experiment", "Stats", "Indexer", "IntegrationTest"]
# }}

[tx_pool]
max_mem_size = 20_000_000 # 20mb
max_cycles = 200_000_000_000
max_verfify_cache_size = 100_000

[script]
runner = "Rust" # {{
# _ => runner = "{runner}"
# }}

[store]
header_cache_size       = 4096
cell_output_cache_size  = 128

# Set the lock script to protect mined CKB.
#
# CKB uses CS architecture for miner. Miner process (ckb miner) gets block
# template from the Node process (ckb run) via RPC. Thus the lock script is
# configured in ckb.toml instead of ckb-miner.toml, and the config takes effect
# after restarting Node process.
#
# The `code_hash` identifies different cryptography algorithm. Read the manual
# of the lock script provider about how to generate this config.
#
# CKB provides an secp256k1 implementation, it requires a hash on the
# compressed public key. The hash algorithm is blake2b, with personal
# "ckb-default-hash". The first 160 bits (20 bytes) are used as the only arg.
#
# You can use any tool you trust to generate a Bitcoin private key and public
# key pair, which can be used in CKB as well. CKB CLI provides the function for
# you to convert the public key into block assembler configuration parameters.
#
# Here is an example using OpenSSL to generate the key pair:
#
# **WARNING**: This command will print the private key to screen.
#
#    openssl ecparam -genkey -name secp256k1 -text -noout -outform DER | \
#       xxd -p -c 1000 | \
#       sed 's/41534e31204f49443a20736563703235366b310a30740201010420/PrivKey: /' | \
#       sed 's/a00706052b8104000aa144034200/\'$'\nPubKey: /'
#
# Once you get your public key, generate the block assembler parameters:
#
#     ckb cli secp256k1-lock <pubkey>
#
# The command `ckb init` also accepts options to generate the block assembler
# directly. See `ckb init --help` for details. And `ckb cli secp256k1-lock` can
# also prints the command line options for `ckb init`.
#
#     ckb cli secp256k1-lock <pubkey> --format cmd
#
# The two commands can be combined together:
#
#     ckb init $(ckb cli secp256k1-lock <pubkey> --format cmd)
#
# Also, ckb allows the miners to add any data to the cellbase that they have dug out.
# The data must be A 0x-prefixed hex string.
#
# note: The data field is optional.
#
# **WARNING**: if data is larger than the capacity value of the current cellbase,
# it will be truncated
#
# # {{
# _ => {block_assembler}
# }}
