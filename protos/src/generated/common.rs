// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

// struct ProposalShortId, aligned to 1
#[repr(C, align(1))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct ProposalShortId {
    u0_: u8,
    u1_: u8,
    u2_: u8,
    u3_: u8,
    u4_: u8,
    u5_: u8,
    u6_: u8,
    u7_: u8,
    u8__: u8,
    u9_: u8,
} // pub struct ProposalShortId
impl flatbuffers::SafeSliceAccess for ProposalShortId {}
impl<'a> flatbuffers::Follow<'a> for ProposalShortId {
    type Inner = &'a ProposalShortId;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a ProposalShortId>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a ProposalShortId {
    type Inner = &'a ProposalShortId;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<ProposalShortId>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for ProposalShortId {
    type Output = ProposalShortId;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const ProposalShortId as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b ProposalShortId {
    type Output = ProposalShortId;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const ProposalShortId as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl ProposalShortId {
    pub fn new<'a>(
        _u0: u8,
        _u1: u8,
        _u2: u8,
        _u3: u8,
        _u4: u8,
        _u5: u8,
        _u6: u8,
        _u7: u8,
        _u8_: u8,
        _u9: u8,
    ) -> Self {
        ProposalShortId {
            u0_: _u0.to_little_endian(),
            u1_: _u1.to_little_endian(),
            u2_: _u2.to_little_endian(),
            u3_: _u3.to_little_endian(),
            u4_: _u4.to_little_endian(),
            u5_: _u5.to_little_endian(),
            u6_: _u6.to_little_endian(),
            u7_: _u7.to_little_endian(),
            u8__: _u8_.to_little_endian(),
            u9_: _u9.to_little_endian(),
        }
    }
    pub fn u0<'a>(&'a self) -> u8 {
        self.u0_.from_little_endian()
    }
    pub fn u1<'a>(&'a self) -> u8 {
        self.u1_.from_little_endian()
    }
    pub fn u2<'a>(&'a self) -> u8 {
        self.u2_.from_little_endian()
    }
    pub fn u3<'a>(&'a self) -> u8 {
        self.u3_.from_little_endian()
    }
    pub fn u4<'a>(&'a self) -> u8 {
        self.u4_.from_little_endian()
    }
    pub fn u5<'a>(&'a self) -> u8 {
        self.u5_.from_little_endian()
    }
    pub fn u6<'a>(&'a self) -> u8 {
        self.u6_.from_little_endian()
    }
    pub fn u7<'a>(&'a self) -> u8 {
        self.u7_.from_little_endian()
    }
    pub fn u8_<'a>(&'a self) -> u8 {
        self.u8__.from_little_endian()
    }
    pub fn u9<'a>(&'a self) -> u8 {
        self.u9_.from_little_endian()
    }
}

// struct Bytes32, aligned to 1
#[repr(C, align(1))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Bytes32 {
    u0_: u8,
    u1_: u8,
    u2_: u8,
    u3_: u8,
    u4_: u8,
    u5_: u8,
    u6_: u8,
    u7_: u8,
    u8__: u8,
    u9_: u8,
    u10_: u8,
    u11_: u8,
    u12_: u8,
    u13_: u8,
    u14_: u8,
    u15_: u8,
    u16__: u8,
    u17_: u8,
    u18_: u8,
    u19_: u8,
    u20_: u8,
    u21_: u8,
    u22_: u8,
    u23_: u8,
    u24_: u8,
    u25_: u8,
    u26_: u8,
    u27_: u8,
    u28_: u8,
    u29_: u8,
    u30_: u8,
    u31_: u8,
} // pub struct Bytes32
impl flatbuffers::SafeSliceAccess for Bytes32 {}
impl<'a> flatbuffers::Follow<'a> for Bytes32 {
    type Inner = &'a Bytes32;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Bytes32>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Bytes32 {
    type Inner = &'a Bytes32;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Bytes32>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Bytes32 {
    type Output = Bytes32;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Bytes32 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Bytes32 {
    type Output = Bytes32;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Bytes32 as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl Bytes32 {
    pub fn new<'a>(
        _u0: u8,
        _u1: u8,
        _u2: u8,
        _u3: u8,
        _u4: u8,
        _u5: u8,
        _u6: u8,
        _u7: u8,
        _u8_: u8,
        _u9: u8,
        _u10: u8,
        _u11: u8,
        _u12: u8,
        _u13: u8,
        _u14: u8,
        _u15: u8,
        _u16_: u8,
        _u17: u8,
        _u18: u8,
        _u19: u8,
        _u20: u8,
        _u21: u8,
        _u22: u8,
        _u23: u8,
        _u24: u8,
        _u25: u8,
        _u26: u8,
        _u27: u8,
        _u28: u8,
        _u29: u8,
        _u30: u8,
        _u31: u8,
    ) -> Self {
        Bytes32 {
            u0_: _u0.to_little_endian(),
            u1_: _u1.to_little_endian(),
            u2_: _u2.to_little_endian(),
            u3_: _u3.to_little_endian(),
            u4_: _u4.to_little_endian(),
            u5_: _u5.to_little_endian(),
            u6_: _u6.to_little_endian(),
            u7_: _u7.to_little_endian(),
            u8__: _u8_.to_little_endian(),
            u9_: _u9.to_little_endian(),
            u10_: _u10.to_little_endian(),
            u11_: _u11.to_little_endian(),
            u12_: _u12.to_little_endian(),
            u13_: _u13.to_little_endian(),
            u14_: _u14.to_little_endian(),
            u15_: _u15.to_little_endian(),
            u16__: _u16_.to_little_endian(),
            u17_: _u17.to_little_endian(),
            u18_: _u18.to_little_endian(),
            u19_: _u19.to_little_endian(),
            u20_: _u20.to_little_endian(),
            u21_: _u21.to_little_endian(),
            u22_: _u22.to_little_endian(),
            u23_: _u23.to_little_endian(),
            u24_: _u24.to_little_endian(),
            u25_: _u25.to_little_endian(),
            u26_: _u26.to_little_endian(),
            u27_: _u27.to_little_endian(),
            u28_: _u28.to_little_endian(),
            u29_: _u29.to_little_endian(),
            u30_: _u30.to_little_endian(),
            u31_: _u31.to_little_endian(),
        }
    }
    pub fn u0<'a>(&'a self) -> u8 {
        self.u0_.from_little_endian()
    }
    pub fn u1<'a>(&'a self) -> u8 {
        self.u1_.from_little_endian()
    }
    pub fn u2<'a>(&'a self) -> u8 {
        self.u2_.from_little_endian()
    }
    pub fn u3<'a>(&'a self) -> u8 {
        self.u3_.from_little_endian()
    }
    pub fn u4<'a>(&'a self) -> u8 {
        self.u4_.from_little_endian()
    }
    pub fn u5<'a>(&'a self) -> u8 {
        self.u5_.from_little_endian()
    }
    pub fn u6<'a>(&'a self) -> u8 {
        self.u6_.from_little_endian()
    }
    pub fn u7<'a>(&'a self) -> u8 {
        self.u7_.from_little_endian()
    }
    pub fn u8_<'a>(&'a self) -> u8 {
        self.u8__.from_little_endian()
    }
    pub fn u9<'a>(&'a self) -> u8 {
        self.u9_.from_little_endian()
    }
    pub fn u10<'a>(&'a self) -> u8 {
        self.u10_.from_little_endian()
    }
    pub fn u11<'a>(&'a self) -> u8 {
        self.u11_.from_little_endian()
    }
    pub fn u12<'a>(&'a self) -> u8 {
        self.u12_.from_little_endian()
    }
    pub fn u13<'a>(&'a self) -> u8 {
        self.u13_.from_little_endian()
    }
    pub fn u14<'a>(&'a self) -> u8 {
        self.u14_.from_little_endian()
    }
    pub fn u15<'a>(&'a self) -> u8 {
        self.u15_.from_little_endian()
    }
    pub fn u16_<'a>(&'a self) -> u8 {
        self.u16__.from_little_endian()
    }
    pub fn u17<'a>(&'a self) -> u8 {
        self.u17_.from_little_endian()
    }
    pub fn u18<'a>(&'a self) -> u8 {
        self.u18_.from_little_endian()
    }
    pub fn u19<'a>(&'a self) -> u8 {
        self.u19_.from_little_endian()
    }
    pub fn u20<'a>(&'a self) -> u8 {
        self.u20_.from_little_endian()
    }
    pub fn u21<'a>(&'a self) -> u8 {
        self.u21_.from_little_endian()
    }
    pub fn u22<'a>(&'a self) -> u8 {
        self.u22_.from_little_endian()
    }
    pub fn u23<'a>(&'a self) -> u8 {
        self.u23_.from_little_endian()
    }
    pub fn u24<'a>(&'a self) -> u8 {
        self.u24_.from_little_endian()
    }
    pub fn u25<'a>(&'a self) -> u8 {
        self.u25_.from_little_endian()
    }
    pub fn u26<'a>(&'a self) -> u8 {
        self.u26_.from_little_endian()
    }
    pub fn u27<'a>(&'a self) -> u8 {
        self.u27_.from_little_endian()
    }
    pub fn u28<'a>(&'a self) -> u8 {
        self.u28_.from_little_endian()
    }
    pub fn u29<'a>(&'a self) -> u8 {
        self.u29_.from_little_endian()
    }
    pub fn u30<'a>(&'a self) -> u8 {
        self.u30_.from_little_endian()
    }
    pub fn u31<'a>(&'a self) -> u8 {
        self.u31_.from_little_endian()
    }
}

// struct TransactionInfo, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct TransactionInfo {
    block_hash_: Bytes32,
    block_number_: u64,
    block_epoch_: u64,
    index_: u32,
    padding0__: u32,
} // pub struct TransactionInfo
impl flatbuffers::SafeSliceAccess for TransactionInfo {}
impl<'a> flatbuffers::Follow<'a> for TransactionInfo {
    type Inner = &'a TransactionInfo;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a TransactionInfo>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a TransactionInfo {
    type Inner = &'a TransactionInfo;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<TransactionInfo>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for TransactionInfo {
    type Output = TransactionInfo;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const TransactionInfo as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b TransactionInfo {
    type Output = TransactionInfo;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const TransactionInfo as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl TransactionInfo {
    pub fn new<'a>(
        _block_hash: &'a Bytes32,
        _block_number: u64,
        _block_epoch: u64,
        _index: u32,
    ) -> Self {
        TransactionInfo {
            block_hash_: *_block_hash,
            block_number_: _block_number.to_little_endian(),
            block_epoch_: _block_epoch.to_little_endian(),
            index_: _index.to_little_endian(),

            padding0__: 0,
        }
    }
    pub fn block_hash<'a>(&'a self) -> &'a Bytes32 {
        &self.block_hash_
    }
    pub fn block_number<'a>(&'a self) -> u64 {
        self.block_number_.from_little_endian()
    }
    pub fn block_epoch<'a>(&'a self) -> u64 {
        self.block_epoch_.from_little_endian()
    }
    pub fn index<'a>(&'a self) -> u32 {
        self.index_.from_little_endian()
    }
}

// struct DaoStats, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct DaoStats {
    accumulated_rate_: u64,
    accumulated_capacity_: u64,
} // pub struct DaoStats
impl flatbuffers::SafeSliceAccess for DaoStats {}
impl<'a> flatbuffers::Follow<'a> for DaoStats {
    type Inner = &'a DaoStats;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a DaoStats>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a DaoStats {
    type Inner = &'a DaoStats;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<DaoStats>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for DaoStats {
    type Output = DaoStats;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const DaoStats as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b DaoStats {
    type Output = DaoStats;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const DaoStats as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl DaoStats {
    pub fn new<'a>(_accumulated_rate: u64, _accumulated_capacity: u64) -> Self {
        DaoStats {
            accumulated_rate_: _accumulated_rate.to_little_endian(),
            accumulated_capacity_: _accumulated_capacity.to_little_endian(),
        }
    }
    pub fn accumulated_rate<'a>(&'a self) -> u64 {
        self.accumulated_rate_.from_little_endian()
    }
    pub fn accumulated_capacity<'a>(&'a self) -> u64 {
        self.accumulated_capacity_.from_little_endian()
    }
}

// struct EpochExt, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct EpochExt {
    number_: u64,
    block_reward_: u64,
    remainder_reward_: u64,
    last_block_hash_in_previous_epoch_: Bytes32,
    start_number_: u64,
    length_: u64,
    difficulty_: Bytes32,
} // pub struct EpochExt
impl flatbuffers::SafeSliceAccess for EpochExt {}
impl<'a> flatbuffers::Follow<'a> for EpochExt {
    type Inner = &'a EpochExt;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a EpochExt>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a EpochExt {
    type Inner = &'a EpochExt;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<EpochExt>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for EpochExt {
    type Output = EpochExt;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const EpochExt as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b EpochExt {
    type Output = EpochExt;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const EpochExt as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl EpochExt {
    pub fn new<'a>(
        _number: u64,
        _block_reward: u64,
        _remainder_reward: u64,
        _last_block_hash_in_previous_epoch: &'a Bytes32,
        _start_number: u64,
        _length: u64,
        _difficulty: &'a Bytes32,
    ) -> Self {
        EpochExt {
            number_: _number.to_little_endian(),
            block_reward_: _block_reward.to_little_endian(),
            remainder_reward_: _remainder_reward.to_little_endian(),
            last_block_hash_in_previous_epoch_: *_last_block_hash_in_previous_epoch,
            start_number_: _start_number.to_little_endian(),
            length_: _length.to_little_endian(),
            difficulty_: *_difficulty,
        }
    }
    pub fn number<'a>(&'a self) -> u64 {
        self.number_.from_little_endian()
    }
    pub fn block_reward<'a>(&'a self) -> u64 {
        self.block_reward_.from_little_endian()
    }
    pub fn remainder_reward<'a>(&'a self) -> u64 {
        self.remainder_reward_.from_little_endian()
    }
    pub fn last_block_hash_in_previous_epoch<'a>(&'a self) -> &'a Bytes32 {
        &self.last_block_hash_in_previous_epoch_
    }
    pub fn start_number<'a>(&'a self) -> u64 {
        self.start_number_.from_little_endian()
    }
    pub fn length<'a>(&'a self) -> u64 {
        self.length_.from_little_endian()
    }
    pub fn difficulty<'a>(&'a self) -> &'a Bytes32 {
        &self.difficulty_
    }
}

// struct CellMeta, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CellMeta {
    capacity_: u64,
    data_hash_: Bytes32,
} // pub struct CellMeta
impl flatbuffers::SafeSliceAccess for CellMeta {}
impl<'a> flatbuffers::Follow<'a> for CellMeta {
    type Inner = &'a CellMeta;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a CellMeta>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a CellMeta {
    type Inner = &'a CellMeta;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<CellMeta>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for CellMeta {
    type Output = CellMeta;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const CellMeta as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b CellMeta {
    type Output = CellMeta;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const CellMeta as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl CellMeta {
    pub fn new<'a>(_capacity: u64, _data_hash: &'a Bytes32) -> Self {
        CellMeta {
            capacity_: _capacity.to_little_endian(),
            data_hash_: *_data_hash,
        }
    }
    pub fn capacity<'a>(&'a self) -> u64 {
        self.capacity_.from_little_endian()
    }
    pub fn data_hash<'a>(&'a self) -> &'a Bytes32 {
        &self.data_hash_
    }
}

pub enum BytesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Bytes<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bytes<'a> {
    type Inner = Bytes<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Bytes<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Bytes { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BytesArgs<'args>,
    ) -> flatbuffers::WIPOffset<Bytes<'bldr>> {
        let mut builder = BytesBuilder::new(_fbb);
        if let Some(x) = args.seq {
            builder.add_seq(x);
        }
        builder.finish()
    }

    pub const VT_SEQ: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn seq(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Bytes::VT_SEQ, None)
            .map(|v| v.safe_slice())
    }
}

pub struct BytesArgs<'a> {
    pub seq: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for BytesArgs<'a> {
    #[inline]
    fn default() -> Self {
        BytesArgs { seq: None }
    }
}
pub struct BytesBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BytesBuilder<'a, 'b> {
    #[inline]
    pub fn add_seq(&mut self, seq: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Bytes::VT_SEQ, seq);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BytesBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BytesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Bytes<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum HeaderOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Header<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Header<'a> {
    type Inner = Header<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Header<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Header { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HeaderArgs<'args>,
    ) -> flatbuffers::WIPOffset<Header<'bldr>> {
        let mut builder = HeaderBuilder::new(_fbb);
        builder.add_epoch(args.epoch);
        builder.add_nonce(args.nonce);
        builder.add_number(args.number);
        builder.add_timestamp(args.timestamp);
        if let Some(x) = args.dao {
            builder.add_dao(x);
        }
        builder.add_uncles_count(args.uncles_count);
        if let Some(x) = args.uncles_hash {
            builder.add_uncles_hash(x);
        }
        if let Some(x) = args.proof {
            builder.add_proof(x);
        }
        if let Some(x) = args.difficulty {
            builder.add_difficulty(x);
        }
        if let Some(x) = args.proposals_hash {
            builder.add_proposals_hash(x);
        }
        if let Some(x) = args.witnesses_root {
            builder.add_witnesses_root(x);
        }
        if let Some(x) = args.transactions_root {
            builder.add_transactions_root(x);
        }
        if let Some(x) = args.parent_hash {
            builder.add_parent_hash(x);
        }
        builder.add_version(args.version);
        builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_PARENT_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 8;
    pub const VT_NUMBER: flatbuffers::VOffsetT = 10;
    pub const VT_TRANSACTIONS_ROOT: flatbuffers::VOffsetT = 12;
    pub const VT_WITNESSES_ROOT: flatbuffers::VOffsetT = 14;
    pub const VT_PROPOSALS_HASH: flatbuffers::VOffsetT = 16;
    pub const VT_DIFFICULTY: flatbuffers::VOffsetT = 18;
    pub const VT_NONCE: flatbuffers::VOffsetT = 20;
    pub const VT_PROOF: flatbuffers::VOffsetT = 22;
    pub const VT_UNCLES_HASH: flatbuffers::VOffsetT = 24;
    pub const VT_UNCLES_COUNT: flatbuffers::VOffsetT = 26;
    pub const VT_EPOCH: flatbuffers::VOffsetT = 28;
    pub const VT_DAO: flatbuffers::VOffsetT = 30;

    #[inline]
    pub fn version(&self) -> u32 {
        self._tab.get::<u32>(Header::VT_VERSION, Some(0)).unwrap()
    }
    #[inline]
    pub fn parent_hash(&self) -> Option<&'a Bytes32> {
        self._tab.get::<Bytes32>(Header::VT_PARENT_HASH, None)
    }
    #[inline]
    pub fn timestamp(&self) -> u64 {
        self._tab.get::<u64>(Header::VT_TIMESTAMP, Some(0)).unwrap()
    }
    #[inline]
    pub fn number(&self) -> u64 {
        self._tab.get::<u64>(Header::VT_NUMBER, Some(0)).unwrap()
    }
    #[inline]
    pub fn transactions_root(&self) -> Option<&'a Bytes32> {
        self._tab.get::<Bytes32>(Header::VT_TRANSACTIONS_ROOT, None)
    }
    #[inline]
    pub fn witnesses_root(&self) -> Option<&'a Bytes32> {
        self._tab.get::<Bytes32>(Header::VT_WITNESSES_ROOT, None)
    }
    #[inline]
    pub fn proposals_hash(&self) -> Option<&'a Bytes32> {
        self._tab.get::<Bytes32>(Header::VT_PROPOSALS_HASH, None)
    }
    #[inline]
    pub fn difficulty(&self) -> Option<&'a Bytes32> {
        self._tab.get::<Bytes32>(Header::VT_DIFFICULTY, None)
    }
    #[inline]
    pub fn nonce(&self) -> u64 {
        self._tab.get::<u64>(Header::VT_NONCE, Some(0)).unwrap()
    }
    #[inline]
    pub fn proof(&self) -> Option<Bytes<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Header::VT_PROOF, None)
    }
    #[inline]
    pub fn uncles_hash(&self) -> Option<&'a Bytes32> {
        self._tab.get::<Bytes32>(Header::VT_UNCLES_HASH, None)
    }
    #[inline]
    pub fn uncles_count(&self) -> u32 {
        self._tab
            .get::<u32>(Header::VT_UNCLES_COUNT, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn epoch(&self) -> u64 {
        self._tab.get::<u64>(Header::VT_EPOCH, Some(0)).unwrap()
    }
    #[inline]
    pub fn dao(&self) -> Option<Bytes<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(Header::VT_DAO, None)
    }
}

pub struct HeaderArgs<'a> {
    pub version: u32,
    pub parent_hash: Option<&'a Bytes32>,
    pub timestamp: u64,
    pub number: u64,
    pub transactions_root: Option<&'a Bytes32>,
    pub witnesses_root: Option<&'a Bytes32>,
    pub proposals_hash: Option<&'a Bytes32>,
    pub difficulty: Option<&'a Bytes32>,
    pub nonce: u64,
    pub proof: Option<flatbuffers::WIPOffset<Bytes<'a>>>,
    pub uncles_hash: Option<&'a Bytes32>,
    pub uncles_count: u32,
    pub epoch: u64,
    pub dao: Option<flatbuffers::WIPOffset<Bytes<'a>>>,
}
impl<'a> Default for HeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        HeaderArgs {
            version: 0,
            parent_hash: None,
            timestamp: 0,
            number: 0,
            transactions_root: None,
            witnesses_root: None,
            proposals_hash: None,
            difficulty: None,
            nonce: 0,
            proof: None,
            uncles_hash: None,
            uncles_count: 0,
            epoch: 0,
            dao: None,
        }
    }
}
pub struct HeaderBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HeaderBuilder<'a, 'b> {
    #[inline]
    pub fn add_version(&mut self, version: u32) {
        self.fbb_.push_slot::<u32>(Header::VT_VERSION, version, 0);
    }
    #[inline]
    pub fn add_parent_hash(&mut self, parent_hash: &'b Bytes32) {
        self.fbb_
            .push_slot_always::<&Bytes32>(Header::VT_PARENT_HASH, parent_hash);
    }
    #[inline]
    pub fn add_timestamp(&mut self, timestamp: u64) {
        self.fbb_
            .push_slot::<u64>(Header::VT_TIMESTAMP, timestamp, 0);
    }
    #[inline]
    pub fn add_number(&mut self, number: u64) {
        self.fbb_.push_slot::<u64>(Header::VT_NUMBER, number, 0);
    }
    #[inline]
    pub fn add_transactions_root(&mut self, transactions_root: &'b Bytes32) {
        self.fbb_
            .push_slot_always::<&Bytes32>(Header::VT_TRANSACTIONS_ROOT, transactions_root);
    }
    #[inline]
    pub fn add_witnesses_root(&mut self, witnesses_root: &'b Bytes32) {
        self.fbb_
            .push_slot_always::<&Bytes32>(Header::VT_WITNESSES_ROOT, witnesses_root);
    }
    #[inline]
    pub fn add_proposals_hash(&mut self, proposals_hash: &'b Bytes32) {
        self.fbb_
            .push_slot_always::<&Bytes32>(Header::VT_PROPOSALS_HASH, proposals_hash);
    }
    #[inline]
    pub fn add_difficulty(&mut self, difficulty: &'b Bytes32) {
        self.fbb_
            .push_slot_always::<&Bytes32>(Header::VT_DIFFICULTY, difficulty);
    }
    #[inline]
    pub fn add_nonce(&mut self, nonce: u64) {
        self.fbb_.push_slot::<u64>(Header::VT_NONCE, nonce, 0);
    }
    #[inline]
    pub fn add_proof(&mut self, proof: flatbuffers::WIPOffset<Bytes<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Header::VT_PROOF, proof);
    }
    #[inline]
    pub fn add_uncles_hash(&mut self, uncles_hash: &'b Bytes32) {
        self.fbb_
            .push_slot_always::<&Bytes32>(Header::VT_UNCLES_HASH, uncles_hash);
    }
    #[inline]
    pub fn add_uncles_count(&mut self, uncles_count: u32) {
        self.fbb_
            .push_slot::<u32>(Header::VT_UNCLES_COUNT, uncles_count, 0);
    }
    #[inline]
    pub fn add_epoch(&mut self, epoch: u64) {
        self.fbb_.push_slot::<u64>(Header::VT_EPOCH, epoch, 0);
    }
    #[inline]
    pub fn add_dao(&mut self, dao: flatbuffers::WIPOffset<Bytes<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Bytes>>(Header::VT_DAO, dao);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HeaderBuilder<'a, 'b> {
        let start = _fbb.start_table();
        HeaderBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Header<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum BlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Block<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Block<'a> {
    type Inner = Block<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Block<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Block { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockArgs<'args>,
    ) -> flatbuffers::WIPOffset<Block<'bldr>> {
        let mut builder = BlockBuilder::new(_fbb);
        if let Some(x) = args.proposals {
            builder.add_proposals(x);
        }
        if let Some(x) = args.transactions {
            builder.add_transactions(x);
        }
        if let Some(x) = args.uncles {
            builder.add_uncles(x);
        }
        if let Some(x) = args.header {
            builder.add_header(x);
        }
        builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_UNCLES: flatbuffers::VOffsetT = 6;
    pub const VT_TRANSACTIONS: flatbuffers::VOffsetT = 8;
    pub const VT_PROPOSALS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn header(&self) -> Option<Header<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<Header<'a>>>(Block::VT_HEADER, None)
    }
    #[inline]
    pub fn uncles(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UncleBlock<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<UncleBlock<'a>>>,
        >>(Block::VT_UNCLES, None)
    }
    #[inline]
    pub fn transactions(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Transaction<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>>,
        >>(Block::VT_TRANSACTIONS, None)
    }
    #[inline]
    pub fn proposals(&self) -> Option<&'a [ProposalShortId]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<ProposalShortId>>>(
                Block::VT_PROPOSALS,
                None,
            )
            .map(|v| v.safe_slice())
    }
}

pub struct BlockArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a>>>,
    pub uncles: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UncleBlock<'a>>>,
        >,
    >,
    pub transactions: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Transaction<'a>>>,
        >,
    >,
    pub proposals: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ProposalShortId>>>,
}
impl<'a> Default for BlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockArgs {
            header: None,
            uncles: None,
            transactions: None,
            proposals: None,
        }
    }
}
pub struct BlockBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockBuilder<'a, 'b> {
    #[inline]
    pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Header>>(Block::VT_HEADER, header);
    }
    #[inline]
    pub fn add_uncles(
        &mut self,
        uncles: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<UncleBlock<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_UNCLES, uncles);
    }
    #[inline]
    pub fn add_transactions(
        &mut self,
        transactions: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Transaction<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_TRANSACTIONS, transactions);
    }
    #[inline]
    pub fn add_proposals(
        &mut self,
        proposals: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ProposalShortId>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Block::VT_PROPOSALS, proposals);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BlockBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Block<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum BlockBodyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BlockBody<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockBody<'a> {
    type Inner = BlockBody<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BlockBody<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BlockBody { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockBodyArgs<'args>,
    ) -> flatbuffers::WIPOffset<BlockBody<'bldr>> {
        let mut builder = BlockBodyBuilder::new(_fbb);
        if let Some(x) = args.transactions {
            builder.add_transactions(x);
        }
        builder.finish()
    }

    pub const VT_TRANSACTIONS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn transactions(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Transaction<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<Transaction<'a>>>,
        >>(BlockBody::VT_TRANSACTIONS, None)
    }
}

pub struct BlockBodyArgs<'a> {
    pub transactions: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Transaction<'a>>>,
        >,
    >,
}
impl<'a> Default for BlockBodyArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockBodyArgs { transactions: None }
    }
}
pub struct BlockBodyBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockBodyBuilder<'a, 'b> {
    #[inline]
    pub fn add_transactions(
        &mut self,
        transactions: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Transaction<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            BlockBody::VT_TRANSACTIONS,
            transactions,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockBodyBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BlockBodyBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<BlockBody<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum UncleBlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct UncleBlock<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UncleBlock<'a> {
    type Inner = UncleBlock<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> UncleBlock<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UncleBlock { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UncleBlockArgs<'args>,
    ) -> flatbuffers::WIPOffset<UncleBlock<'bldr>> {
        let mut builder = UncleBlockBuilder::new(_fbb);
        if let Some(x) = args.proposals {
            builder.add_proposals(x);
        }
        if let Some(x) = args.header {
            builder.add_header(x);
        }
        builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_PROPOSALS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn header(&self) -> Option<Header<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<Header<'a>>>(UncleBlock::VT_HEADER, None)
    }
    #[inline]
    pub fn proposals(&self) -> Option<&'a [ProposalShortId]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<ProposalShortId>>>(
                UncleBlock::VT_PROPOSALS,
                None,
            )
            .map(|v| v.safe_slice())
    }
}

pub struct UncleBlockArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a>>>,
    pub proposals: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ProposalShortId>>>,
}
impl<'a> Default for UncleBlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        UncleBlockArgs {
            header: None,
            proposals: None,
        }
    }
}
pub struct UncleBlockBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UncleBlockBuilder<'a, 'b> {
    #[inline]
    pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Header>>(UncleBlock::VT_HEADER, header);
    }
    #[inline]
    pub fn add_proposals(
        &mut self,
        proposals: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ProposalShortId>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(UncleBlock::VT_PROPOSALS, proposals);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UncleBlockBuilder<'a, 'b> {
        let start = _fbb.start_table();
        UncleBlockBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<UncleBlock<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum TransactionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Transaction<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Transaction<'a> {
    type Inner = Transaction<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Transaction<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Transaction { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TransactionArgs<'args>,
    ) -> flatbuffers::WIPOffset<Transaction<'bldr>> {
        let mut builder = TransactionBuilder::new(_fbb);
        if let Some(x) = args.witnesses {
            builder.add_witnesses(x);
        }
        if let Some(x) = args.outputs {
            builder.add_outputs(x);
        }
        if let Some(x) = args.inputs {
            builder.add_inputs(x);
        }
        if let Some(x) = args.deps {
            builder.add_deps(x);
        }
        builder.add_version(args.version);
        builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_DEPS: flatbuffers::VOffsetT = 6;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 8;
    pub const VT_OUTPUTS: flatbuffers::VOffsetT = 10;
    pub const VT_WITNESSES: flatbuffers::VOffsetT = 12;

    #[inline]
    pub fn version(&self) -> u32 {
        self._tab
            .get::<u32>(Transaction::VT_VERSION, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn deps(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutPoint<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<OutPoint<'a>>>,
        >>(Transaction::VT_DEPS, None)
    }
    #[inline]
    pub fn inputs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CellInput<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<CellInput<'a>>>,
        >>(Transaction::VT_INPUTS, None)
    }
    #[inline]
    pub fn outputs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CellOutput<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<CellOutput<'a>>>,
        >>(Transaction::VT_OUTPUTS, None)
    }
    #[inline]
    pub fn witnesses(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Witness<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<Witness<'a>>>,
        >>(Transaction::VT_WITNESSES, None)
    }
}

pub struct TransactionArgs<'a> {
    pub version: u32,
    pub deps: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OutPoint<'a>>>>,
    >,
    pub inputs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CellInput<'a>>>,
        >,
    >,
    pub outputs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CellOutput<'a>>>,
        >,
    >,
    pub witnesses: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Witness<'a>>>>,
    >,
}
impl<'a> Default for TransactionArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransactionArgs {
            version: 0,
            deps: None,
            inputs: None,
            outputs: None,
            witnesses: None,
        }
    }
}
pub struct TransactionBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransactionBuilder<'a, 'b> {
    #[inline]
    pub fn add_version(&mut self, version: u32) {
        self.fbb_
            .push_slot::<u32>(Transaction::VT_VERSION, version, 0);
    }
    #[inline]
    pub fn add_deps(
        &mut self,
        deps: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<OutPoint<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_DEPS, deps);
    }
    #[inline]
    pub fn add_inputs(
        &mut self,
        inputs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CellInput<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_INPUTS, inputs);
    }
    #[inline]
    pub fn add_outputs(
        &mut self,
        outputs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CellOutput<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_OUTPUTS, outputs);
    }
    #[inline]
    pub fn add_witnesses(
        &mut self,
        witnesses: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Witness<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_WITNESSES, witnesses);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransactionBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TransactionBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Transaction<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum WitnessOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Witness<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Witness<'a> {
    type Inner = Witness<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Witness<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Witness { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WitnessArgs<'args>,
    ) -> flatbuffers::WIPOffset<Witness<'bldr>> {
        let mut builder = WitnessBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>,
        >>(Witness::VT_DATA, None)
    }
}

pub struct WitnessArgs<'a> {
    pub data: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bytes<'a>>>>,
    >,
}
impl<'a> Default for WitnessArgs<'a> {
    #[inline]
    fn default() -> Self {
        WitnessArgs { data: None }
    }
}
pub struct WitnessBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WitnessBuilder<'a, 'b> {
    #[inline]
    pub fn add_data(
        &mut self,
        data: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Bytes<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Witness::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WitnessBuilder<'a, 'b> {
        let start = _fbb.start_table();
        WitnessBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Witness<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum OutPointOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct OutPoint<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OutPoint<'a> {
    type Inner = OutPoint<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> OutPoint<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OutPoint { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OutPointArgs<'args>,
    ) -> flatbuffers::WIPOffset<OutPoint<'bldr>> {
        let mut builder = OutPointBuilder::new(_fbb);
        builder.add_index(args.index);
        if let Some(x) = args.tx_hash {
            builder.add_tx_hash(x);
        }
        if let Some(x) = args.block_hash {
            builder.add_block_hash(x);
        }
        builder.finish()
    }

    pub const VT_BLOCK_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_TX_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_INDEX: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn block_hash(&self) -> Option<&'a Bytes32> {
        self._tab.get::<Bytes32>(OutPoint::VT_BLOCK_HASH, None)
    }
    #[inline]
    pub fn tx_hash(&self) -> Option<&'a Bytes32> {
        self._tab.get::<Bytes32>(OutPoint::VT_TX_HASH, None)
    }
    #[inline]
    pub fn index(&self) -> u32 {
        self._tab.get::<u32>(OutPoint::VT_INDEX, Some(0)).unwrap()
    }
}

pub struct OutPointArgs<'a> {
    pub block_hash: Option<&'a Bytes32>,
    pub tx_hash: Option<&'a Bytes32>,
    pub index: u32,
}
impl<'a> Default for OutPointArgs<'a> {
    #[inline]
    fn default() -> Self {
        OutPointArgs {
            block_hash: None,
            tx_hash: None,
            index: 0,
        }
    }
}
pub struct OutPointBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OutPointBuilder<'a, 'b> {
    #[inline]
    pub fn add_block_hash(&mut self, block_hash: &'b Bytes32) {
        self.fbb_
            .push_slot_always::<&Bytes32>(OutPoint::VT_BLOCK_HASH, block_hash);
    }
    #[inline]
    pub fn add_tx_hash(&mut self, tx_hash: &'b Bytes32) {
        self.fbb_
            .push_slot_always::<&Bytes32>(OutPoint::VT_TX_HASH, tx_hash);
    }
    #[inline]
    pub fn add_index(&mut self, index: u32) {
        self.fbb_.push_slot::<u32>(OutPoint::VT_INDEX, index, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OutPointBuilder<'a, 'b> {
        let start = _fbb.start_table();
        OutPointBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<OutPoint<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum CellInputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CellInput<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CellInput<'a> {
    type Inner = CellInput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CellInput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CellInput { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CellInputArgs<'args>,
    ) -> flatbuffers::WIPOffset<CellInput<'bldr>> {
        let mut builder = CellInputBuilder::new(_fbb);
        builder.add_since(args.since);
        builder.add_index(args.index);
        if let Some(x) = args.tx_hash {
            builder.add_tx_hash(x);
        }
        if let Some(x) = args.block_hash {
            builder.add_block_hash(x);
        }
        builder.finish()
    }

    pub const VT_BLOCK_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_TX_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_INDEX: flatbuffers::VOffsetT = 8;
    pub const VT_SINCE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn block_hash(&self) -> Option<&'a Bytes32> {
        self._tab.get::<Bytes32>(CellInput::VT_BLOCK_HASH, None)
    }
    #[inline]
    pub fn tx_hash(&self) -> Option<&'a Bytes32> {
        self._tab.get::<Bytes32>(CellInput::VT_TX_HASH, None)
    }
    #[inline]
    pub fn index(&self) -> u32 {
        self._tab.get::<u32>(CellInput::VT_INDEX, Some(0)).unwrap()
    }
    #[inline]
    pub fn since(&self) -> u64 {
        self._tab.get::<u64>(CellInput::VT_SINCE, Some(0)).unwrap()
    }
}

pub struct CellInputArgs<'a> {
    pub block_hash: Option<&'a Bytes32>,
    pub tx_hash: Option<&'a Bytes32>,
    pub index: u32,
    pub since: u64,
}
impl<'a> Default for CellInputArgs<'a> {
    #[inline]
    fn default() -> Self {
        CellInputArgs {
            block_hash: None,
            tx_hash: None,
            index: 0,
            since: 0,
        }
    }
}
pub struct CellInputBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CellInputBuilder<'a, 'b> {
    #[inline]
    pub fn add_block_hash(&mut self, block_hash: &'b Bytes32) {
        self.fbb_
            .push_slot_always::<&Bytes32>(CellInput::VT_BLOCK_HASH, block_hash);
    }
    #[inline]
    pub fn add_tx_hash(&mut self, tx_hash: &'b Bytes32) {
        self.fbb_
            .push_slot_always::<&Bytes32>(CellInput::VT_TX_HASH, tx_hash);
    }
    #[inline]
    pub fn add_index(&mut self, index: u32) {
        self.fbb_.push_slot::<u32>(CellInput::VT_INDEX, index, 0);
    }
    #[inline]
    pub fn add_since(&mut self, since: u64) {
        self.fbb_.push_slot::<u64>(CellInput::VT_SINCE, since, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CellInputBuilder<'a, 'b> {
        let start = _fbb.start_table();
        CellInputBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CellInput<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum CellOutputOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CellOutput<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CellOutput<'a> {
    type Inner = CellOutput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CellOutput<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CellOutput { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CellOutputArgs<'args>,
    ) -> flatbuffers::WIPOffset<CellOutput<'bldr>> {
        let mut builder = CellOutputBuilder::new(_fbb);
        builder.add_capacity(args.capacity);
        if let Some(x) = args.type_ {
            builder.add_type_(x);
        }
        if let Some(x) = args.lock {
            builder.add_lock(x);
        }
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    pub const VT_CAPACITY: flatbuffers::VOffsetT = 4;
    pub const VT_DATA: flatbuffers::VOffsetT = 6;
    pub const VT_LOCK: flatbuffers::VOffsetT = 8;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn capacity(&self) -> u64 {
        self._tab
            .get::<u64>(CellOutput::VT_CAPACITY, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn data(&self) -> Option<Bytes<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(CellOutput::VT_DATA, None)
    }
    #[inline]
    pub fn lock(&self) -> Option<Script<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<Script<'a>>>(CellOutput::VT_LOCK, None)
    }
    #[inline]
    pub fn type_(&self) -> Option<Script<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<Script<'a>>>(CellOutput::VT_TYPE_, None)
    }
}

pub struct CellOutputArgs<'a> {
    pub capacity: u64,
    pub data: Option<flatbuffers::WIPOffset<Bytes<'a>>>,
    pub lock: Option<flatbuffers::WIPOffset<Script<'a>>>,
    pub type_: Option<flatbuffers::WIPOffset<Script<'a>>>,
}
impl<'a> Default for CellOutputArgs<'a> {
    #[inline]
    fn default() -> Self {
        CellOutputArgs {
            capacity: 0,
            data: None,
            lock: None,
            type_: None,
        }
    }
}
pub struct CellOutputBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CellOutputBuilder<'a, 'b> {
    #[inline]
    pub fn add_capacity(&mut self, capacity: u64) {
        self.fbb_
            .push_slot::<u64>(CellOutput::VT_CAPACITY, capacity, 0);
    }
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<Bytes<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Bytes>>(CellOutput::VT_DATA, data);
    }
    #[inline]
    pub fn add_lock(&mut self, lock: flatbuffers::WIPOffset<Script<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Script>>(CellOutput::VT_LOCK, lock);
    }
    #[inline]
    pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<Script<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Script>>(CellOutput::VT_TYPE_, type_);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CellOutputBuilder<'a, 'b> {
        let start = _fbb.start_table();
        CellOutputBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CellOutput<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum ScriptOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Script<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Script<'a> {
    type Inner = Script<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Script<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Script { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ScriptArgs<'args>,
    ) -> flatbuffers::WIPOffset<Script<'bldr>> {
        let mut builder = ScriptBuilder::new(_fbb);
        if let Some(x) = args.code_hash {
            builder.add_code_hash(x);
        }
        if let Some(x) = args.args {
            builder.add_args(x);
        }
        builder.finish()
    }

    pub const VT_ARGS: flatbuffers::VOffsetT = 4;
    pub const VT_CODE_HASH: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn args(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bytes<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<Bytes<'a>>>,
        >>(Script::VT_ARGS, None)
    }
    #[inline]
    pub fn code_hash(&self) -> Option<&'a Bytes32> {
        self._tab.get::<Bytes32>(Script::VT_CODE_HASH, None)
    }
}

pub struct ScriptArgs<'a> {
    pub args: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bytes<'a>>>>,
    >,
    pub code_hash: Option<&'a Bytes32>,
}
impl<'a> Default for ScriptArgs<'a> {
    #[inline]
    fn default() -> Self {
        ScriptArgs {
            args: None,
            code_hash: None,
        }
    }
}
pub struct ScriptBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ScriptBuilder<'a, 'b> {
    #[inline]
    pub fn add_args(
        &mut self,
        args: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Bytes<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Script::VT_ARGS, args);
    }
    #[inline]
    pub fn add_code_hash(&mut self, code_hash: &'b Bytes32) {
        self.fbb_
            .push_slot_always::<&Bytes32>(Script::VT_CODE_HASH, code_hash);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ScriptBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ScriptBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Script<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum BlockExtOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BlockExt<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockExt<'a> {
    type Inner = BlockExt<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BlockExt<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BlockExt { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockExtArgs<'args>,
    ) -> flatbuffers::WIPOffset<BlockExt<'bldr>> {
        let mut builder = BlockExtBuilder::new(_fbb);
        builder.add_total_uncles_count(args.total_uncles_count);
        builder.add_received_at(args.received_at);
        if let Some(x) = args.txs_fees {
            builder.add_txs_fees(x);
        }
        if let Some(x) = args.dao_stats {
            builder.add_dao_stats(x);
        }
        if let Some(x) = args.total_difficulty {
            builder.add_total_difficulty(x);
        }
        builder.add_verified(args.verified);
        builder.add_has_verified(args.has_verified);
        builder.finish()
    }

    pub const VT_RECEIVED_AT: flatbuffers::VOffsetT = 4;
    pub const VT_TOTAL_DIFFICULTY: flatbuffers::VOffsetT = 6;
    pub const VT_TOTAL_UNCLES_COUNT: flatbuffers::VOffsetT = 8;
    pub const VT_HAS_VERIFIED: flatbuffers::VOffsetT = 10;
    pub const VT_VERIFIED: flatbuffers::VOffsetT = 12;
    pub const VT_DAO_STATS: flatbuffers::VOffsetT = 14;
    pub const VT_TXS_FEES: flatbuffers::VOffsetT = 16;

    #[inline]
    pub fn received_at(&self) -> u64 {
        self._tab
            .get::<u64>(BlockExt::VT_RECEIVED_AT, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn total_difficulty(&self) -> Option<&'a Bytes32> {
        self._tab
            .get::<Bytes32>(BlockExt::VT_TOTAL_DIFFICULTY, None)
    }
    #[inline]
    pub fn total_uncles_count(&self) -> u64 {
        self._tab
            .get::<u64>(BlockExt::VT_TOTAL_UNCLES_COUNT, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn has_verified(&self) -> bool {
        self._tab
            .get::<bool>(BlockExt::VT_HAS_VERIFIED, Some(false))
            .unwrap()
    }
    #[inline]
    pub fn verified(&self) -> bool {
        self._tab
            .get::<bool>(BlockExt::VT_VERIFIED, Some(false))
            .unwrap()
    }
    #[inline]
    pub fn dao_stats(&self) -> Option<&'a DaoStats> {
        self._tab.get::<DaoStats>(BlockExt::VT_DAO_STATS, None)
    }
    #[inline]
    pub fn txs_fees(&self) -> Option<flatbuffers::Vector<'a, u64>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(
                BlockExt::VT_TXS_FEES,
                None,
            )
    }
}

pub struct BlockExtArgs<'a> {
    pub received_at: u64,
    pub total_difficulty: Option<&'a Bytes32>,
    pub total_uncles_count: u64,
    pub has_verified: bool,
    pub verified: bool,
    pub dao_stats: Option<&'a DaoStats>,
    pub txs_fees: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
}
impl<'a> Default for BlockExtArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockExtArgs {
            received_at: 0,
            total_difficulty: None,
            total_uncles_count: 0,
            has_verified: false,
            verified: false,
            dao_stats: None,
            txs_fees: None,
        }
    }
}
pub struct BlockExtBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockExtBuilder<'a, 'b> {
    #[inline]
    pub fn add_received_at(&mut self, received_at: u64) {
        self.fbb_
            .push_slot::<u64>(BlockExt::VT_RECEIVED_AT, received_at, 0);
    }
    #[inline]
    pub fn add_total_difficulty(&mut self, total_difficulty: &'b Bytes32) {
        self.fbb_
            .push_slot_always::<&Bytes32>(BlockExt::VT_TOTAL_DIFFICULTY, total_difficulty);
    }
    #[inline]
    pub fn add_total_uncles_count(&mut self, total_uncles_count: u64) {
        self.fbb_
            .push_slot::<u64>(BlockExt::VT_TOTAL_UNCLES_COUNT, total_uncles_count, 0);
    }
    #[inline]
    pub fn add_has_verified(&mut self, has_verified: bool) {
        self.fbb_
            .push_slot::<bool>(BlockExt::VT_HAS_VERIFIED, has_verified, false);
    }
    #[inline]
    pub fn add_verified(&mut self, verified: bool) {
        self.fbb_
            .push_slot::<bool>(BlockExt::VT_VERIFIED, verified, false);
    }
    #[inline]
    pub fn add_dao_stats(&mut self, dao_stats: &'b DaoStats) {
        self.fbb_
            .push_slot_always::<&DaoStats>(BlockExt::VT_DAO_STATS, dao_stats);
    }
    #[inline]
    pub fn add_txs_fees(&mut self, txs_fees: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u64>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(BlockExt::VT_TXS_FEES, txs_fees);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockExtBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BlockExtBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<BlockExt<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum TransactionMetaOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TransactionMeta<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransactionMeta<'a> {
    type Inner = TransactionMeta<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TransactionMeta<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransactionMeta { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TransactionMetaArgs<'args>,
    ) -> flatbuffers::WIPOffset<TransactionMeta<'bldr>> {
        let mut builder = TransactionMetaBuilder::new(_fbb);
        builder.add_epoch_number(args.epoch_number);
        builder.add_block_number(args.block_number);
        builder.add_len(args.len);
        if let Some(x) = args.bits {
            builder.add_bits(x);
        }
        builder.add_cellbase(args.cellbase);
        builder.finish()
    }

    pub const VT_BLOCK_NUMBER: flatbuffers::VOffsetT = 4;
    pub const VT_EPOCH_NUMBER: flatbuffers::VOffsetT = 6;
    pub const VT_CELLBASE: flatbuffers::VOffsetT = 8;
    pub const VT_BITS: flatbuffers::VOffsetT = 10;
    pub const VT_LEN: flatbuffers::VOffsetT = 12;

    #[inline]
    pub fn block_number(&self) -> u64 {
        self._tab
            .get::<u64>(TransactionMeta::VT_BLOCK_NUMBER, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn epoch_number(&self) -> u64 {
        self._tab
            .get::<u64>(TransactionMeta::VT_EPOCH_NUMBER, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn cellbase(&self) -> bool {
        self._tab
            .get::<bool>(TransactionMeta::VT_CELLBASE, Some(false))
            .unwrap()
    }
    #[inline]
    pub fn bits(&self) -> Option<Bytes<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<Bytes<'a>>>(TransactionMeta::VT_BITS, None)
    }
    #[inline]
    pub fn len(&self) -> u32 {
        self._tab
            .get::<u32>(TransactionMeta::VT_LEN, Some(0))
            .unwrap()
    }
}

pub struct TransactionMetaArgs<'a> {
    pub block_number: u64,
    pub epoch_number: u64,
    pub cellbase: bool,
    pub bits: Option<flatbuffers::WIPOffset<Bytes<'a>>>,
    pub len: u32,
}
impl<'a> Default for TransactionMetaArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransactionMetaArgs {
            block_number: 0,
            epoch_number: 0,
            cellbase: false,
            bits: None,
            len: 0,
        }
    }
}
pub struct TransactionMetaBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransactionMetaBuilder<'a, 'b> {
    #[inline]
    pub fn add_block_number(&mut self, block_number: u64) {
        self.fbb_
            .push_slot::<u64>(TransactionMeta::VT_BLOCK_NUMBER, block_number, 0);
    }
    #[inline]
    pub fn add_epoch_number(&mut self, epoch_number: u64) {
        self.fbb_
            .push_slot::<u64>(TransactionMeta::VT_EPOCH_NUMBER, epoch_number, 0);
    }
    #[inline]
    pub fn add_cellbase(&mut self, cellbase: bool) {
        self.fbb_
            .push_slot::<bool>(TransactionMeta::VT_CELLBASE, cellbase, false);
    }
    #[inline]
    pub fn add_bits(&mut self, bits: flatbuffers::WIPOffset<Bytes<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Bytes>>(TransactionMeta::VT_BITS, bits);
    }
    #[inline]
    pub fn add_len(&mut self, len: u32) {
        self.fbb_.push_slot::<u32>(TransactionMeta::VT_LEN, len, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransactionMetaBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TransactionMetaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransactionMeta<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}
