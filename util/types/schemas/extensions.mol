import blockchain;

/* Basic Types */

option BoolOpt (Bool);
option Byte32Opt (Byte32);

array Bool [byte; 1];

// The `BeUintN` is used to store a `N` bits unsigned integer
// as a byte array in big endian.
array BeUint32 [byte; 4];
array BeUint64 [byte; 8];

vector Uint32Vec <Uint32>;
vector Uint64Vec <Uint64>;
vector Uint256Vec <Uint256>;

/* Extension Types for Chain */

option CellOutputOpt (CellOutput);

vector HeaderVec <Header>;
vector OutPointVec <OutPoint>;

/* Types for Light Client */

struct HeaderDigest {
    hash:                   Byte32,

    total_difficulty:       Uint256,

    start_number:           Uint64,
    end_number:             Uint64,

    start_epoch:            Uint64,
    end_epoch:              Uint64,

    start_timestamp:        Uint64,
    end_timestamp:          Uint64,

    start_compact_target:   Uint32,
    end_compact_target:     Uint32,
}

/* Types for Storage */

struct HeaderView {
    hash:               Byte32,
    data:               Header,
}

table UncleBlockVecView {
    hashes:             Byte32Vec,
    data:               UncleBlockVec,
}

table TransactionView {
    hash:               Byte32,
    witness_hash:       Byte32,
    data:               Transaction,
}

table BlockExt {
    total_difficulty:   Uint256,
    total_uncles_count: Uint64,
    received_at:        Uint64,
    txs_fees:           Uint64Vec,
    verified:           BoolOpt,
}

struct EpochExt {
    previous_epoch_hash_rate:           Uint256,
    last_block_hash_in_previous_epoch:  Byte32,
    compact_target:                     Uint32,
    number:                             Uint64,
    base_block_reward:                  Uint64,
    remainder_reward:                   Uint64,
    start_number:                       Uint64,
    length:                             Uint64,
}

struct TransactionKey {
    block_hash:     Byte32,
    index:          BeUint32,
}

struct NumberHash {
    number:         Uint64,
    block_hash:     Byte32,
}

struct TransactionInfo {
    block_number:   Uint64,
    block_epoch:    Uint64,
    key:            TransactionKey,
}

table CellEntry {
    output:                CellOutput,
    block_hash:            Byte32,
    block_number:          Uint64,
    block_epoch:           Uint64,
    index:                 Uint32,
    data_size:             Uint64,
}

table CellDataEntry {
    output_data:           Bytes,
    output_data_hash:      Byte32,
}

/* Types for Network/Relay */

union RelayMessage {
    CompactBlock,
    RelayTransactions,
    RelayTransactionHashes,
    GetRelayTransactions,
    GetBlockTransactions,
    BlockTransactions,
    GetBlockProposal,
    BlockProposal,
}

table CompactBlock {
    header:                     Header,
    short_ids:                  ProposalShortIdVec,
    prefilled_transactions:     IndexTransactionVec,
    uncles:                     Byte32Vec,
    proposals:                  ProposalShortIdVec,
}

table CompactBlockV1 {
    header:                     Header,
    short_ids:                  ProposalShortIdVec,
    prefilled_transactions:     IndexTransactionVec,
    uncles:                     Byte32Vec,
    proposals:                  ProposalShortIdVec,
    extension:                  Bytes,
}

table RelayTransaction {
    cycles:                     Uint64,
    transaction:                Transaction,
}
vector RelayTransactionVec <RelayTransaction>;

table RelayTransactions {
    transactions:               RelayTransactionVec,
}

table RelayTransactionHashes {
    tx_hashes:                  Byte32Vec,
}

table GetRelayTransactions {
    tx_hashes:                  Byte32Vec,
}

table GetBlockTransactions {
    block_hash:                 Byte32,
    indexes:                    Uint32Vec,
    uncle_indexes:              Uint32Vec,
}

table BlockTransactions {
    block_hash:                 Byte32,
    transactions:               TransactionVec,
    uncles:                     UncleBlockVec,
}

table GetBlockProposal {
    block_hash:                 Byte32,
    proposals:                  ProposalShortIdVec,
}

table BlockProposal {
    transactions:               TransactionVec,
}

table IndexTransaction {
    index:                      Uint32,
    transaction:                Transaction,
}
vector IndexTransactionVec <IndexTransaction>;

/* Types for Network/BlockFilter */

union BlockFilterMessage {
    GetBlockFilters,
    BlockFilters,
    GetBlockFilterHashes,
    BlockFilterHashes,
    GetBlockFilterCheckPoints,
    BlockFilterCheckPoints,
}

struct GetBlockFilters {
    start_number:   Uint64,
}

table BlockFilters {
    start_number:   Uint64,
    block_hashes:   Byte32Vec,
    filters:        BytesVec,
}

struct GetBlockFilterHashes {
    start_number:   Uint64,
}

table BlockFilterHashes {
    start_number:               Uint64,
    parent_block_filter_hash:   Byte32,
    block_filter_hashes:        Byte32Vec,
}

struct GetBlockFilterCheckPoints {
    start_number:   Uint64,
}

table BlockFilterCheckPoints {
    start_number:           Uint64,
    block_filter_hashes:    Byte32Vec,
}


/* Types for Network/Sync */

union SyncMessage {
    GetHeaders,
    SendHeaders,
    GetBlocks,
    SendBlock,
    SetFilter,
    AddFilter,
    ClearFilter,
    FilteredBlock,
    InIBD,
}

table GetHeaders {
    hash_stop:              Byte32,
    block_locator_hashes:   Byte32Vec,
}

table GetBlocks {
    block_hashes:           Byte32Vec,
}

table SendHeaders {
    headers:                HeaderVec,
}

table SendBlock {
    block:                  Block,
}

table SetFilter {
    hash_seed:              Uint32,
    filter:                 Bytes,
    num_hashes:             byte,
}

table AddFilter {
    filter:                 Bytes,
}

table ClearFilter {
}

table FilteredBlock {
    header:                 Header,
    witnesses_root:         Byte32,
    transactions:           TransactionVec,
    proof:                  MerkleProof,
}

table MerkleProof {
    indices:                Uint32Vec,
    lemmas:                 Byte32Vec,
}

table InIBD {
}

/* Types for Network/LightClient */

vector HeaderDigestVec <HeaderDigest>;

struct HeaderWithChainRoot {
    header:                 Header,
    uncles_hash:            Byte32,
    chain_root:             HeaderDigest,
}

vector HeaderWithChainRootVec <HeaderWithChainRoot>;

table VerifiableHeader {
    header:                 Header,
    uncles_hash:            Byte32,
    extension:              BytesOpt,
}

union LightClientMessage {
    GetLastState,
    SendLastState,
    GetBlockSamples,
    SendBlockSamples,
    GetBlockProof,
    SendBlockProof,
    GetTransactions,
    SendTransactions,
}

table GetLastState {}

table SendLastState {
    tip_header:                 VerifiableHeader,
    total_difficulty:           Uint256,
}

table GetBlockSamples {
    // SendLastState.tip_header.hash
    last_hash:                  Byte32,
    // Last proved tip hash
    start_hash:                 Byte32,
    // Last proved tip number
    start_number:               Uint64,
    difficulty_boundary:        Uint256,
    difficulties:               Uint256Vec,
}

table SendBlockSamples {
    root:                       HeaderDigest,
    proof:                      HeaderDigestVec,
    // The headers before `GetBlockSamples.start_number` (inclusive) for client side to detect the fork number
    reorg_last_n_headers:       HeaderWithChainRootVec,
    sampled_headers:            HeaderWithChainRootVec,
    last_n_headers:             HeaderWithChainRootVec,
}

table GetBlockProof {
    // The requested block hashes
    block_hashes:           Byte32Vec,
    // Light Client's local tip hash
    tip_hash:               Byte32,
}

table SendBlockProof {
    // The root of `GetBlockProof.tip_hash`
    root:                   HeaderDigest,
    // The proof of `GetBlockProof.block_hashs`. If `proof` is empty it means `tip_hash` is not in chain.
    proof:                  HeaderDigestVec,
    /// The tip header
    tip_header:             VerifiableHeader,
    // The headers of `GetBlockProof.block_hashes`. If a block hash not ancestor
    // of tip hash it will not included in headers.
    headers:                HeaderVec,
}

vector FilteredBlockVec <FilteredBlock>;

table GetTransactions {
    tx_hashes:        Byte32Vec,
    tip_hash:         Byte32,
}

table SendTransactions {
    // The transactions group by block
    filtered_blocks:  FilteredBlockVec,
    // The root of `GetTransactions.tip_hash`
    root:             HeaderDigest,
    // The block proof of filtered_blocks.headers
    block_proof:      HeaderDigestVec,
    /// The tip header
    tip_header:       VerifiableHeader,
}

/* Types for Network/Others */

table Time {
    timestamp:                  Uint64,
}

table RawAlert {
    notice_until:   Uint64,
    id:             Uint32,
    cancel:         Uint32,
    priority:       Uint32,
    message:        Bytes,
    min_version:    BytesOpt,
    max_version:    BytesOpt,
}

table Alert {
    raw:                        RawAlert,
    signatures:                 BytesVec,
}

table Identify {
    flag:                       Uint64,         // Flag
    name:                       Bytes,          // Network Name
    client_version:             Bytes,
}
