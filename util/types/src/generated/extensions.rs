// Generated by Molecule 0.7.3

use super::blockchain::*;
use molecule::prelude::*;
#[derive(Clone)]
pub struct BoolOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BoolOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BoolOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BoolOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for BoolOpt {
    fn default() -> Self {
        let v: Vec<u8> = vec![];
        BoolOpt::new_unchecked(v.into())
    }
}
impl BoolOpt {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Bool> {
        if self.is_none() {
            None
        } else {
            Some(Bool::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BoolOptReader<'r> {
        BoolOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BoolOpt {
    type Builder = BoolOptBuilder;
    const NAME: &'static str = "BoolOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BoolOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BoolOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BoolOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct BoolOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BoolOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BoolOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BoolOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> BoolOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<BoolReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(BoolReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BoolOptReader<'r> {
    type Entity = BoolOpt;
    const NAME: &'static str = "BoolOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BoolOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            BoolReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BoolOptBuilder(pub(crate) Option<Bool>);
impl BoolOptBuilder {
    pub fn set(mut self, v: Option<Bool>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for BoolOptBuilder {
    type Entity = BoolOpt;
    const NAME: &'static str = "BoolOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BoolOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte32Opt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte32Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte32Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte32Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for Byte32Opt {
    fn default() -> Self {
        let v: Vec<u8> = vec![];
        Byte32Opt::new_unchecked(v.into())
    }
}
impl Byte32Opt {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Byte32> {
        if self.is_none() {
            None
        } else {
            Some(Byte32::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> Byte32OptReader<'r> {
        Byte32OptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte32Opt {
    type Builder = Byte32OptBuilder;
    const NAME: &'static str = "Byte32Opt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte32Opt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte32OptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte32OptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct Byte32OptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte32OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte32OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte32OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> Byte32OptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Byte32Reader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(Byte32Reader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte32OptReader<'r> {
    type Entity = Byte32Opt;
    const NAME: &'static str = "Byte32OptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte32OptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            Byte32Reader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct Byte32OptBuilder(pub(crate) Option<Byte32>);
impl Byte32OptBuilder {
    pub fn set(mut self, v: Option<Byte32>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for Byte32OptBuilder {
    type Entity = Byte32Opt;
    const NAME: &'static str = "Byte32OptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte32Opt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Bool(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Bool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Bool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Bool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Bool {
    fn default() -> Self {
        let v: Vec<u8> = vec![0];
        Bool::new_unchecked(v.into())
    }
}
impl Bool {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> BoolReader<'r> {
        BoolReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Bool {
    type Builder = BoolBuilder;
    const NAME: &'static str = "Bool";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Bool(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BoolReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BoolReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct BoolReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> BoolReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for BoolReader<'r> {
    type Entity = Bool;
    const NAME: &'static str = "BoolReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BoolReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct BoolBuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for BoolBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for BoolBuilder {
    fn default() -> Self {
        BoolBuilder([Byte::default()])
    }
}
impl BoolBuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set(mut self, v: [Byte; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
}
impl molecule::prelude::Builder for BoolBuilder {
    type Entity = Bool;
    const NAME: &'static str = "BoolBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Bool::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BeUint32(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BeUint32 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BeUint32 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BeUint32 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for BeUint32 {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        BeUint32::new_unchecked(v.into())
    }
}
impl BeUint32 {
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> BeUint32Reader<'r> {
        BeUint32Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BeUint32 {
    type Builder = BeUint32Builder;
    const NAME: &'static str = "BeUint32";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BeUint32(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BeUint32Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BeUint32Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1(), self.nth2(), self.nth3()])
    }
}
#[derive(Clone, Copy)]
pub struct BeUint32Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BeUint32Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BeUint32Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BeUint32Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> BeUint32Reader<'r> {
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for BeUint32Reader<'r> {
    type Entity = BeUint32;
    const NAME: &'static str = "BeUint32Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BeUint32Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct BeUint32Builder(pub(crate) [Byte; 4]);
impl ::core::fmt::Debug for BeUint32Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for BeUint32Builder {
    fn default() -> Self {
        BeUint32Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl BeUint32Builder {
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn set(mut self, v: [Byte; 4]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
}
impl molecule::prelude::Builder for BeUint32Builder {
    type Entity = BeUint32;
    const NAME: &'static str = "BeUint32Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BeUint32::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BeUint64(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BeUint64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BeUint64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BeUint64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for BeUint64 {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];
        BeUint64::new_unchecked(v.into())
    }
}
impl BeUint64 {
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 8;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> BeUint64Reader<'r> {
        BeUint64Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BeUint64 {
    type Builder = BeUint64Builder;
    const NAME: &'static str = "BeUint64";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BeUint64(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BeUint64Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BeUint64Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct BeUint64Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BeUint64Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BeUint64Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BeUint64Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> BeUint64Reader<'r> {
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 8;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for BeUint64Reader<'r> {
    type Entity = BeUint64;
    const NAME: &'static str = "BeUint64Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BeUint64Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct BeUint64Builder(pub(crate) [Byte; 8]);
impl ::core::fmt::Debug for BeUint64Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for BeUint64Builder {
    fn default() -> Self {
        BeUint64Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl BeUint64Builder {
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 8;
    pub fn set(mut self, v: [Byte; 8]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
}
impl molecule::prelude::Builder for BeUint64Builder {
    type Entity = BeUint64;
    const NAME: &'static str = "BeUint64Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BeUint64::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Uint32Vec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Uint32Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Uint32Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Uint32Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for Uint32Vec {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        Uint32Vec::new_unchecked(v.into())
    }
}
impl Uint32Vec {
    pub const ITEM_SIZE: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Uint32> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Uint32 {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> Uint32VecReader<'r> {
        Uint32VecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Uint32Vec {
    type Builder = Uint32VecBuilder;
    const NAME: &'static str = "Uint32Vec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Uint32Vec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint32VecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint32VecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct Uint32VecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Uint32VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Uint32VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Uint32VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> Uint32VecReader<'r> {
    pub const ITEM_SIZE: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Uint32Reader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Uint32Reader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Uint32VecReader<'r> {
    type Entity = Uint32Vec;
    const NAME: &'static str = "Uint32VecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Uint32VecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct Uint32VecBuilder(pub(crate) Vec<Uint32>);
impl Uint32VecBuilder {
    pub const ITEM_SIZE: usize = 4;
    pub fn set(mut self, v: Vec<Uint32>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Uint32) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Uint32>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Uint32) -> Option<Uint32> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for Uint32VecBuilder {
    type Entity = Uint32Vec;
    const NAME: &'static str = "Uint32VecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Uint32Vec::new_unchecked(inner.into())
    }
}
pub struct Uint32VecIterator(Uint32Vec, usize, usize);
impl ::core::iter::Iterator for Uint32VecIterator {
    type Item = Uint32;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for Uint32VecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for Uint32Vec {
    type Item = Uint32;
    type IntoIter = Uint32VecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        Uint32VecIterator(self, 0, len)
    }
}
impl<'r> Uint32VecReader<'r> {
    pub fn iter<'t>(&'t self) -> Uint32VecReaderIterator<'t, 'r> {
        Uint32VecReaderIterator(&self, 0, self.len())
    }
}
pub struct Uint32VecReaderIterator<'t, 'r>(&'t Uint32VecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for Uint32VecReaderIterator<'t, 'r> {
    type Item = Uint32Reader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for Uint32VecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Uint64Vec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Uint64Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Uint64Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Uint64Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for Uint64Vec {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        Uint64Vec::new_unchecked(v.into())
    }
}
impl Uint64Vec {
    pub const ITEM_SIZE: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Uint64> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Uint64 {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> Uint64VecReader<'r> {
        Uint64VecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Uint64Vec {
    type Builder = Uint64VecBuilder;
    const NAME: &'static str = "Uint64Vec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Uint64Vec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint64VecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint64VecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct Uint64VecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Uint64VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Uint64VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Uint64VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> Uint64VecReader<'r> {
    pub const ITEM_SIZE: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Uint64Reader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Uint64Reader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Uint64VecReader<'r> {
    type Entity = Uint64Vec;
    const NAME: &'static str = "Uint64VecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Uint64VecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct Uint64VecBuilder(pub(crate) Vec<Uint64>);
impl Uint64VecBuilder {
    pub const ITEM_SIZE: usize = 8;
    pub fn set(mut self, v: Vec<Uint64>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Uint64) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Uint64>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Uint64) -> Option<Uint64> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for Uint64VecBuilder {
    type Entity = Uint64Vec;
    const NAME: &'static str = "Uint64VecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Uint64Vec::new_unchecked(inner.into())
    }
}
pub struct Uint64VecIterator(Uint64Vec, usize, usize);
impl ::core::iter::Iterator for Uint64VecIterator {
    type Item = Uint64;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for Uint64VecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for Uint64Vec {
    type Item = Uint64;
    type IntoIter = Uint64VecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        Uint64VecIterator(self, 0, len)
    }
}
impl<'r> Uint64VecReader<'r> {
    pub fn iter<'t>(&'t self) -> Uint64VecReaderIterator<'t, 'r> {
        Uint64VecReaderIterator(&self, 0, self.len())
    }
}
pub struct Uint64VecReaderIterator<'t, 'r>(&'t Uint64VecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for Uint64VecReaderIterator<'t, 'r> {
    type Item = Uint64Reader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for Uint64VecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct CellOutputOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CellOutputOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CellOutputOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CellOutputOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for CellOutputOpt {
    fn default() -> Self {
        let v: Vec<u8> = vec![];
        CellOutputOpt::new_unchecked(v.into())
    }
}
impl CellOutputOpt {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<CellOutput> {
        if self.is_none() {
            None
        } else {
            Some(CellOutput::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CellOutputOptReader<'r> {
        CellOutputOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CellOutputOpt {
    type Builder = CellOutputOptBuilder;
    const NAME: &'static str = "CellOutputOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CellOutputOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CellOutputOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CellOutputOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct CellOutputOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CellOutputOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CellOutputOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CellOutputOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> CellOutputOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<CellOutputReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(CellOutputReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CellOutputOptReader<'r> {
    type Entity = CellOutputOpt;
    const NAME: &'static str = "CellOutputOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CellOutputOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            CellOutputReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CellOutputOptBuilder(pub(crate) Option<CellOutput>);
impl CellOutputOptBuilder {
    pub fn set(mut self, v: Option<CellOutput>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for CellOutputOptBuilder {
    type Entity = CellOutputOpt;
    const NAME: &'static str = "CellOutputOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CellOutputOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct HeaderVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for HeaderVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for HeaderVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for HeaderVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for HeaderVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        HeaderVec::new_unchecked(v.into())
    }
}
impl HeaderVec {
    pub const ITEM_SIZE: usize = 208;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Header> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Header {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Header::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> HeaderVecReader<'r> {
        HeaderVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for HeaderVec {
    type Builder = HeaderVecBuilder;
    const NAME: &'static str = "HeaderVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        HeaderVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct HeaderVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for HeaderVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for HeaderVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for HeaderVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> HeaderVecReader<'r> {
    pub const ITEM_SIZE: usize = 208;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<HeaderReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> HeaderReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        HeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for HeaderVecReader<'r> {
    type Entity = HeaderVec;
    const NAME: &'static str = "HeaderVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        HeaderVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct HeaderVecBuilder(pub(crate) Vec<Header>);
impl HeaderVecBuilder {
    pub const ITEM_SIZE: usize = 208;
    pub fn set(mut self, v: Vec<Header>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Header) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Header>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Header) -> Option<Header> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for HeaderVecBuilder {
    type Entity = HeaderVec;
    const NAME: &'static str = "HeaderVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        HeaderVec::new_unchecked(inner.into())
    }
}
pub struct HeaderVecIterator(HeaderVec, usize, usize);
impl ::core::iter::Iterator for HeaderVecIterator {
    type Item = Header;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for HeaderVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for HeaderVec {
    type Item = Header;
    type IntoIter = HeaderVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        HeaderVecIterator(self, 0, len)
    }
}
impl<'r> HeaderVecReader<'r> {
    pub fn iter<'t>(&'t self) -> HeaderVecReaderIterator<'t, 'r> {
        HeaderVecReaderIterator(&self, 0, self.len())
    }
}
pub struct HeaderVecReaderIterator<'t, 'r>(&'t HeaderVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for HeaderVecReaderIterator<'t, 'r> {
    type Item = HeaderReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for HeaderVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct OutPointVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for OutPointVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for OutPointVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for OutPointVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for OutPointVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        OutPointVec::new_unchecked(v.into())
    }
}
impl OutPointVec {
    pub const ITEM_SIZE: usize = 36;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<OutPoint> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> OutPoint {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        OutPoint::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> OutPointVecReader<'r> {
        OutPointVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for OutPointVec {
    type Builder = OutPointVecBuilder;
    const NAME: &'static str = "OutPointVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        OutPointVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        OutPointVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        OutPointVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct OutPointVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for OutPointVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for OutPointVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for OutPointVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> OutPointVecReader<'r> {
    pub const ITEM_SIZE: usize = 36;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<OutPointReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> OutPointReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        OutPointReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for OutPointVecReader<'r> {
    type Entity = OutPointVec;
    const NAME: &'static str = "OutPointVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        OutPointVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct OutPointVecBuilder(pub(crate) Vec<OutPoint>);
impl OutPointVecBuilder {
    pub const ITEM_SIZE: usize = 36;
    pub fn set(mut self, v: Vec<OutPoint>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: OutPoint) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = OutPoint>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: OutPoint) -> Option<OutPoint> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for OutPointVecBuilder {
    type Entity = OutPointVec;
    const NAME: &'static str = "OutPointVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        OutPointVec::new_unchecked(inner.into())
    }
}
pub struct OutPointVecIterator(OutPointVec, usize, usize);
impl ::core::iter::Iterator for OutPointVecIterator {
    type Item = OutPoint;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for OutPointVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for OutPointVec {
    type Item = OutPoint;
    type IntoIter = OutPointVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        OutPointVecIterator(self, 0, len)
    }
}
impl<'r> OutPointVecReader<'r> {
    pub fn iter<'t>(&'t self) -> OutPointVecReaderIterator<'t, 'r> {
        OutPointVecReaderIterator(&self, 0, self.len())
    }
}
pub struct OutPointVecReaderIterator<'t, 'r>(&'t OutPointVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for OutPointVecReaderIterator<'t, 'r> {
    type Item = OutPointReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for OutPointVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct HeaderDigest(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for HeaderDigest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for HeaderDigest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for HeaderDigest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash", self.hash())?;
        write!(f, ", {}: {}", "blocks_count", self.blocks_count())?;
        write!(f, ", {}: {}", "total_difficulty", self.total_difficulty())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for HeaderDigest {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        HeaderDigest::new_unchecked(v.into())
    }
}
impl HeaderDigest {
    pub const TOTAL_SIZE: usize = 72;
    pub const FIELD_SIZES: [usize; 3] = [32, 8, 32];
    pub const FIELD_COUNT: usize = 3;
    pub fn hash(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(0..32))
    }
    pub fn blocks_count(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(32..40))
    }
    pub fn total_difficulty(&self) -> Uint256 {
        Uint256::new_unchecked(self.0.slice(40..72))
    }
    pub fn as_reader<'r>(&'r self) -> HeaderDigestReader<'r> {
        HeaderDigestReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for HeaderDigest {
    type Builder = HeaderDigestBuilder;
    const NAME: &'static str = "HeaderDigest";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        HeaderDigest(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderDigestReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderDigestReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .hash(self.hash())
            .blocks_count(self.blocks_count())
            .total_difficulty(self.total_difficulty())
    }
}
#[derive(Clone, Copy)]
pub struct HeaderDigestReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for HeaderDigestReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for HeaderDigestReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for HeaderDigestReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash", self.hash())?;
        write!(f, ", {}: {}", "blocks_count", self.blocks_count())?;
        write!(f, ", {}: {}", "total_difficulty", self.total_difficulty())?;
        write!(f, " }}")
    }
}
impl<'r> HeaderDigestReader<'r> {
    pub const TOTAL_SIZE: usize = 72;
    pub const FIELD_SIZES: [usize; 3] = [32, 8, 32];
    pub const FIELD_COUNT: usize = 3;
    pub fn hash(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[0..32])
    }
    pub fn blocks_count(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[32..40])
    }
    pub fn total_difficulty(&self) -> Uint256Reader<'r> {
        Uint256Reader::new_unchecked(&self.as_slice()[40..72])
    }
}
impl<'r> molecule::prelude::Reader<'r> for HeaderDigestReader<'r> {
    type Entity = HeaderDigest;
    const NAME: &'static str = "HeaderDigestReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        HeaderDigestReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct HeaderDigestBuilder {
    pub(crate) hash: Byte32,
    pub(crate) blocks_count: Uint64,
    pub(crate) total_difficulty: Uint256,
}
impl HeaderDigestBuilder {
    pub const TOTAL_SIZE: usize = 72;
    pub const FIELD_SIZES: [usize; 3] = [32, 8, 32];
    pub const FIELD_COUNT: usize = 3;
    pub fn hash(mut self, v: Byte32) -> Self {
        self.hash = v;
        self
    }
    pub fn blocks_count(mut self, v: Uint64) -> Self {
        self.blocks_count = v;
        self
    }
    pub fn total_difficulty(mut self, v: Uint256) -> Self {
        self.total_difficulty = v;
        self
    }
}
impl molecule::prelude::Builder for HeaderDigestBuilder {
    type Entity = HeaderDigest;
    const NAME: &'static str = "HeaderDigestBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.hash.as_slice())?;
        writer.write_all(self.blocks_count.as_slice())?;
        writer.write_all(self.total_difficulty.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        HeaderDigest::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct HeaderView(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for HeaderView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for HeaderView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for HeaderView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash", self.hash())?;
        write!(f, ", {}: {}", "data", self.data())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for HeaderView {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
        ];
        HeaderView::new_unchecked(v.into())
    }
}
impl HeaderView {
    pub const TOTAL_SIZE: usize = 240;
    pub const FIELD_SIZES: [usize; 2] = [32, 208];
    pub const FIELD_COUNT: usize = 2;
    pub fn hash(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(0..32))
    }
    pub fn data(&self) -> Header {
        Header::new_unchecked(self.0.slice(32..240))
    }
    pub fn as_reader<'r>(&'r self) -> HeaderViewReader<'r> {
        HeaderViewReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for HeaderView {
    type Builder = HeaderViewBuilder;
    const NAME: &'static str = "HeaderView";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        HeaderView(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderViewReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderViewReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().hash(self.hash()).data(self.data())
    }
}
#[derive(Clone, Copy)]
pub struct HeaderViewReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for HeaderViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for HeaderViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for HeaderViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash", self.hash())?;
        write!(f, ", {}: {}", "data", self.data())?;
        write!(f, " }}")
    }
}
impl<'r> HeaderViewReader<'r> {
    pub const TOTAL_SIZE: usize = 240;
    pub const FIELD_SIZES: [usize; 2] = [32, 208];
    pub const FIELD_COUNT: usize = 2;
    pub fn hash(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[0..32])
    }
    pub fn data(&self) -> HeaderReader<'r> {
        HeaderReader::new_unchecked(&self.as_slice()[32..240])
    }
}
impl<'r> molecule::prelude::Reader<'r> for HeaderViewReader<'r> {
    type Entity = HeaderView;
    const NAME: &'static str = "HeaderViewReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        HeaderViewReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct HeaderViewBuilder {
    pub(crate) hash: Byte32,
    pub(crate) data: Header,
}
impl HeaderViewBuilder {
    pub const TOTAL_SIZE: usize = 240;
    pub const FIELD_SIZES: [usize; 2] = [32, 208];
    pub const FIELD_COUNT: usize = 2;
    pub fn hash(mut self, v: Byte32) -> Self {
        self.hash = v;
        self
    }
    pub fn data(mut self, v: Header) -> Self {
        self.data = v;
        self
    }
}
impl molecule::prelude::Builder for HeaderViewBuilder {
    type Entity = HeaderView;
    const NAME: &'static str = "HeaderViewBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.hash.as_slice())?;
        writer.write_all(self.data.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        HeaderView::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct UncleBlockVecView(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for UncleBlockVecView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for UncleBlockVecView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for UncleBlockVecView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hashes", self.hashes())?;
        write!(f, ", {}: {}", "data", self.data())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for UncleBlockVecView {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
        ];
        UncleBlockVecView::new_unchecked(v.into())
    }
}
impl UncleBlockVecView {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn data(&self) -> UncleBlockVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            UncleBlockVec::new_unchecked(self.0.slice(start..end))
        } else {
            UncleBlockVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> UncleBlockVecViewReader<'r> {
        UncleBlockVecViewReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for UncleBlockVecView {
    type Builder = UncleBlockVecViewBuilder;
    const NAME: &'static str = "UncleBlockVecView";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        UncleBlockVecView(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UncleBlockVecViewReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UncleBlockVecViewReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().hashes(self.hashes()).data(self.data())
    }
}
#[derive(Clone, Copy)]
pub struct UncleBlockVecViewReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for UncleBlockVecViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for UncleBlockVecViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for UncleBlockVecViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hashes", self.hashes())?;
        write!(f, ", {}: {}", "data", self.data())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> UncleBlockVecViewReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn data(&self) -> UncleBlockVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            UncleBlockVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            UncleBlockVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for UncleBlockVecViewReader<'r> {
    type Entity = UncleBlockVecView;
    const NAME: &'static str = "UncleBlockVecViewReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        UncleBlockVecViewReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32VecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        UncleBlockVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct UncleBlockVecViewBuilder {
    pub(crate) hashes: Byte32Vec,
    pub(crate) data: UncleBlockVec,
}
impl UncleBlockVecViewBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn hashes(mut self, v: Byte32Vec) -> Self {
        self.hashes = v;
        self
    }
    pub fn data(mut self, v: UncleBlockVec) -> Self {
        self.data = v;
        self
    }
}
impl molecule::prelude::Builder for UncleBlockVecViewBuilder {
    type Entity = UncleBlockVecView;
    const NAME: &'static str = "UncleBlockVecViewBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.hashes.as_slice().len()
            + self.data.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.hashes.as_slice().len();
        offsets.push(total_size);
        total_size += self.data.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.hashes.as_slice())?;
        writer.write_all(self.data.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        UncleBlockVecView::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransactionView(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransactionView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransactionView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransactionView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash", self.hash())?;
        write!(f, ", {}: {}", "witness_hash", self.witness_hash())?;
        write!(f, ", {}: {}", "data", self.data())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransactionView {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            148, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 0, 0,
            12, 0, 0, 0, 64, 0, 0, 0, 52, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0,
            0, 44, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0,
            0, 4, 0, 0, 0, 4, 0, 0, 0,
        ];
        TransactionView::new_unchecked(v.into())
    }
}
impl TransactionView {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn witness_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn data(&self) -> Transaction {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Transaction::new_unchecked(self.0.slice(start..end))
        } else {
            Transaction::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TransactionViewReader<'r> {
        TransactionViewReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransactionView {
    type Builder = TransactionViewBuilder;
    const NAME: &'static str = "TransactionView";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransactionView(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionViewReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionViewReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .hash(self.hash())
            .witness_hash(self.witness_hash())
            .data(self.data())
    }
}
#[derive(Clone, Copy)]
pub struct TransactionViewReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransactionViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransactionViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransactionViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash", self.hash())?;
        write!(f, ", {}: {}", "witness_hash", self.witness_hash())?;
        write!(f, ", {}: {}", "data", self.data())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TransactionViewReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn witness_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn data(&self) -> TransactionReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            TransactionReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            TransactionReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransactionViewReader<'r> {
    type Entity = TransactionView;
    const NAME: &'static str = "TransactionViewReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransactionViewReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        TransactionReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TransactionViewBuilder {
    pub(crate) hash: Byte32,
    pub(crate) witness_hash: Byte32,
    pub(crate) data: Transaction,
}
impl TransactionViewBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn hash(mut self, v: Byte32) -> Self {
        self.hash = v;
        self
    }
    pub fn witness_hash(mut self, v: Byte32) -> Self {
        self.witness_hash = v;
        self
    }
    pub fn data(mut self, v: Transaction) -> Self {
        self.data = v;
        self
    }
}
impl molecule::prelude::Builder for TransactionViewBuilder {
    type Entity = TransactionView;
    const NAME: &'static str = "TransactionViewBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.hash.as_slice().len()
            + self.witness_hash.as_slice().len()
            + self.data.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.witness_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.data.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.hash.as_slice())?;
        writer.write_all(self.witness_hash.as_slice())?;
        writer.write_all(self.data.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransactionView::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlockExt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockExt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockExt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockExt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "total_difficulty", self.total_difficulty())?;
        write!(
            f,
            ", {}: {}",
            "total_uncles_count",
            self.total_uncles_count()
        )?;
        write!(f, ", {}: {}", "received_at", self.received_at())?;
        write!(f, ", {}: {}", "txs_fees", self.txs_fees())?;
        write!(f, ", {}: {}", "verified", self.verified())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BlockExt {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            76, 0, 0, 0, 24, 0, 0, 0, 56, 0, 0, 0, 64, 0, 0, 0, 72, 0, 0, 0, 76, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        BlockExt::new_unchecked(v.into())
    }
}
impl BlockExt {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn total_difficulty(&self) -> Uint256 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint256::new_unchecked(self.0.slice(start..end))
    }
    pub fn total_uncles_count(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn received_at(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn txs_fees(&self) -> Uint64Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn verified(&self) -> BoolOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            BoolOpt::new_unchecked(self.0.slice(start..end))
        } else {
            BoolOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockExtReader<'r> {
        BlockExtReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockExt {
    type Builder = BlockExtBuilder;
    const NAME: &'static str = "BlockExt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockExt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockExtReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockExtReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .total_difficulty(self.total_difficulty())
            .total_uncles_count(self.total_uncles_count())
            .received_at(self.received_at())
            .txs_fees(self.txs_fees())
            .verified(self.verified())
    }
}
#[derive(Clone, Copy)]
pub struct BlockExtReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockExtReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockExtReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockExtReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "total_difficulty", self.total_difficulty())?;
        write!(
            f,
            ", {}: {}",
            "total_uncles_count",
            self.total_uncles_count()
        )?;
        write!(f, ", {}: {}", "received_at", self.received_at())?;
        write!(f, ", {}: {}", "txs_fees", self.txs_fees())?;
        write!(f, ", {}: {}", "verified", self.verified())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BlockExtReader<'r> {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn total_difficulty(&self) -> Uint256Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint256Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn total_uncles_count(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn received_at(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn txs_fees(&self) -> Uint64VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn verified(&self) -> BoolOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            BoolOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BoolOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockExtReader<'r> {
    type Entity = BlockExt;
    const NAME: &'static str = "BlockExtReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockExtReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint256Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint64Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint64VecReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        BoolOptReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockExtBuilder {
    pub(crate) total_difficulty: Uint256,
    pub(crate) total_uncles_count: Uint64,
    pub(crate) received_at: Uint64,
    pub(crate) txs_fees: Uint64Vec,
    pub(crate) verified: BoolOpt,
}
impl BlockExtBuilder {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_difficulty(mut self, v: Uint256) -> Self {
        self.total_difficulty = v;
        self
    }
    pub fn total_uncles_count(mut self, v: Uint64) -> Self {
        self.total_uncles_count = v;
        self
    }
    pub fn received_at(mut self, v: Uint64) -> Self {
        self.received_at = v;
        self
    }
    pub fn txs_fees(mut self, v: Uint64Vec) -> Self {
        self.txs_fees = v;
        self
    }
    pub fn verified(mut self, v: BoolOpt) -> Self {
        self.verified = v;
        self
    }
}
impl molecule::prelude::Builder for BlockExtBuilder {
    type Entity = BlockExt;
    const NAME: &'static str = "BlockExtBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.total_difficulty.as_slice().len()
            + self.total_uncles_count.as_slice().len()
            + self.received_at.as_slice().len()
            + self.txs_fees.as_slice().len()
            + self.verified.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.total_difficulty.as_slice().len();
        offsets.push(total_size);
        total_size += self.total_uncles_count.as_slice().len();
        offsets.push(total_size);
        total_size += self.received_at.as_slice().len();
        offsets.push(total_size);
        total_size += self.txs_fees.as_slice().len();
        offsets.push(total_size);
        total_size += self.verified.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.total_difficulty.as_slice())?;
        writer.write_all(self.total_uncles_count.as_slice())?;
        writer.write_all(self.received_at.as_slice())?;
        writer.write_all(self.txs_fees.as_slice())?;
        writer.write_all(self.verified.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockExt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct EpochExt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for EpochExt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for EpochExt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for EpochExt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(
            f,
            "{}: {}",
            "previous_epoch_hash_rate",
            self.previous_epoch_hash_rate()
        )?;
        write!(
            f,
            ", {}: {}",
            "last_block_hash_in_previous_epoch",
            self.last_block_hash_in_previous_epoch()
        )?;
        write!(f, ", {}: {}", "compact_target", self.compact_target())?;
        write!(f, ", {}: {}", "number", self.number())?;
        write!(f, ", {}: {}", "base_block_reward", self.base_block_reward())?;
        write!(f, ", {}: {}", "remainder_reward", self.remainder_reward())?;
        write!(f, ", {}: {}", "start_number", self.start_number())?;
        write!(f, ", {}: {}", "length", self.length())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for EpochExt {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        EpochExt::new_unchecked(v.into())
    }
}
impl EpochExt {
    pub const TOTAL_SIZE: usize = 108;
    pub const FIELD_SIZES: [usize; 8] = [32, 32, 4, 8, 8, 8, 8, 8];
    pub const FIELD_COUNT: usize = 8;
    pub fn previous_epoch_hash_rate(&self) -> Uint256 {
        Uint256::new_unchecked(self.0.slice(0..32))
    }
    pub fn last_block_hash_in_previous_epoch(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(32..64))
    }
    pub fn compact_target(&self) -> Uint32 {
        Uint32::new_unchecked(self.0.slice(64..68))
    }
    pub fn number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(68..76))
    }
    pub fn base_block_reward(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(76..84))
    }
    pub fn remainder_reward(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(84..92))
    }
    pub fn start_number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(92..100))
    }
    pub fn length(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(100..108))
    }
    pub fn as_reader<'r>(&'r self) -> EpochExtReader<'r> {
        EpochExtReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for EpochExt {
    type Builder = EpochExtBuilder;
    const NAME: &'static str = "EpochExt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        EpochExt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        EpochExtReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        EpochExtReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .previous_epoch_hash_rate(self.previous_epoch_hash_rate())
            .last_block_hash_in_previous_epoch(self.last_block_hash_in_previous_epoch())
            .compact_target(self.compact_target())
            .number(self.number())
            .base_block_reward(self.base_block_reward())
            .remainder_reward(self.remainder_reward())
            .start_number(self.start_number())
            .length(self.length())
    }
}
#[derive(Clone, Copy)]
pub struct EpochExtReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for EpochExtReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for EpochExtReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for EpochExtReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(
            f,
            "{}: {}",
            "previous_epoch_hash_rate",
            self.previous_epoch_hash_rate()
        )?;
        write!(
            f,
            ", {}: {}",
            "last_block_hash_in_previous_epoch",
            self.last_block_hash_in_previous_epoch()
        )?;
        write!(f, ", {}: {}", "compact_target", self.compact_target())?;
        write!(f, ", {}: {}", "number", self.number())?;
        write!(f, ", {}: {}", "base_block_reward", self.base_block_reward())?;
        write!(f, ", {}: {}", "remainder_reward", self.remainder_reward())?;
        write!(f, ", {}: {}", "start_number", self.start_number())?;
        write!(f, ", {}: {}", "length", self.length())?;
        write!(f, " }}")
    }
}
impl<'r> EpochExtReader<'r> {
    pub const TOTAL_SIZE: usize = 108;
    pub const FIELD_SIZES: [usize; 8] = [32, 32, 4, 8, 8, 8, 8, 8];
    pub const FIELD_COUNT: usize = 8;
    pub fn previous_epoch_hash_rate(&self) -> Uint256Reader<'r> {
        Uint256Reader::new_unchecked(&self.as_slice()[0..32])
    }
    pub fn last_block_hash_in_previous_epoch(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[32..64])
    }
    pub fn compact_target(&self) -> Uint32Reader<'r> {
        Uint32Reader::new_unchecked(&self.as_slice()[64..68])
    }
    pub fn number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[68..76])
    }
    pub fn base_block_reward(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[76..84])
    }
    pub fn remainder_reward(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[84..92])
    }
    pub fn start_number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[92..100])
    }
    pub fn length(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[100..108])
    }
}
impl<'r> molecule::prelude::Reader<'r> for EpochExtReader<'r> {
    type Entity = EpochExt;
    const NAME: &'static str = "EpochExtReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        EpochExtReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct EpochExtBuilder {
    pub(crate) previous_epoch_hash_rate: Uint256,
    pub(crate) last_block_hash_in_previous_epoch: Byte32,
    pub(crate) compact_target: Uint32,
    pub(crate) number: Uint64,
    pub(crate) base_block_reward: Uint64,
    pub(crate) remainder_reward: Uint64,
    pub(crate) start_number: Uint64,
    pub(crate) length: Uint64,
}
impl EpochExtBuilder {
    pub const TOTAL_SIZE: usize = 108;
    pub const FIELD_SIZES: [usize; 8] = [32, 32, 4, 8, 8, 8, 8, 8];
    pub const FIELD_COUNT: usize = 8;
    pub fn previous_epoch_hash_rate(mut self, v: Uint256) -> Self {
        self.previous_epoch_hash_rate = v;
        self
    }
    pub fn last_block_hash_in_previous_epoch(mut self, v: Byte32) -> Self {
        self.last_block_hash_in_previous_epoch = v;
        self
    }
    pub fn compact_target(mut self, v: Uint32) -> Self {
        self.compact_target = v;
        self
    }
    pub fn number(mut self, v: Uint64) -> Self {
        self.number = v;
        self
    }
    pub fn base_block_reward(mut self, v: Uint64) -> Self {
        self.base_block_reward = v;
        self
    }
    pub fn remainder_reward(mut self, v: Uint64) -> Self {
        self.remainder_reward = v;
        self
    }
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
    pub fn length(mut self, v: Uint64) -> Self {
        self.length = v;
        self
    }
}
impl molecule::prelude::Builder for EpochExtBuilder {
    type Entity = EpochExt;
    const NAME: &'static str = "EpochExtBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.previous_epoch_hash_rate.as_slice())?;
        writer.write_all(self.last_block_hash_in_previous_epoch.as_slice())?;
        writer.write_all(self.compact_target.as_slice())?;
        writer.write_all(self.number.as_slice())?;
        writer.write_all(self.base_block_reward.as_slice())?;
        writer.write_all(self.remainder_reward.as_slice())?;
        writer.write_all(self.start_number.as_slice())?;
        writer.write_all(self.length.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        EpochExt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransactionKey(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransactionKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransactionKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransactionKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "index", self.index())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransactionKey {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0,
        ];
        TransactionKey::new_unchecked(v.into())
    }
}
impl TransactionKey {
    pub const TOTAL_SIZE: usize = 36;
    pub const FIELD_SIZES: [usize; 2] = [32, 4];
    pub const FIELD_COUNT: usize = 2;
    pub fn block_hash(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(0..32))
    }
    pub fn index(&self) -> BeUint32 {
        BeUint32::new_unchecked(self.0.slice(32..36))
    }
    pub fn as_reader<'r>(&'r self) -> TransactionKeyReader<'r> {
        TransactionKeyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransactionKey {
    type Builder = TransactionKeyBuilder;
    const NAME: &'static str = "TransactionKey";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransactionKey(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionKeyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionKeyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .block_hash(self.block_hash())
            .index(self.index())
    }
}
#[derive(Clone, Copy)]
pub struct TransactionKeyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransactionKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransactionKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransactionKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "index", self.index())?;
        write!(f, " }}")
    }
}
impl<'r> TransactionKeyReader<'r> {
    pub const TOTAL_SIZE: usize = 36;
    pub const FIELD_SIZES: [usize; 2] = [32, 4];
    pub const FIELD_COUNT: usize = 2;
    pub fn block_hash(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[0..32])
    }
    pub fn index(&self) -> BeUint32Reader<'r> {
        BeUint32Reader::new_unchecked(&self.as_slice()[32..36])
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransactionKeyReader<'r> {
    type Entity = TransactionKey;
    const NAME: &'static str = "TransactionKeyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransactionKeyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TransactionKeyBuilder {
    pub(crate) block_hash: Byte32,
    pub(crate) index: BeUint32,
}
impl TransactionKeyBuilder {
    pub const TOTAL_SIZE: usize = 36;
    pub const FIELD_SIZES: [usize; 2] = [32, 4];
    pub const FIELD_COUNT: usize = 2;
    pub fn block_hash(mut self, v: Byte32) -> Self {
        self.block_hash = v;
        self
    }
    pub fn index(mut self, v: BeUint32) -> Self {
        self.index = v;
        self
    }
}
impl molecule::prelude::Builder for TransactionKeyBuilder {
    type Entity = TransactionKey;
    const NAME: &'static str = "TransactionKeyBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.block_hash.as_slice())?;
        writer.write_all(self.index.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransactionKey::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct NumberHash(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for NumberHash {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for NumberHash {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for NumberHash {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "number", self.number())?;
        write!(f, ", {}: {}", "block_hash", self.block_hash())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for NumberHash {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        NumberHash::new_unchecked(v.into())
    }
}
impl NumberHash {
    pub const TOTAL_SIZE: usize = 40;
    pub const FIELD_SIZES: [usize; 2] = [8, 32];
    pub const FIELD_COUNT: usize = 2;
    pub fn number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(0..8))
    }
    pub fn block_hash(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(8..40))
    }
    pub fn as_reader<'r>(&'r self) -> NumberHashReader<'r> {
        NumberHashReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for NumberHash {
    type Builder = NumberHashBuilder;
    const NAME: &'static str = "NumberHash";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        NumberHash(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberHashReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberHashReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .number(self.number())
            .block_hash(self.block_hash())
    }
}
#[derive(Clone, Copy)]
pub struct NumberHashReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for NumberHashReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for NumberHashReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for NumberHashReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "number", self.number())?;
        write!(f, ", {}: {}", "block_hash", self.block_hash())?;
        write!(f, " }}")
    }
}
impl<'r> NumberHashReader<'r> {
    pub const TOTAL_SIZE: usize = 40;
    pub const FIELD_SIZES: [usize; 2] = [8, 32];
    pub const FIELD_COUNT: usize = 2;
    pub fn number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[0..8])
    }
    pub fn block_hash(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[8..40])
    }
}
impl<'r> molecule::prelude::Reader<'r> for NumberHashReader<'r> {
    type Entity = NumberHash;
    const NAME: &'static str = "NumberHashReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        NumberHashReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct NumberHashBuilder {
    pub(crate) number: Uint64,
    pub(crate) block_hash: Byte32,
}
impl NumberHashBuilder {
    pub const TOTAL_SIZE: usize = 40;
    pub const FIELD_SIZES: [usize; 2] = [8, 32];
    pub const FIELD_COUNT: usize = 2;
    pub fn number(mut self, v: Uint64) -> Self {
        self.number = v;
        self
    }
    pub fn block_hash(mut self, v: Byte32) -> Self {
        self.block_hash = v;
        self
    }
}
impl molecule::prelude::Builder for NumberHashBuilder {
    type Entity = NumberHash;
    const NAME: &'static str = "NumberHashBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.number.as_slice())?;
        writer.write_all(self.block_hash.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        NumberHash::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransactionInfo(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransactionInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransactionInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransactionInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_number", self.block_number())?;
        write!(f, ", {}: {}", "block_epoch", self.block_epoch())?;
        write!(f, ", {}: {}", "key", self.key())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransactionInfo {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        TransactionInfo::new_unchecked(v.into())
    }
}
impl TransactionInfo {
    pub const TOTAL_SIZE: usize = 52;
    pub const FIELD_SIZES: [usize; 3] = [8, 8, 36];
    pub const FIELD_COUNT: usize = 3;
    pub fn block_number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(0..8))
    }
    pub fn block_epoch(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(8..16))
    }
    pub fn key(&self) -> TransactionKey {
        TransactionKey::new_unchecked(self.0.slice(16..52))
    }
    pub fn as_reader<'r>(&'r self) -> TransactionInfoReader<'r> {
        TransactionInfoReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransactionInfo {
    type Builder = TransactionInfoBuilder;
    const NAME: &'static str = "TransactionInfo";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransactionInfo(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionInfoReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionInfoReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .block_number(self.block_number())
            .block_epoch(self.block_epoch())
            .key(self.key())
    }
}
#[derive(Clone, Copy)]
pub struct TransactionInfoReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransactionInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransactionInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransactionInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_number", self.block_number())?;
        write!(f, ", {}: {}", "block_epoch", self.block_epoch())?;
        write!(f, ", {}: {}", "key", self.key())?;
        write!(f, " }}")
    }
}
impl<'r> TransactionInfoReader<'r> {
    pub const TOTAL_SIZE: usize = 52;
    pub const FIELD_SIZES: [usize; 3] = [8, 8, 36];
    pub const FIELD_COUNT: usize = 3;
    pub fn block_number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[0..8])
    }
    pub fn block_epoch(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[8..16])
    }
    pub fn key(&self) -> TransactionKeyReader<'r> {
        TransactionKeyReader::new_unchecked(&self.as_slice()[16..52])
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransactionInfoReader<'r> {
    type Entity = TransactionInfo;
    const NAME: &'static str = "TransactionInfoReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransactionInfoReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TransactionInfoBuilder {
    pub(crate) block_number: Uint64,
    pub(crate) block_epoch: Uint64,
    pub(crate) key: TransactionKey,
}
impl TransactionInfoBuilder {
    pub const TOTAL_SIZE: usize = 52;
    pub const FIELD_SIZES: [usize; 3] = [8, 8, 36];
    pub const FIELD_COUNT: usize = 3;
    pub fn block_number(mut self, v: Uint64) -> Self {
        self.block_number = v;
        self
    }
    pub fn block_epoch(mut self, v: Uint64) -> Self {
        self.block_epoch = v;
        self
    }
    pub fn key(mut self, v: TransactionKey) -> Self {
        self.key = v;
        self
    }
}
impl molecule::prelude::Builder for TransactionInfoBuilder {
    type Entity = TransactionInfo;
    const NAME: &'static str = "TransactionInfoBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.block_number.as_slice())?;
        writer.write_all(self.block_epoch.as_slice())?;
        writer.write_all(self.key.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransactionInfo::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct CellEntry(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CellEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CellEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CellEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "output", self.output())?;
        write!(f, ", {}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "block_number", self.block_number())?;
        write!(f, ", {}: {}", "block_epoch", self.block_epoch())?;
        write!(f, ", {}: {}", "index", self.index())?;
        write!(f, ", {}: {}", "data_size", self.data_size())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for CellEntry {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            165, 0, 0, 0, 28, 0, 0, 0, 105, 0, 0, 0, 137, 0, 0, 0, 145, 0, 0, 0, 153, 0, 0, 0, 157,
            0, 0, 0, 77, 0, 0, 0, 16, 0, 0, 0, 24, 0, 0, 0, 77, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        CellEntry::new_unchecked(v.into())
    }
}
impl CellEntry {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn output(&self) -> CellOutput {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        CellOutput::new_unchecked(self.0.slice(start..end))
    }
    pub fn block_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn block_number(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn block_epoch(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn index(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn data_size(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Uint64::new_unchecked(self.0.slice(start..end))
        } else {
            Uint64::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CellEntryReader<'r> {
        CellEntryReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CellEntry {
    type Builder = CellEntryBuilder;
    const NAME: &'static str = "CellEntry";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CellEntry(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CellEntryReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CellEntryReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .output(self.output())
            .block_hash(self.block_hash())
            .block_number(self.block_number())
            .block_epoch(self.block_epoch())
            .index(self.index())
            .data_size(self.data_size())
    }
}
#[derive(Clone, Copy)]
pub struct CellEntryReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CellEntryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CellEntryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CellEntryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "output", self.output())?;
        write!(f, ", {}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "block_number", self.block_number())?;
        write!(f, ", {}: {}", "block_epoch", self.block_epoch())?;
        write!(f, ", {}: {}", "index", self.index())?;
        write!(f, ", {}: {}", "data_size", self.data_size())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> CellEntryReader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn output(&self) -> CellOutputReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        CellOutputReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn block_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn block_number(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn block_epoch(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn index(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn data_size(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Uint64Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint64Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CellEntryReader<'r> {
    type Entity = CellEntry;
    const NAME: &'static str = "CellEntryReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CellEntryReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        CellOutputReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint64Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint64Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Uint32Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Uint64Reader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CellEntryBuilder {
    pub(crate) output: CellOutput,
    pub(crate) block_hash: Byte32,
    pub(crate) block_number: Uint64,
    pub(crate) block_epoch: Uint64,
    pub(crate) index: Uint32,
    pub(crate) data_size: Uint64,
}
impl CellEntryBuilder {
    pub const FIELD_COUNT: usize = 6;
    pub fn output(mut self, v: CellOutput) -> Self {
        self.output = v;
        self
    }
    pub fn block_hash(mut self, v: Byte32) -> Self {
        self.block_hash = v;
        self
    }
    pub fn block_number(mut self, v: Uint64) -> Self {
        self.block_number = v;
        self
    }
    pub fn block_epoch(mut self, v: Uint64) -> Self {
        self.block_epoch = v;
        self
    }
    pub fn index(mut self, v: Uint32) -> Self {
        self.index = v;
        self
    }
    pub fn data_size(mut self, v: Uint64) -> Self {
        self.data_size = v;
        self
    }
}
impl molecule::prelude::Builder for CellEntryBuilder {
    type Entity = CellEntry;
    const NAME: &'static str = "CellEntryBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.output.as_slice().len()
            + self.block_hash.as_slice().len()
            + self.block_number.as_slice().len()
            + self.block_epoch.as_slice().len()
            + self.index.as_slice().len()
            + self.data_size.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.output.as_slice().len();
        offsets.push(total_size);
        total_size += self.block_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.block_number.as_slice().len();
        offsets.push(total_size);
        total_size += self.block_epoch.as_slice().len();
        offsets.push(total_size);
        total_size += self.index.as_slice().len();
        offsets.push(total_size);
        total_size += self.data_size.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.output.as_slice())?;
        writer.write_all(self.block_hash.as_slice())?;
        writer.write_all(self.block_number.as_slice())?;
        writer.write_all(self.block_epoch.as_slice())?;
        writer.write_all(self.index.as_slice())?;
        writer.write_all(self.data_size.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CellEntry::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct CellDataEntry(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CellDataEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CellDataEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CellDataEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "output_data", self.output_data())?;
        write!(f, ", {}: {}", "output_data_hash", self.output_data_hash())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for CellDataEntry {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            48, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        CellDataEntry::new_unchecked(v.into())
    }
}
impl CellDataEntry {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn output_data(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn output_data_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CellDataEntryReader<'r> {
        CellDataEntryReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CellDataEntry {
    type Builder = CellDataEntryBuilder;
    const NAME: &'static str = "CellDataEntry";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CellDataEntry(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CellDataEntryReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CellDataEntryReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .output_data(self.output_data())
            .output_data_hash(self.output_data_hash())
    }
}
#[derive(Clone, Copy)]
pub struct CellDataEntryReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CellDataEntryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CellDataEntryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CellDataEntryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "output_data", self.output_data())?;
        write!(f, ", {}: {}", "output_data_hash", self.output_data_hash())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> CellDataEntryReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn output_data(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn output_data_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CellDataEntryReader<'r> {
    type Entity = CellDataEntry;
    const NAME: &'static str = "CellDataEntryReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CellDataEntryReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CellDataEntryBuilder {
    pub(crate) output_data: Bytes,
    pub(crate) output_data_hash: Byte32,
}
impl CellDataEntryBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn output_data(mut self, v: Bytes) -> Self {
        self.output_data = v;
        self
    }
    pub fn output_data_hash(mut self, v: Byte32) -> Self {
        self.output_data_hash = v;
        self
    }
}
impl molecule::prelude::Builder for CellDataEntryBuilder {
    type Entity = CellDataEntry;
    const NAME: &'static str = "CellDataEntryBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.output_data.as_slice().len()
            + self.output_data_hash.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.output_data.as_slice().len();
        offsets.push(total_size);
        total_size += self.output_data_hash.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.output_data.as_slice())?;
        writer.write_all(self.output_data_hash.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CellDataEntry::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct RelayMessage(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RelayMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RelayMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RelayMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for RelayMessage {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 248, 0, 0, 0, 24, 0, 0, 0, 232, 0, 0, 0, 236, 0, 0, 0, 240, 0, 0, 0, 244,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        RelayMessage::new_unchecked(v.into())
    }
}
impl RelayMessage {
    pub const ITEMS_COUNT: usize = 8;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> RelayMessageUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => CompactBlock::new_unchecked(inner).into(),
            1 => RelayTransactions::new_unchecked(inner).into(),
            2 => RelayTransactionHashes::new_unchecked(inner).into(),
            3 => GetRelayTransactions::new_unchecked(inner).into(),
            4 => GetBlockTransactions::new_unchecked(inner).into(),
            5 => BlockTransactions::new_unchecked(inner).into(),
            6 => GetBlockProposal::new_unchecked(inner).into(),
            7 => BlockProposal::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> RelayMessageReader<'r> {
        RelayMessageReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RelayMessage {
    type Builder = RelayMessageBuilder;
    const NAME: &'static str = "RelayMessage";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RelayMessage(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayMessageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayMessageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct RelayMessageReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RelayMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RelayMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RelayMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> RelayMessageReader<'r> {
    pub const ITEMS_COUNT: usize = 8;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> RelayMessageUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => CompactBlockReader::new_unchecked(inner).into(),
            1 => RelayTransactionsReader::new_unchecked(inner).into(),
            2 => RelayTransactionHashesReader::new_unchecked(inner).into(),
            3 => GetRelayTransactionsReader::new_unchecked(inner).into(),
            4 => GetBlockTransactionsReader::new_unchecked(inner).into(),
            5 => BlockTransactionsReader::new_unchecked(inner).into(),
            6 => GetBlockProposalReader::new_unchecked(inner).into(),
            7 => BlockProposalReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for RelayMessageReader<'r> {
    type Entity = RelayMessage;
    const NAME: &'static str = "RelayMessageReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RelayMessageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => CompactBlockReader::verify(inner_slice, compatible),
            1 => RelayTransactionsReader::verify(inner_slice, compatible),
            2 => RelayTransactionHashesReader::verify(inner_slice, compatible),
            3 => GetRelayTransactionsReader::verify(inner_slice, compatible),
            4 => GetBlockTransactionsReader::verify(inner_slice, compatible),
            5 => BlockTransactionsReader::verify(inner_slice, compatible),
            6 => GetBlockProposalReader::verify(inner_slice, compatible),
            7 => BlockProposalReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct RelayMessageBuilder(pub(crate) RelayMessageUnion);
impl RelayMessageBuilder {
    pub const ITEMS_COUNT: usize = 8;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<RelayMessageUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for RelayMessageBuilder {
    type Entity = RelayMessage;
    const NAME: &'static str = "RelayMessageBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RelayMessage::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum RelayMessageUnion {
    CompactBlock(CompactBlock),
    RelayTransactions(RelayTransactions),
    RelayTransactionHashes(RelayTransactionHashes),
    GetRelayTransactions(GetRelayTransactions),
    GetBlockTransactions(GetBlockTransactions),
    BlockTransactions(BlockTransactions),
    GetBlockProposal(GetBlockProposal),
    BlockProposal(BlockProposal),
}
#[derive(Debug, Clone, Copy)]
pub enum RelayMessageUnionReader<'r> {
    CompactBlock(CompactBlockReader<'r>),
    RelayTransactions(RelayTransactionsReader<'r>),
    RelayTransactionHashes(RelayTransactionHashesReader<'r>),
    GetRelayTransactions(GetRelayTransactionsReader<'r>),
    GetBlockTransactions(GetBlockTransactionsReader<'r>),
    BlockTransactions(BlockTransactionsReader<'r>),
    GetBlockProposal(GetBlockProposalReader<'r>),
    BlockProposal(BlockProposalReader<'r>),
}
impl ::core::default::Default for RelayMessageUnion {
    fn default() -> Self {
        RelayMessageUnion::CompactBlock(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for RelayMessageUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            RelayMessageUnion::CompactBlock(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, CompactBlock::NAME, item)
            }
            RelayMessageUnion::RelayTransactions(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, RelayTransactions::NAME, item)
            }
            RelayMessageUnion::RelayTransactionHashes(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    RelayTransactionHashes::NAME,
                    item
                )
            }
            RelayMessageUnion::GetRelayTransactions(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetRelayTransactions::NAME,
                    item
                )
            }
            RelayMessageUnion::GetBlockTransactions(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetBlockTransactions::NAME,
                    item
                )
            }
            RelayMessageUnion::BlockTransactions(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockTransactions::NAME, item)
            }
            RelayMessageUnion::GetBlockProposal(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlockProposal::NAME, item)
            }
            RelayMessageUnion::BlockProposal(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockProposal::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for RelayMessageUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            RelayMessageUnionReader::CompactBlock(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, CompactBlock::NAME, item)
            }
            RelayMessageUnionReader::RelayTransactions(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, RelayTransactions::NAME, item)
            }
            RelayMessageUnionReader::RelayTransactionHashes(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    RelayTransactionHashes::NAME,
                    item
                )
            }
            RelayMessageUnionReader::GetRelayTransactions(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetRelayTransactions::NAME,
                    item
                )
            }
            RelayMessageUnionReader::GetBlockTransactions(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetBlockTransactions::NAME,
                    item
                )
            }
            RelayMessageUnionReader::BlockTransactions(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockTransactions::NAME, item)
            }
            RelayMessageUnionReader::GetBlockProposal(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlockProposal::NAME, item)
            }
            RelayMessageUnionReader::BlockProposal(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockProposal::NAME, item)
            }
        }
    }
}
impl RelayMessageUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            RelayMessageUnion::CompactBlock(ref item) => write!(f, "{}", item),
            RelayMessageUnion::RelayTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnion::RelayTransactionHashes(ref item) => write!(f, "{}", item),
            RelayMessageUnion::GetRelayTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnion::GetBlockTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnion::BlockTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnion::GetBlockProposal(ref item) => write!(f, "{}", item),
            RelayMessageUnion::BlockProposal(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> RelayMessageUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            RelayMessageUnionReader::CompactBlock(ref item) => write!(f, "{}", item),
            RelayMessageUnionReader::RelayTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnionReader::RelayTransactionHashes(ref item) => write!(f, "{}", item),
            RelayMessageUnionReader::GetRelayTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnionReader::GetBlockTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnionReader::BlockTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnionReader::GetBlockProposal(ref item) => write!(f, "{}", item),
            RelayMessageUnionReader::BlockProposal(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<CompactBlock> for RelayMessageUnion {
    fn from(item: CompactBlock) -> Self {
        RelayMessageUnion::CompactBlock(item)
    }
}
impl ::core::convert::From<RelayTransactions> for RelayMessageUnion {
    fn from(item: RelayTransactions) -> Self {
        RelayMessageUnion::RelayTransactions(item)
    }
}
impl ::core::convert::From<RelayTransactionHashes> for RelayMessageUnion {
    fn from(item: RelayTransactionHashes) -> Self {
        RelayMessageUnion::RelayTransactionHashes(item)
    }
}
impl ::core::convert::From<GetRelayTransactions> for RelayMessageUnion {
    fn from(item: GetRelayTransactions) -> Self {
        RelayMessageUnion::GetRelayTransactions(item)
    }
}
impl ::core::convert::From<GetBlockTransactions> for RelayMessageUnion {
    fn from(item: GetBlockTransactions) -> Self {
        RelayMessageUnion::GetBlockTransactions(item)
    }
}
impl ::core::convert::From<BlockTransactions> for RelayMessageUnion {
    fn from(item: BlockTransactions) -> Self {
        RelayMessageUnion::BlockTransactions(item)
    }
}
impl ::core::convert::From<GetBlockProposal> for RelayMessageUnion {
    fn from(item: GetBlockProposal) -> Self {
        RelayMessageUnion::GetBlockProposal(item)
    }
}
impl ::core::convert::From<BlockProposal> for RelayMessageUnion {
    fn from(item: BlockProposal) -> Self {
        RelayMessageUnion::BlockProposal(item)
    }
}
impl<'r> ::core::convert::From<CompactBlockReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: CompactBlockReader<'r>) -> Self {
        RelayMessageUnionReader::CompactBlock(item)
    }
}
impl<'r> ::core::convert::From<RelayTransactionsReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: RelayTransactionsReader<'r>) -> Self {
        RelayMessageUnionReader::RelayTransactions(item)
    }
}
impl<'r> ::core::convert::From<RelayTransactionHashesReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: RelayTransactionHashesReader<'r>) -> Self {
        RelayMessageUnionReader::RelayTransactionHashes(item)
    }
}
impl<'r> ::core::convert::From<GetRelayTransactionsReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: GetRelayTransactionsReader<'r>) -> Self {
        RelayMessageUnionReader::GetRelayTransactions(item)
    }
}
impl<'r> ::core::convert::From<GetBlockTransactionsReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: GetBlockTransactionsReader<'r>) -> Self {
        RelayMessageUnionReader::GetBlockTransactions(item)
    }
}
impl<'r> ::core::convert::From<BlockTransactionsReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: BlockTransactionsReader<'r>) -> Self {
        RelayMessageUnionReader::BlockTransactions(item)
    }
}
impl<'r> ::core::convert::From<GetBlockProposalReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: GetBlockProposalReader<'r>) -> Self {
        RelayMessageUnionReader::GetBlockProposal(item)
    }
}
impl<'r> ::core::convert::From<BlockProposalReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: BlockProposalReader<'r>) -> Self {
        RelayMessageUnionReader::BlockProposal(item)
    }
}
impl RelayMessageUnion {
    pub const NAME: &'static str = "RelayMessageUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            RelayMessageUnion::CompactBlock(item) => item.as_bytes(),
            RelayMessageUnion::RelayTransactions(item) => item.as_bytes(),
            RelayMessageUnion::RelayTransactionHashes(item) => item.as_bytes(),
            RelayMessageUnion::GetRelayTransactions(item) => item.as_bytes(),
            RelayMessageUnion::GetBlockTransactions(item) => item.as_bytes(),
            RelayMessageUnion::BlockTransactions(item) => item.as_bytes(),
            RelayMessageUnion::GetBlockProposal(item) => item.as_bytes(),
            RelayMessageUnion::BlockProposal(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            RelayMessageUnion::CompactBlock(item) => item.as_slice(),
            RelayMessageUnion::RelayTransactions(item) => item.as_slice(),
            RelayMessageUnion::RelayTransactionHashes(item) => item.as_slice(),
            RelayMessageUnion::GetRelayTransactions(item) => item.as_slice(),
            RelayMessageUnion::GetBlockTransactions(item) => item.as_slice(),
            RelayMessageUnion::BlockTransactions(item) => item.as_slice(),
            RelayMessageUnion::GetBlockProposal(item) => item.as_slice(),
            RelayMessageUnion::BlockProposal(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            RelayMessageUnion::CompactBlock(_) => 0,
            RelayMessageUnion::RelayTransactions(_) => 1,
            RelayMessageUnion::RelayTransactionHashes(_) => 2,
            RelayMessageUnion::GetRelayTransactions(_) => 3,
            RelayMessageUnion::GetBlockTransactions(_) => 4,
            RelayMessageUnion::BlockTransactions(_) => 5,
            RelayMessageUnion::GetBlockProposal(_) => 6,
            RelayMessageUnion::BlockProposal(_) => 7,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            RelayMessageUnion::CompactBlock(_) => "CompactBlock",
            RelayMessageUnion::RelayTransactions(_) => "RelayTransactions",
            RelayMessageUnion::RelayTransactionHashes(_) => "RelayTransactionHashes",
            RelayMessageUnion::GetRelayTransactions(_) => "GetRelayTransactions",
            RelayMessageUnion::GetBlockTransactions(_) => "GetBlockTransactions",
            RelayMessageUnion::BlockTransactions(_) => "BlockTransactions",
            RelayMessageUnion::GetBlockProposal(_) => "GetBlockProposal",
            RelayMessageUnion::BlockProposal(_) => "BlockProposal",
        }
    }
    pub fn as_reader<'r>(&'r self) -> RelayMessageUnionReader<'r> {
        match self {
            RelayMessageUnion::CompactBlock(item) => item.as_reader().into(),
            RelayMessageUnion::RelayTransactions(item) => item.as_reader().into(),
            RelayMessageUnion::RelayTransactionHashes(item) => item.as_reader().into(),
            RelayMessageUnion::GetRelayTransactions(item) => item.as_reader().into(),
            RelayMessageUnion::GetBlockTransactions(item) => item.as_reader().into(),
            RelayMessageUnion::BlockTransactions(item) => item.as_reader().into(),
            RelayMessageUnion::GetBlockProposal(item) => item.as_reader().into(),
            RelayMessageUnion::BlockProposal(item) => item.as_reader().into(),
        }
    }
}
impl<'r> RelayMessageUnionReader<'r> {
    pub const NAME: &'r str = "RelayMessageUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            RelayMessageUnionReader::CompactBlock(item) => item.as_slice(),
            RelayMessageUnionReader::RelayTransactions(item) => item.as_slice(),
            RelayMessageUnionReader::RelayTransactionHashes(item) => item.as_slice(),
            RelayMessageUnionReader::GetRelayTransactions(item) => item.as_slice(),
            RelayMessageUnionReader::GetBlockTransactions(item) => item.as_slice(),
            RelayMessageUnionReader::BlockTransactions(item) => item.as_slice(),
            RelayMessageUnionReader::GetBlockProposal(item) => item.as_slice(),
            RelayMessageUnionReader::BlockProposal(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            RelayMessageUnionReader::CompactBlock(_) => 0,
            RelayMessageUnionReader::RelayTransactions(_) => 1,
            RelayMessageUnionReader::RelayTransactionHashes(_) => 2,
            RelayMessageUnionReader::GetRelayTransactions(_) => 3,
            RelayMessageUnionReader::GetBlockTransactions(_) => 4,
            RelayMessageUnionReader::BlockTransactions(_) => 5,
            RelayMessageUnionReader::GetBlockProposal(_) => 6,
            RelayMessageUnionReader::BlockProposal(_) => 7,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            RelayMessageUnionReader::CompactBlock(_) => "CompactBlock",
            RelayMessageUnionReader::RelayTransactions(_) => "RelayTransactions",
            RelayMessageUnionReader::RelayTransactionHashes(_) => "RelayTransactionHashes",
            RelayMessageUnionReader::GetRelayTransactions(_) => "GetRelayTransactions",
            RelayMessageUnionReader::GetBlockTransactions(_) => "GetBlockTransactions",
            RelayMessageUnionReader::BlockTransactions(_) => "BlockTransactions",
            RelayMessageUnionReader::GetBlockProposal(_) => "GetBlockProposal",
            RelayMessageUnionReader::BlockProposal(_) => "BlockProposal",
        }
    }
}
#[derive(Clone)]
pub struct CompactBlock(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CompactBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CompactBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CompactBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "short_ids", self.short_ids())?;
        write!(
            f,
            ", {}: {}",
            "prefilled_transactions",
            self.prefilled_transactions()
        )?;
        write!(f, ", {}: {}", "uncles", self.uncles())?;
        write!(f, ", {}: {}", "proposals", self.proposals())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for CompactBlock {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            248, 0, 0, 0, 24, 0, 0, 0, 232, 0, 0, 0, 236, 0, 0, 0, 240, 0, 0, 0, 244, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        CompactBlock::new_unchecked(v.into())
    }
}
impl CompactBlock {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> Header {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Header::new_unchecked(self.0.slice(start..end))
    }
    pub fn short_ids(&self) -> ProposalShortIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ProposalShortIdVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn prefilled_transactions(&self) -> IndexTransactionVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        IndexTransactionVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn uncles(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposals(&self) -> ProposalShortIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            ProposalShortIdVec::new_unchecked(self.0.slice(start..end))
        } else {
            ProposalShortIdVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CompactBlockReader<'r> {
        CompactBlockReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CompactBlock {
    type Builder = CompactBlockBuilder;
    const NAME: &'static str = "CompactBlock";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CompactBlock(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CompactBlockReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CompactBlockReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .header(self.header())
            .short_ids(self.short_ids())
            .prefilled_transactions(self.prefilled_transactions())
            .uncles(self.uncles())
            .proposals(self.proposals())
    }
}
#[derive(Clone, Copy)]
pub struct CompactBlockReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CompactBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CompactBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CompactBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "short_ids", self.short_ids())?;
        write!(
            f,
            ", {}: {}",
            "prefilled_transactions",
            self.prefilled_transactions()
        )?;
        write!(f, ", {}: {}", "uncles", self.uncles())?;
        write!(f, ", {}: {}", "proposals", self.proposals())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> CompactBlockReader<'r> {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> HeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn short_ids(&self) -> ProposalShortIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ProposalShortIdVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn prefilled_transactions(&self) -> IndexTransactionVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        IndexTransactionVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn uncles(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposals(&self) -> ProposalShortIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            ProposalShortIdVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ProposalShortIdVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CompactBlockReader<'r> {
    type Entity = CompactBlock;
    const NAME: &'static str = "CompactBlockReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CompactBlockReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ProposalShortIdVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        IndexTransactionVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        ProposalShortIdVecReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CompactBlockBuilder {
    pub(crate) header: Header,
    pub(crate) short_ids: ProposalShortIdVec,
    pub(crate) prefilled_transactions: IndexTransactionVec,
    pub(crate) uncles: Byte32Vec,
    pub(crate) proposals: ProposalShortIdVec,
}
impl CompactBlockBuilder {
    pub const FIELD_COUNT: usize = 5;
    pub fn header(mut self, v: Header) -> Self {
        self.header = v;
        self
    }
    pub fn short_ids(mut self, v: ProposalShortIdVec) -> Self {
        self.short_ids = v;
        self
    }
    pub fn prefilled_transactions(mut self, v: IndexTransactionVec) -> Self {
        self.prefilled_transactions = v;
        self
    }
    pub fn uncles(mut self, v: Byte32Vec) -> Self {
        self.uncles = v;
        self
    }
    pub fn proposals(mut self, v: ProposalShortIdVec) -> Self {
        self.proposals = v;
        self
    }
}
impl molecule::prelude::Builder for CompactBlockBuilder {
    type Entity = CompactBlock;
    const NAME: &'static str = "CompactBlockBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.header.as_slice().len()
            + self.short_ids.as_slice().len()
            + self.prefilled_transactions.as_slice().len()
            + self.uncles.as_slice().len()
            + self.proposals.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.header.as_slice().len();
        offsets.push(total_size);
        total_size += self.short_ids.as_slice().len();
        offsets.push(total_size);
        total_size += self.prefilled_transactions.as_slice().len();
        offsets.push(total_size);
        total_size += self.uncles.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposals.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.header.as_slice())?;
        writer.write_all(self.short_ids.as_slice())?;
        writer.write_all(self.prefilled_transactions.as_slice())?;
        writer.write_all(self.uncles.as_slice())?;
        writer.write_all(self.proposals.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CompactBlock::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct CompactBlockV1(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CompactBlockV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CompactBlockV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CompactBlockV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "short_ids", self.short_ids())?;
        write!(
            f,
            ", {}: {}",
            "prefilled_transactions",
            self.prefilled_transactions()
        )?;
        write!(f, ", {}: {}", "uncles", self.uncles())?;
        write!(f, ", {}: {}", "proposals", self.proposals())?;
        write!(f, ", {}: {}", "extension", self.extension())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for CompactBlockV1 {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 1, 0, 0, 28, 0, 0, 0, 236, 0, 0, 0, 240, 0, 0, 0, 244, 0, 0, 0, 248, 0, 0, 0, 252,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        CompactBlockV1::new_unchecked(v.into())
    }
}
impl CompactBlockV1 {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> Header {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Header::new_unchecked(self.0.slice(start..end))
    }
    pub fn short_ids(&self) -> ProposalShortIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ProposalShortIdVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn prefilled_transactions(&self) -> IndexTransactionVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        IndexTransactionVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn uncles(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposals(&self) -> ProposalShortIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        ProposalShortIdVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn extension(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CompactBlockV1Reader<'r> {
        CompactBlockV1Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CompactBlockV1 {
    type Builder = CompactBlockV1Builder;
    const NAME: &'static str = "CompactBlockV1";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CompactBlockV1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CompactBlockV1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CompactBlockV1Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .header(self.header())
            .short_ids(self.short_ids())
            .prefilled_transactions(self.prefilled_transactions())
            .uncles(self.uncles())
            .proposals(self.proposals())
            .extension(self.extension())
    }
}
#[derive(Clone, Copy)]
pub struct CompactBlockV1Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CompactBlockV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CompactBlockV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CompactBlockV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "short_ids", self.short_ids())?;
        write!(
            f,
            ", {}: {}",
            "prefilled_transactions",
            self.prefilled_transactions()
        )?;
        write!(f, ", {}: {}", "uncles", self.uncles())?;
        write!(f, ", {}: {}", "proposals", self.proposals())?;
        write!(f, ", {}: {}", "extension", self.extension())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> CompactBlockV1Reader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> HeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn short_ids(&self) -> ProposalShortIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ProposalShortIdVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn prefilled_transactions(&self) -> IndexTransactionVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        IndexTransactionVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn uncles(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposals(&self) -> ProposalShortIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        ProposalShortIdVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn extension(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CompactBlockV1Reader<'r> {
    type Entity = CompactBlockV1;
    const NAME: &'static str = "CompactBlockV1Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CompactBlockV1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ProposalShortIdVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        IndexTransactionVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        ProposalShortIdVecReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        BytesReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CompactBlockV1Builder {
    pub(crate) header: Header,
    pub(crate) short_ids: ProposalShortIdVec,
    pub(crate) prefilled_transactions: IndexTransactionVec,
    pub(crate) uncles: Byte32Vec,
    pub(crate) proposals: ProposalShortIdVec,
    pub(crate) extension: Bytes,
}
impl CompactBlockV1Builder {
    pub const FIELD_COUNT: usize = 6;
    pub fn header(mut self, v: Header) -> Self {
        self.header = v;
        self
    }
    pub fn short_ids(mut self, v: ProposalShortIdVec) -> Self {
        self.short_ids = v;
        self
    }
    pub fn prefilled_transactions(mut self, v: IndexTransactionVec) -> Self {
        self.prefilled_transactions = v;
        self
    }
    pub fn uncles(mut self, v: Byte32Vec) -> Self {
        self.uncles = v;
        self
    }
    pub fn proposals(mut self, v: ProposalShortIdVec) -> Self {
        self.proposals = v;
        self
    }
    pub fn extension(mut self, v: Bytes) -> Self {
        self.extension = v;
        self
    }
}
impl molecule::prelude::Builder for CompactBlockV1Builder {
    type Entity = CompactBlockV1;
    const NAME: &'static str = "CompactBlockV1Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.header.as_slice().len()
            + self.short_ids.as_slice().len()
            + self.prefilled_transactions.as_slice().len()
            + self.uncles.as_slice().len()
            + self.proposals.as_slice().len()
            + self.extension.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.header.as_slice().len();
        offsets.push(total_size);
        total_size += self.short_ids.as_slice().len();
        offsets.push(total_size);
        total_size += self.prefilled_transactions.as_slice().len();
        offsets.push(total_size);
        total_size += self.uncles.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposals.as_slice().len();
        offsets.push(total_size);
        total_size += self.extension.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.header.as_slice())?;
        writer.write_all(self.short_ids.as_slice())?;
        writer.write_all(self.prefilled_transactions.as_slice())?;
        writer.write_all(self.uncles.as_slice())?;
        writer.write_all(self.proposals.as_slice())?;
        writer.write_all(self.extension.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CompactBlockV1::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct RelayTransaction(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RelayTransaction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RelayTransaction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RelayTransaction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cycles", self.cycles())?;
        write!(f, ", {}: {}", "transaction", self.transaction())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for RelayTransaction {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            88, 0, 0, 0, 12, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 0, 0, 12, 0, 0,
            0, 64, 0, 0, 0, 52, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0,
            0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0,
            0, 4, 0, 0, 0,
        ];
        RelayTransaction::new_unchecked(v.into())
    }
}
impl RelayTransaction {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cycles(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn transaction(&self) -> Transaction {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Transaction::new_unchecked(self.0.slice(start..end))
        } else {
            Transaction::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> RelayTransactionReader<'r> {
        RelayTransactionReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RelayTransaction {
    type Builder = RelayTransactionBuilder;
    const NAME: &'static str = "RelayTransaction";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RelayTransaction(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cycles(self.cycles())
            .transaction(self.transaction())
    }
}
#[derive(Clone, Copy)]
pub struct RelayTransactionReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RelayTransactionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RelayTransactionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RelayTransactionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cycles", self.cycles())?;
        write!(f, ", {}: {}", "transaction", self.transaction())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> RelayTransactionReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cycles(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn transaction(&self) -> TransactionReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            TransactionReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            TransactionReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for RelayTransactionReader<'r> {
    type Entity = RelayTransaction;
    const NAME: &'static str = "RelayTransactionReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RelayTransactionReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TransactionReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct RelayTransactionBuilder {
    pub(crate) cycles: Uint64,
    pub(crate) transaction: Transaction,
}
impl RelayTransactionBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn cycles(mut self, v: Uint64) -> Self {
        self.cycles = v;
        self
    }
    pub fn transaction(mut self, v: Transaction) -> Self {
        self.transaction = v;
        self
    }
}
impl molecule::prelude::Builder for RelayTransactionBuilder {
    type Entity = RelayTransaction;
    const NAME: &'static str = "RelayTransactionBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cycles.as_slice().len()
            + self.transaction.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cycles.as_slice().len();
        offsets.push(total_size);
        total_size += self.transaction.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cycles.as_slice())?;
        writer.write_all(self.transaction.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RelayTransaction::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct RelayTransactionVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RelayTransactionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RelayTransactionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RelayTransactionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for RelayTransactionVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        RelayTransactionVec::new_unchecked(v.into())
    }
}
impl RelayTransactionVec {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<RelayTransaction> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> RelayTransaction {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            RelayTransaction::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            RelayTransaction::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> RelayTransactionVecReader<'r> {
        RelayTransactionVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RelayTransactionVec {
    type Builder = RelayTransactionVecBuilder;
    const NAME: &'static str = "RelayTransactionVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RelayTransactionVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct RelayTransactionVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RelayTransactionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RelayTransactionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RelayTransactionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> RelayTransactionVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<RelayTransactionReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> RelayTransactionReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            RelayTransactionReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            RelayTransactionReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for RelayTransactionVecReader<'r> {
    type Entity = RelayTransactionVec;
    const NAME: &'static str = "RelayTransactionVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RelayTransactionVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            RelayTransactionReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct RelayTransactionVecBuilder(pub(crate) Vec<RelayTransaction>);
impl RelayTransactionVecBuilder {
    pub fn set(mut self, v: Vec<RelayTransaction>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: RelayTransaction) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = RelayTransaction>>(
        mut self,
        iter: T,
    ) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: RelayTransaction) -> Option<RelayTransaction> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for RelayTransactionVecBuilder {
    type Entity = RelayTransactionVec;
    const NAME: &'static str = "RelayTransactionVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RelayTransactionVec::new_unchecked(inner.into())
    }
}
pub struct RelayTransactionVecIterator(RelayTransactionVec, usize, usize);
impl ::core::iter::Iterator for RelayTransactionVecIterator {
    type Item = RelayTransaction;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for RelayTransactionVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for RelayTransactionVec {
    type Item = RelayTransaction;
    type IntoIter = RelayTransactionVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        RelayTransactionVecIterator(self, 0, len)
    }
}
impl<'r> RelayTransactionVecReader<'r> {
    pub fn iter<'t>(&'t self) -> RelayTransactionVecReaderIterator<'t, 'r> {
        RelayTransactionVecReaderIterator(&self, 0, self.len())
    }
}
pub struct RelayTransactionVecReaderIterator<'t, 'r>(
    &'t RelayTransactionVecReader<'r>,
    usize,
    usize,
);
impl<'t: 'r, 'r> ::core::iter::Iterator for RelayTransactionVecReaderIterator<'t, 'r> {
    type Item = RelayTransactionReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for RelayTransactionVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct RelayTransactions(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RelayTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RelayTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RelayTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "transactions", self.transactions())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for RelayTransactions {
    fn default() -> Self {
        let v: Vec<u8> = vec![12, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0];
        RelayTransactions::new_unchecked(v.into())
    }
}
impl RelayTransactions {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn transactions(&self) -> RelayTransactionVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            RelayTransactionVec::new_unchecked(self.0.slice(start..end))
        } else {
            RelayTransactionVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> RelayTransactionsReader<'r> {
        RelayTransactionsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RelayTransactions {
    type Builder = RelayTransactionsBuilder;
    const NAME: &'static str = "RelayTransactions";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RelayTransactions(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().transactions(self.transactions())
    }
}
#[derive(Clone, Copy)]
pub struct RelayTransactionsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RelayTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RelayTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RelayTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "transactions", self.transactions())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> RelayTransactionsReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn transactions(&self) -> RelayTransactionVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            RelayTransactionVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            RelayTransactionVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for RelayTransactionsReader<'r> {
    type Entity = RelayTransactions;
    const NAME: &'static str = "RelayTransactionsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RelayTransactionsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        RelayTransactionVecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct RelayTransactionsBuilder {
    pub(crate) transactions: RelayTransactionVec,
}
impl RelayTransactionsBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn transactions(mut self, v: RelayTransactionVec) -> Self {
        self.transactions = v;
        self
    }
}
impl molecule::prelude::Builder for RelayTransactionsBuilder {
    type Entity = RelayTransactions;
    const NAME: &'static str = "RelayTransactionsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.transactions.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.transactions.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.transactions.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RelayTransactions::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct RelayTransactionHashes(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RelayTransactionHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RelayTransactionHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RelayTransactionHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "tx_hashes", self.tx_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for RelayTransactionHashes {
    fn default() -> Self {
        let v: Vec<u8> = vec![12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
        RelayTransactionHashes::new_unchecked(v.into())
    }
}
impl RelayTransactionHashes {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn tx_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> RelayTransactionHashesReader<'r> {
        RelayTransactionHashesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RelayTransactionHashes {
    type Builder = RelayTransactionHashesBuilder;
    const NAME: &'static str = "RelayTransactionHashes";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RelayTransactionHashes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionHashesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionHashesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().tx_hashes(self.tx_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct RelayTransactionHashesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RelayTransactionHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RelayTransactionHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RelayTransactionHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "tx_hashes", self.tx_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> RelayTransactionHashesReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn tx_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for RelayTransactionHashesReader<'r> {
    type Entity = RelayTransactionHashes;
    const NAME: &'static str = "RelayTransactionHashesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RelayTransactionHashesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32VecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct RelayTransactionHashesBuilder {
    pub(crate) tx_hashes: Byte32Vec,
}
impl RelayTransactionHashesBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn tx_hashes(mut self, v: Byte32Vec) -> Self {
        self.tx_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for RelayTransactionHashesBuilder {
    type Entity = RelayTransactionHashes;
    const NAME: &'static str = "RelayTransactionHashesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.tx_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.tx_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.tx_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RelayTransactionHashes::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetRelayTransactions(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetRelayTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetRelayTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetRelayTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "tx_hashes", self.tx_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetRelayTransactions {
    fn default() -> Self {
        let v: Vec<u8> = vec![12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
        GetRelayTransactions::new_unchecked(v.into())
    }
}
impl GetRelayTransactions {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn tx_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetRelayTransactionsReader<'r> {
        GetRelayTransactionsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetRelayTransactions {
    type Builder = GetRelayTransactionsBuilder;
    const NAME: &'static str = "GetRelayTransactions";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetRelayTransactions(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetRelayTransactionsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetRelayTransactionsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().tx_hashes(self.tx_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct GetRelayTransactionsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetRelayTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetRelayTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetRelayTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "tx_hashes", self.tx_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetRelayTransactionsReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn tx_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetRelayTransactionsReader<'r> {
    type Entity = GetRelayTransactions;
    const NAME: &'static str = "GetRelayTransactionsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetRelayTransactionsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32VecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetRelayTransactionsBuilder {
    pub(crate) tx_hashes: Byte32Vec,
}
impl GetRelayTransactionsBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn tx_hashes(mut self, v: Byte32Vec) -> Self {
        self.tx_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for GetRelayTransactionsBuilder {
    type Entity = GetRelayTransactions;
    const NAME: &'static str = "GetRelayTransactionsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.tx_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.tx_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.tx_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetRelayTransactions::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetBlockTransactions(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetBlockTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetBlockTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetBlockTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "indexes", self.indexes())?;
        write!(f, ", {}: {}", "uncle_indexes", self.uncle_indexes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetBlockTransactions {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            56, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        GetBlockTransactions::new_unchecked(v.into())
    }
}
impl GetBlockTransactions {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn indexes(&self) -> Uint32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn uncle_indexes(&self) -> Uint32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Uint32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Uint32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetBlockTransactionsReader<'r> {
        GetBlockTransactionsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetBlockTransactions {
    type Builder = GetBlockTransactionsBuilder;
    const NAME: &'static str = "GetBlockTransactions";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetBlockTransactions(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockTransactionsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockTransactionsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .block_hash(self.block_hash())
            .indexes(self.indexes())
            .uncle_indexes(self.uncle_indexes())
    }
}
#[derive(Clone, Copy)]
pub struct GetBlockTransactionsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetBlockTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetBlockTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetBlockTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "indexes", self.indexes())?;
        write!(f, ", {}: {}", "uncle_indexes", self.uncle_indexes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetBlockTransactionsReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn indexes(&self) -> Uint32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn uncle_indexes(&self) -> Uint32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Uint32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetBlockTransactionsReader<'r> {
    type Entity = GetBlockTransactions;
    const NAME: &'static str = "GetBlockTransactionsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetBlockTransactionsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint32VecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint32VecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetBlockTransactionsBuilder {
    pub(crate) block_hash: Byte32,
    pub(crate) indexes: Uint32Vec,
    pub(crate) uncle_indexes: Uint32Vec,
}
impl GetBlockTransactionsBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn block_hash(mut self, v: Byte32) -> Self {
        self.block_hash = v;
        self
    }
    pub fn indexes(mut self, v: Uint32Vec) -> Self {
        self.indexes = v;
        self
    }
    pub fn uncle_indexes(mut self, v: Uint32Vec) -> Self {
        self.uncle_indexes = v;
        self
    }
}
impl molecule::prelude::Builder for GetBlockTransactionsBuilder {
    type Entity = GetBlockTransactions;
    const NAME: &'static str = "GetBlockTransactionsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.block_hash.as_slice().len()
            + self.indexes.as_slice().len()
            + self.uncle_indexes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.block_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.indexes.as_slice().len();
        offsets.push(total_size);
        total_size += self.uncle_indexes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.block_hash.as_slice())?;
        writer.write_all(self.indexes.as_slice())?;
        writer.write_all(self.uncle_indexes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetBlockTransactions::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlockTransactions(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "transactions", self.transactions())?;
        write!(f, ", {}: {}", "uncles", self.uncles())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BlockTransactions {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            56, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0,
        ];
        BlockTransactions::new_unchecked(v.into())
    }
}
impl BlockTransactions {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn transactions(&self) -> TransactionVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TransactionVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn uncles(&self) -> UncleBlockVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            UncleBlockVec::new_unchecked(self.0.slice(start..end))
        } else {
            UncleBlockVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockTransactionsReader<'r> {
        BlockTransactionsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockTransactions {
    type Builder = BlockTransactionsBuilder;
    const NAME: &'static str = "BlockTransactions";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockTransactions(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockTransactionsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockTransactionsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .block_hash(self.block_hash())
            .transactions(self.transactions())
            .uncles(self.uncles())
    }
}
#[derive(Clone, Copy)]
pub struct BlockTransactionsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "transactions", self.transactions())?;
        write!(f, ", {}: {}", "uncles", self.uncles())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BlockTransactionsReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn transactions(&self) -> TransactionVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TransactionVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn uncles(&self) -> UncleBlockVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            UncleBlockVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            UncleBlockVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockTransactionsReader<'r> {
    type Entity = BlockTransactions;
    const NAME: &'static str = "BlockTransactionsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockTransactionsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TransactionVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        UncleBlockVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockTransactionsBuilder {
    pub(crate) block_hash: Byte32,
    pub(crate) transactions: TransactionVec,
    pub(crate) uncles: UncleBlockVec,
}
impl BlockTransactionsBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn block_hash(mut self, v: Byte32) -> Self {
        self.block_hash = v;
        self
    }
    pub fn transactions(mut self, v: TransactionVec) -> Self {
        self.transactions = v;
        self
    }
    pub fn uncles(mut self, v: UncleBlockVec) -> Self {
        self.uncles = v;
        self
    }
}
impl molecule::prelude::Builder for BlockTransactionsBuilder {
    type Entity = BlockTransactions;
    const NAME: &'static str = "BlockTransactionsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.block_hash.as_slice().len()
            + self.transactions.as_slice().len()
            + self.uncles.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.block_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.transactions.as_slice().len();
        offsets.push(total_size);
        total_size += self.uncles.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.block_hash.as_slice())?;
        writer.write_all(self.transactions.as_slice())?;
        writer.write_all(self.uncles.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockTransactions::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetBlockProposal(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetBlockProposal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetBlockProposal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetBlockProposal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "proposals", self.proposals())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetBlockProposal {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            48, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        GetBlockProposal::new_unchecked(v.into())
    }
}
impl GetBlockProposal {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposals(&self) -> ProposalShortIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            ProposalShortIdVec::new_unchecked(self.0.slice(start..end))
        } else {
            ProposalShortIdVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetBlockProposalReader<'r> {
        GetBlockProposalReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetBlockProposal {
    type Builder = GetBlockProposalBuilder;
    const NAME: &'static str = "GetBlockProposal";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetBlockProposal(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockProposalReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockProposalReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .block_hash(self.block_hash())
            .proposals(self.proposals())
    }
}
#[derive(Clone, Copy)]
pub struct GetBlockProposalReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetBlockProposalReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetBlockProposalReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetBlockProposalReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "proposals", self.proposals())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetBlockProposalReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposals(&self) -> ProposalShortIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            ProposalShortIdVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ProposalShortIdVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetBlockProposalReader<'r> {
    type Entity = GetBlockProposal;
    const NAME: &'static str = "GetBlockProposalReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetBlockProposalReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ProposalShortIdVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetBlockProposalBuilder {
    pub(crate) block_hash: Byte32,
    pub(crate) proposals: ProposalShortIdVec,
}
impl GetBlockProposalBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn block_hash(mut self, v: Byte32) -> Self {
        self.block_hash = v;
        self
    }
    pub fn proposals(mut self, v: ProposalShortIdVec) -> Self {
        self.proposals = v;
        self
    }
}
impl molecule::prelude::Builder for GetBlockProposalBuilder {
    type Entity = GetBlockProposal;
    const NAME: &'static str = "GetBlockProposalBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.block_hash.as_slice().len()
            + self.proposals.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.block_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposals.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.block_hash.as_slice())?;
        writer.write_all(self.proposals.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetBlockProposal::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlockProposal(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockProposal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockProposal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockProposal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "transactions", self.transactions())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BlockProposal {
    fn default() -> Self {
        let v: Vec<u8> = vec![12, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0];
        BlockProposal::new_unchecked(v.into())
    }
}
impl BlockProposal {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn transactions(&self) -> TransactionVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            TransactionVec::new_unchecked(self.0.slice(start..end))
        } else {
            TransactionVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockProposalReader<'r> {
        BlockProposalReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockProposal {
    type Builder = BlockProposalBuilder;
    const NAME: &'static str = "BlockProposal";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockProposal(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockProposalReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockProposalReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().transactions(self.transactions())
    }
}
#[derive(Clone, Copy)]
pub struct BlockProposalReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockProposalReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockProposalReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockProposalReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "transactions", self.transactions())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BlockProposalReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn transactions(&self) -> TransactionVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            TransactionVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            TransactionVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockProposalReader<'r> {
    type Entity = BlockProposal;
    const NAME: &'static str = "BlockProposalReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockProposalReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        TransactionVecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockProposalBuilder {
    pub(crate) transactions: TransactionVec,
}
impl BlockProposalBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn transactions(mut self, v: TransactionVec) -> Self {
        self.transactions = v;
        self
    }
}
impl molecule::prelude::Builder for BlockProposalBuilder {
    type Entity = BlockProposal;
    const NAME: &'static str = "BlockProposalBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.transactions.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.transactions.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.transactions.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockProposal::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct IndexTransaction(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for IndexTransaction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for IndexTransaction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for IndexTransaction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "index", self.index())?;
        write!(f, ", {}: {}", "transaction", self.transaction())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for IndexTransaction {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            84, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 68, 0, 0, 0, 12, 0, 0, 0, 64, 0, 0,
            0, 52, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0,
            0,
        ];
        IndexTransaction::new_unchecked(v.into())
    }
}
impl IndexTransaction {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn index(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn transaction(&self) -> Transaction {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Transaction::new_unchecked(self.0.slice(start..end))
        } else {
            Transaction::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> IndexTransactionReader<'r> {
        IndexTransactionReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for IndexTransaction {
    type Builder = IndexTransactionBuilder;
    const NAME: &'static str = "IndexTransaction";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        IndexTransaction(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        IndexTransactionReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        IndexTransactionReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .index(self.index())
            .transaction(self.transaction())
    }
}
#[derive(Clone, Copy)]
pub struct IndexTransactionReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for IndexTransactionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for IndexTransactionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for IndexTransactionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "index", self.index())?;
        write!(f, ", {}: {}", "transaction", self.transaction())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> IndexTransactionReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn index(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn transaction(&self) -> TransactionReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            TransactionReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            TransactionReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for IndexTransactionReader<'r> {
    type Entity = IndexTransaction;
    const NAME: &'static str = "IndexTransactionReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        IndexTransactionReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TransactionReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct IndexTransactionBuilder {
    pub(crate) index: Uint32,
    pub(crate) transaction: Transaction,
}
impl IndexTransactionBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn index(mut self, v: Uint32) -> Self {
        self.index = v;
        self
    }
    pub fn transaction(mut self, v: Transaction) -> Self {
        self.transaction = v;
        self
    }
}
impl molecule::prelude::Builder for IndexTransactionBuilder {
    type Entity = IndexTransaction;
    const NAME: &'static str = "IndexTransactionBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.index.as_slice().len()
            + self.transaction.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.index.as_slice().len();
        offsets.push(total_size);
        total_size += self.transaction.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.index.as_slice())?;
        writer.write_all(self.transaction.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        IndexTransaction::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct IndexTransactionVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for IndexTransactionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for IndexTransactionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for IndexTransactionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for IndexTransactionVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        IndexTransactionVec::new_unchecked(v.into())
    }
}
impl IndexTransactionVec {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<IndexTransaction> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> IndexTransaction {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            IndexTransaction::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            IndexTransaction::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> IndexTransactionVecReader<'r> {
        IndexTransactionVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for IndexTransactionVec {
    type Builder = IndexTransactionVecBuilder;
    const NAME: &'static str = "IndexTransactionVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        IndexTransactionVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        IndexTransactionVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        IndexTransactionVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct IndexTransactionVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for IndexTransactionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for IndexTransactionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for IndexTransactionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> IndexTransactionVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<IndexTransactionReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> IndexTransactionReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            IndexTransactionReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            IndexTransactionReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for IndexTransactionVecReader<'r> {
    type Entity = IndexTransactionVec;
    const NAME: &'static str = "IndexTransactionVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        IndexTransactionVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            IndexTransactionReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct IndexTransactionVecBuilder(pub(crate) Vec<IndexTransaction>);
impl IndexTransactionVecBuilder {
    pub fn set(mut self, v: Vec<IndexTransaction>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: IndexTransaction) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = IndexTransaction>>(
        mut self,
        iter: T,
    ) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: IndexTransaction) -> Option<IndexTransaction> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for IndexTransactionVecBuilder {
    type Entity = IndexTransactionVec;
    const NAME: &'static str = "IndexTransactionVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        IndexTransactionVec::new_unchecked(inner.into())
    }
}
pub struct IndexTransactionVecIterator(IndexTransactionVec, usize, usize);
impl ::core::iter::Iterator for IndexTransactionVecIterator {
    type Item = IndexTransaction;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for IndexTransactionVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for IndexTransactionVec {
    type Item = IndexTransaction;
    type IntoIter = IndexTransactionVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        IndexTransactionVecIterator(self, 0, len)
    }
}
impl<'r> IndexTransactionVecReader<'r> {
    pub fn iter<'t>(&'t self) -> IndexTransactionVecReaderIterator<'t, 'r> {
        IndexTransactionVecReaderIterator(&self, 0, self.len())
    }
}
pub struct IndexTransactionVecReaderIterator<'t, 'r>(
    &'t IndexTransactionVecReader<'r>,
    usize,
    usize,
);
impl<'t: 'r, 'r> ::core::iter::Iterator for IndexTransactionVecReaderIterator<'t, 'r> {
    type Item = IndexTransactionReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for IndexTransactionVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct BlockFilterMessage(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockFilterMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockFilterMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockFilterMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for BlockFilterMessage {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        BlockFilterMessage::new_unchecked(v.into())
    }
}
impl BlockFilterMessage {
    pub const ITEMS_COUNT: usize = 6;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> BlockFilterMessageUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => GetBlockFilters::new_unchecked(inner).into(),
            1 => BlockFilters::new_unchecked(inner).into(),
            2 => GetBlockFilterHashes::new_unchecked(inner).into(),
            3 => BlockFilterHashes::new_unchecked(inner).into(),
            4 => GetBlockFilterCheckPoints::new_unchecked(inner).into(),
            5 => BlockFilterCheckPoints::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockFilterMessageReader<'r> {
        BlockFilterMessageReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockFilterMessage {
    type Builder = BlockFilterMessageBuilder;
    const NAME: &'static str = "BlockFilterMessage";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockFilterMessage(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFilterMessageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFilterMessageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct BlockFilterMessageReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockFilterMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockFilterMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockFilterMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> BlockFilterMessageReader<'r> {
    pub const ITEMS_COUNT: usize = 6;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> BlockFilterMessageUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => GetBlockFiltersReader::new_unchecked(inner).into(),
            1 => BlockFiltersReader::new_unchecked(inner).into(),
            2 => GetBlockFilterHashesReader::new_unchecked(inner).into(),
            3 => BlockFilterHashesReader::new_unchecked(inner).into(),
            4 => GetBlockFilterCheckPointsReader::new_unchecked(inner).into(),
            5 => BlockFilterCheckPointsReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockFilterMessageReader<'r> {
    type Entity = BlockFilterMessage;
    const NAME: &'static str = "BlockFilterMessageReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockFilterMessageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => GetBlockFiltersReader::verify(inner_slice, compatible),
            1 => BlockFiltersReader::verify(inner_slice, compatible),
            2 => GetBlockFilterHashesReader::verify(inner_slice, compatible),
            3 => BlockFilterHashesReader::verify(inner_slice, compatible),
            4 => GetBlockFilterCheckPointsReader::verify(inner_slice, compatible),
            5 => BlockFilterCheckPointsReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockFilterMessageBuilder(pub(crate) BlockFilterMessageUnion);
impl BlockFilterMessageBuilder {
    pub const ITEMS_COUNT: usize = 6;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<BlockFilterMessageUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for BlockFilterMessageBuilder {
    type Entity = BlockFilterMessage;
    const NAME: &'static str = "BlockFilterMessageBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockFilterMessage::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum BlockFilterMessageUnion {
    GetBlockFilters(GetBlockFilters),
    BlockFilters(BlockFilters),
    GetBlockFilterHashes(GetBlockFilterHashes),
    BlockFilterHashes(BlockFilterHashes),
    GetBlockFilterCheckPoints(GetBlockFilterCheckPoints),
    BlockFilterCheckPoints(BlockFilterCheckPoints),
}
#[derive(Debug, Clone, Copy)]
pub enum BlockFilterMessageUnionReader<'r> {
    GetBlockFilters(GetBlockFiltersReader<'r>),
    BlockFilters(BlockFiltersReader<'r>),
    GetBlockFilterHashes(GetBlockFilterHashesReader<'r>),
    BlockFilterHashes(BlockFilterHashesReader<'r>),
    GetBlockFilterCheckPoints(GetBlockFilterCheckPointsReader<'r>),
    BlockFilterCheckPoints(BlockFilterCheckPointsReader<'r>),
}
impl ::core::default::Default for BlockFilterMessageUnion {
    fn default() -> Self {
        BlockFilterMessageUnion::GetBlockFilters(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for BlockFilterMessageUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BlockFilterMessageUnion::GetBlockFilters(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlockFilters::NAME, item)
            }
            BlockFilterMessageUnion::BlockFilters(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockFilters::NAME, item)
            }
            BlockFilterMessageUnion::GetBlockFilterHashes(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetBlockFilterHashes::NAME,
                    item
                )
            }
            BlockFilterMessageUnion::BlockFilterHashes(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockFilterHashes::NAME, item)
            }
            BlockFilterMessageUnion::GetBlockFilterCheckPoints(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetBlockFilterCheckPoints::NAME,
                    item
                )
            }
            BlockFilterMessageUnion::BlockFilterCheckPoints(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    BlockFilterCheckPoints::NAME,
                    item
                )
            }
        }
    }
}
impl<'r> ::core::fmt::Display for BlockFilterMessageUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BlockFilterMessageUnionReader::GetBlockFilters(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlockFilters::NAME, item)
            }
            BlockFilterMessageUnionReader::BlockFilters(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockFilters::NAME, item)
            }
            BlockFilterMessageUnionReader::GetBlockFilterHashes(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetBlockFilterHashes::NAME,
                    item
                )
            }
            BlockFilterMessageUnionReader::BlockFilterHashes(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockFilterHashes::NAME, item)
            }
            BlockFilterMessageUnionReader::GetBlockFilterCheckPoints(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetBlockFilterCheckPoints::NAME,
                    item
                )
            }
            BlockFilterMessageUnionReader::BlockFilterCheckPoints(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    BlockFilterCheckPoints::NAME,
                    item
                )
            }
        }
    }
}
impl BlockFilterMessageUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BlockFilterMessageUnion::GetBlockFilters(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnion::BlockFilters(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnion::GetBlockFilterHashes(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnion::BlockFilterHashes(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnion::GetBlockFilterCheckPoints(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnion::BlockFilterCheckPoints(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> BlockFilterMessageUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BlockFilterMessageUnionReader::GetBlockFilters(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnionReader::BlockFilters(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnionReader::GetBlockFilterHashes(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnionReader::BlockFilterHashes(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnionReader::GetBlockFilterCheckPoints(ref item) => {
                write!(f, "{}", item)
            }
            BlockFilterMessageUnionReader::BlockFilterCheckPoints(ref item) => {
                write!(f, "{}", item)
            }
        }
    }
}
impl ::core::convert::From<GetBlockFilters> for BlockFilterMessageUnion {
    fn from(item: GetBlockFilters) -> Self {
        BlockFilterMessageUnion::GetBlockFilters(item)
    }
}
impl ::core::convert::From<BlockFilters> for BlockFilterMessageUnion {
    fn from(item: BlockFilters) -> Self {
        BlockFilterMessageUnion::BlockFilters(item)
    }
}
impl ::core::convert::From<GetBlockFilterHashes> for BlockFilterMessageUnion {
    fn from(item: GetBlockFilterHashes) -> Self {
        BlockFilterMessageUnion::GetBlockFilterHashes(item)
    }
}
impl ::core::convert::From<BlockFilterHashes> for BlockFilterMessageUnion {
    fn from(item: BlockFilterHashes) -> Self {
        BlockFilterMessageUnion::BlockFilterHashes(item)
    }
}
impl ::core::convert::From<GetBlockFilterCheckPoints> for BlockFilterMessageUnion {
    fn from(item: GetBlockFilterCheckPoints) -> Self {
        BlockFilterMessageUnion::GetBlockFilterCheckPoints(item)
    }
}
impl ::core::convert::From<BlockFilterCheckPoints> for BlockFilterMessageUnion {
    fn from(item: BlockFilterCheckPoints) -> Self {
        BlockFilterMessageUnion::BlockFilterCheckPoints(item)
    }
}
impl<'r> ::core::convert::From<GetBlockFiltersReader<'r>> for BlockFilterMessageUnionReader<'r> {
    fn from(item: GetBlockFiltersReader<'r>) -> Self {
        BlockFilterMessageUnionReader::GetBlockFilters(item)
    }
}
impl<'r> ::core::convert::From<BlockFiltersReader<'r>> for BlockFilterMessageUnionReader<'r> {
    fn from(item: BlockFiltersReader<'r>) -> Self {
        BlockFilterMessageUnionReader::BlockFilters(item)
    }
}
impl<'r> ::core::convert::From<GetBlockFilterHashesReader<'r>>
    for BlockFilterMessageUnionReader<'r>
{
    fn from(item: GetBlockFilterHashesReader<'r>) -> Self {
        BlockFilterMessageUnionReader::GetBlockFilterHashes(item)
    }
}
impl<'r> ::core::convert::From<BlockFilterHashesReader<'r>> for BlockFilterMessageUnionReader<'r> {
    fn from(item: BlockFilterHashesReader<'r>) -> Self {
        BlockFilterMessageUnionReader::BlockFilterHashes(item)
    }
}
impl<'r> ::core::convert::From<GetBlockFilterCheckPointsReader<'r>>
    for BlockFilterMessageUnionReader<'r>
{
    fn from(item: GetBlockFilterCheckPointsReader<'r>) -> Self {
        BlockFilterMessageUnionReader::GetBlockFilterCheckPoints(item)
    }
}
impl<'r> ::core::convert::From<BlockFilterCheckPointsReader<'r>>
    for BlockFilterMessageUnionReader<'r>
{
    fn from(item: BlockFilterCheckPointsReader<'r>) -> Self {
        BlockFilterMessageUnionReader::BlockFilterCheckPoints(item)
    }
}
impl BlockFilterMessageUnion {
    pub const NAME: &'static str = "BlockFilterMessageUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            BlockFilterMessageUnion::GetBlockFilters(item) => item.as_bytes(),
            BlockFilterMessageUnion::BlockFilters(item) => item.as_bytes(),
            BlockFilterMessageUnion::GetBlockFilterHashes(item) => item.as_bytes(),
            BlockFilterMessageUnion::BlockFilterHashes(item) => item.as_bytes(),
            BlockFilterMessageUnion::GetBlockFilterCheckPoints(item) => item.as_bytes(),
            BlockFilterMessageUnion::BlockFilterCheckPoints(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            BlockFilterMessageUnion::GetBlockFilters(item) => item.as_slice(),
            BlockFilterMessageUnion::BlockFilters(item) => item.as_slice(),
            BlockFilterMessageUnion::GetBlockFilterHashes(item) => item.as_slice(),
            BlockFilterMessageUnion::BlockFilterHashes(item) => item.as_slice(),
            BlockFilterMessageUnion::GetBlockFilterCheckPoints(item) => item.as_slice(),
            BlockFilterMessageUnion::BlockFilterCheckPoints(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            BlockFilterMessageUnion::GetBlockFilters(_) => 0,
            BlockFilterMessageUnion::BlockFilters(_) => 1,
            BlockFilterMessageUnion::GetBlockFilterHashes(_) => 2,
            BlockFilterMessageUnion::BlockFilterHashes(_) => 3,
            BlockFilterMessageUnion::GetBlockFilterCheckPoints(_) => 4,
            BlockFilterMessageUnion::BlockFilterCheckPoints(_) => 5,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            BlockFilterMessageUnion::GetBlockFilters(_) => "GetBlockFilters",
            BlockFilterMessageUnion::BlockFilters(_) => "BlockFilters",
            BlockFilterMessageUnion::GetBlockFilterHashes(_) => "GetBlockFilterHashes",
            BlockFilterMessageUnion::BlockFilterHashes(_) => "BlockFilterHashes",
            BlockFilterMessageUnion::GetBlockFilterCheckPoints(_) => "GetBlockFilterCheckPoints",
            BlockFilterMessageUnion::BlockFilterCheckPoints(_) => "BlockFilterCheckPoints",
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockFilterMessageUnionReader<'r> {
        match self {
            BlockFilterMessageUnion::GetBlockFilters(item) => item.as_reader().into(),
            BlockFilterMessageUnion::BlockFilters(item) => item.as_reader().into(),
            BlockFilterMessageUnion::GetBlockFilterHashes(item) => item.as_reader().into(),
            BlockFilterMessageUnion::BlockFilterHashes(item) => item.as_reader().into(),
            BlockFilterMessageUnion::GetBlockFilterCheckPoints(item) => item.as_reader().into(),
            BlockFilterMessageUnion::BlockFilterCheckPoints(item) => item.as_reader().into(),
        }
    }
}
impl<'r> BlockFilterMessageUnionReader<'r> {
    pub const NAME: &'r str = "BlockFilterMessageUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            BlockFilterMessageUnionReader::GetBlockFilters(item) => item.as_slice(),
            BlockFilterMessageUnionReader::BlockFilters(item) => item.as_slice(),
            BlockFilterMessageUnionReader::GetBlockFilterHashes(item) => item.as_slice(),
            BlockFilterMessageUnionReader::BlockFilterHashes(item) => item.as_slice(),
            BlockFilterMessageUnionReader::GetBlockFilterCheckPoints(item) => item.as_slice(),
            BlockFilterMessageUnionReader::BlockFilterCheckPoints(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            BlockFilterMessageUnionReader::GetBlockFilters(_) => 0,
            BlockFilterMessageUnionReader::BlockFilters(_) => 1,
            BlockFilterMessageUnionReader::GetBlockFilterHashes(_) => 2,
            BlockFilterMessageUnionReader::BlockFilterHashes(_) => 3,
            BlockFilterMessageUnionReader::GetBlockFilterCheckPoints(_) => 4,
            BlockFilterMessageUnionReader::BlockFilterCheckPoints(_) => 5,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            BlockFilterMessageUnionReader::GetBlockFilters(_) => "GetBlockFilters",
            BlockFilterMessageUnionReader::BlockFilters(_) => "BlockFilters",
            BlockFilterMessageUnionReader::GetBlockFilterHashes(_) => "GetBlockFilterHashes",
            BlockFilterMessageUnionReader::BlockFilterHashes(_) => "BlockFilterHashes",
            BlockFilterMessageUnionReader::GetBlockFilterCheckPoints(_) => {
                "GetBlockFilterCheckPoints"
            }
            BlockFilterMessageUnionReader::BlockFilterCheckPoints(_) => "BlockFilterCheckPoints",
        }
    }
}
#[derive(Clone)]
pub struct GetBlockFilters(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetBlockFilters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetBlockFilters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetBlockFilters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetBlockFilters {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];
        GetBlockFilters::new_unchecked(v.into())
    }
}
impl GetBlockFilters {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(0..8))
    }
    pub fn as_reader<'r>(&'r self) -> GetBlockFiltersReader<'r> {
        GetBlockFiltersReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetBlockFilters {
    type Builder = GetBlockFiltersBuilder;
    const NAME: &'static str = "GetBlockFilters";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetBlockFilters(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockFiltersReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockFiltersReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().start_number(self.start_number())
    }
}
#[derive(Clone, Copy)]
pub struct GetBlockFiltersReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetBlockFiltersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetBlockFiltersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetBlockFiltersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, " }}")
    }
}
impl<'r> GetBlockFiltersReader<'r> {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[0..8])
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetBlockFiltersReader<'r> {
    type Entity = GetBlockFilters;
    const NAME: &'static str = "GetBlockFiltersReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetBlockFiltersReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetBlockFiltersBuilder {
    pub(crate) start_number: Uint64,
}
impl GetBlockFiltersBuilder {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
}
impl molecule::prelude::Builder for GetBlockFiltersBuilder {
    type Entity = GetBlockFilters;
    const NAME: &'static str = "GetBlockFiltersBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.start_number.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetBlockFilters::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlockFilters(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockFilters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockFilters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockFilters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, ", {}: {}", "block_hashes", self.block_hashes())?;
        write!(f, ", {}: {}", "filters", self.filters())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BlockFilters {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            32, 0, 0, 0, 16, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            4, 0, 0, 0,
        ];
        BlockFilters::new_unchecked(v.into())
    }
}
impl BlockFilters {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn start_number(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn block_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn filters(&self) -> BytesVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesVec::new_unchecked(self.0.slice(start..end))
        } else {
            BytesVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockFiltersReader<'r> {
        BlockFiltersReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockFilters {
    type Builder = BlockFiltersBuilder;
    const NAME: &'static str = "BlockFilters";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockFilters(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFiltersReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFiltersReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .start_number(self.start_number())
            .block_hashes(self.block_hashes())
            .filters(self.filters())
    }
}
#[derive(Clone, Copy)]
pub struct BlockFiltersReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockFiltersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockFiltersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockFiltersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, ", {}: {}", "block_hashes", self.block_hashes())?;
        write!(f, ", {}: {}", "filters", self.filters())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BlockFiltersReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn start_number(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn block_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn filters(&self) -> BytesVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockFiltersReader<'r> {
    type Entity = BlockFilters;
    const NAME: &'static str = "BlockFiltersReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockFiltersReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockFiltersBuilder {
    pub(crate) start_number: Uint64,
    pub(crate) block_hashes: Byte32Vec,
    pub(crate) filters: BytesVec,
}
impl BlockFiltersBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
    pub fn block_hashes(mut self, v: Byte32Vec) -> Self {
        self.block_hashes = v;
        self
    }
    pub fn filters(mut self, v: BytesVec) -> Self {
        self.filters = v;
        self
    }
}
impl molecule::prelude::Builder for BlockFiltersBuilder {
    type Entity = BlockFilters;
    const NAME: &'static str = "BlockFiltersBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.start_number.as_slice().len()
            + self.block_hashes.as_slice().len()
            + self.filters.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.start_number.as_slice().len();
        offsets.push(total_size);
        total_size += self.block_hashes.as_slice().len();
        offsets.push(total_size);
        total_size += self.filters.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.start_number.as_slice())?;
        writer.write_all(self.block_hashes.as_slice())?;
        writer.write_all(self.filters.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockFilters::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetBlockFilterHashes(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetBlockFilterHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetBlockFilterHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetBlockFilterHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetBlockFilterHashes {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];
        GetBlockFilterHashes::new_unchecked(v.into())
    }
}
impl GetBlockFilterHashes {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(0..8))
    }
    pub fn as_reader<'r>(&'r self) -> GetBlockFilterHashesReader<'r> {
        GetBlockFilterHashesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetBlockFilterHashes {
    type Builder = GetBlockFilterHashesBuilder;
    const NAME: &'static str = "GetBlockFilterHashes";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetBlockFilterHashes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockFilterHashesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockFilterHashesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().start_number(self.start_number())
    }
}
#[derive(Clone, Copy)]
pub struct GetBlockFilterHashesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetBlockFilterHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetBlockFilterHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetBlockFilterHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, " }}")
    }
}
impl<'r> GetBlockFilterHashesReader<'r> {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[0..8])
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetBlockFilterHashesReader<'r> {
    type Entity = GetBlockFilterHashes;
    const NAME: &'static str = "GetBlockFilterHashesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetBlockFilterHashesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetBlockFilterHashesBuilder {
    pub(crate) start_number: Uint64,
}
impl GetBlockFilterHashesBuilder {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
}
impl molecule::prelude::Builder for GetBlockFilterHashesBuilder {
    type Entity = GetBlockFilterHashes;
    const NAME: &'static str = "GetBlockFilterHashesBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.start_number.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetBlockFilterHashes::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlockFilterHashes(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockFilterHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockFilterHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockFilterHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(
            f,
            ", {}: {}",
            "parent_block_filter_hash",
            self.parent_block_filter_hash()
        )?;
        write!(
            f,
            ", {}: {}",
            "block_filter_hashes",
            self.block_filter_hashes()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BlockFilterHashes {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            60, 0, 0, 0, 16, 0, 0, 0, 24, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,
        ];
        BlockFilterHashes::new_unchecked(v.into())
    }
}
impl BlockFilterHashes {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn start_number(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn parent_block_filter_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn block_filter_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockFilterHashesReader<'r> {
        BlockFilterHashesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockFilterHashes {
    type Builder = BlockFilterHashesBuilder;
    const NAME: &'static str = "BlockFilterHashes";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockFilterHashes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFilterHashesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFilterHashesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .start_number(self.start_number())
            .parent_block_filter_hash(self.parent_block_filter_hash())
            .block_filter_hashes(self.block_filter_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct BlockFilterHashesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockFilterHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockFilterHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockFilterHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(
            f,
            ", {}: {}",
            "parent_block_filter_hash",
            self.parent_block_filter_hash()
        )?;
        write!(
            f,
            ", {}: {}",
            "block_filter_hashes",
            self.block_filter_hashes()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BlockFilterHashesReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn start_number(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn parent_block_filter_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn block_filter_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockFilterHashesReader<'r> {
    type Entity = BlockFilterHashes;
    const NAME: &'static str = "BlockFilterHashesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockFilterHashesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockFilterHashesBuilder {
    pub(crate) start_number: Uint64,
    pub(crate) parent_block_filter_hash: Byte32,
    pub(crate) block_filter_hashes: Byte32Vec,
}
impl BlockFilterHashesBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
    pub fn parent_block_filter_hash(mut self, v: Byte32) -> Self {
        self.parent_block_filter_hash = v;
        self
    }
    pub fn block_filter_hashes(mut self, v: Byte32Vec) -> Self {
        self.block_filter_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for BlockFilterHashesBuilder {
    type Entity = BlockFilterHashes;
    const NAME: &'static str = "BlockFilterHashesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.start_number.as_slice().len()
            + self.parent_block_filter_hash.as_slice().len()
            + self.block_filter_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.start_number.as_slice().len();
        offsets.push(total_size);
        total_size += self.parent_block_filter_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.block_filter_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.start_number.as_slice())?;
        writer.write_all(self.parent_block_filter_hash.as_slice())?;
        writer.write_all(self.block_filter_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockFilterHashes::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetBlockFilterCheckPoints(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetBlockFilterCheckPoints {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetBlockFilterCheckPoints {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetBlockFilterCheckPoints {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetBlockFilterCheckPoints {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];
        GetBlockFilterCheckPoints::new_unchecked(v.into())
    }
}
impl GetBlockFilterCheckPoints {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(0..8))
    }
    pub fn as_reader<'r>(&'r self) -> GetBlockFilterCheckPointsReader<'r> {
        GetBlockFilterCheckPointsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetBlockFilterCheckPoints {
    type Builder = GetBlockFilterCheckPointsBuilder;
    const NAME: &'static str = "GetBlockFilterCheckPoints";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetBlockFilterCheckPoints(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockFilterCheckPointsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockFilterCheckPointsReader::from_compatible_slice(slice)
            .map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().start_number(self.start_number())
    }
}
#[derive(Clone, Copy)]
pub struct GetBlockFilterCheckPointsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetBlockFilterCheckPointsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetBlockFilterCheckPointsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetBlockFilterCheckPointsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, " }}")
    }
}
impl<'r> GetBlockFilterCheckPointsReader<'r> {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[0..8])
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetBlockFilterCheckPointsReader<'r> {
    type Entity = GetBlockFilterCheckPoints;
    const NAME: &'static str = "GetBlockFilterCheckPointsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetBlockFilterCheckPointsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetBlockFilterCheckPointsBuilder {
    pub(crate) start_number: Uint64,
}
impl GetBlockFilterCheckPointsBuilder {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
}
impl molecule::prelude::Builder for GetBlockFilterCheckPointsBuilder {
    type Entity = GetBlockFilterCheckPoints;
    const NAME: &'static str = "GetBlockFilterCheckPointsBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.start_number.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetBlockFilterCheckPoints::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlockFilterCheckPoints(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockFilterCheckPoints {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockFilterCheckPoints {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockFilterCheckPoints {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(
            f,
            ", {}: {}",
            "block_filter_hashes",
            self.block_filter_hashes()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BlockFilterCheckPoints {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            24, 0, 0, 0, 12, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        BlockFilterCheckPoints::new_unchecked(v.into())
    }
}
impl BlockFilterCheckPoints {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn start_number(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn block_filter_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockFilterCheckPointsReader<'r> {
        BlockFilterCheckPointsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockFilterCheckPoints {
    type Builder = BlockFilterCheckPointsBuilder;
    const NAME: &'static str = "BlockFilterCheckPoints";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockFilterCheckPoints(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFilterCheckPointsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFilterCheckPointsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .start_number(self.start_number())
            .block_filter_hashes(self.block_filter_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct BlockFilterCheckPointsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockFilterCheckPointsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockFilterCheckPointsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockFilterCheckPointsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(
            f,
            ", {}: {}",
            "block_filter_hashes",
            self.block_filter_hashes()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BlockFilterCheckPointsReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn start_number(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn block_filter_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockFilterCheckPointsReader<'r> {
    type Entity = BlockFilterCheckPoints;
    const NAME: &'static str = "BlockFilterCheckPointsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockFilterCheckPointsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockFilterCheckPointsBuilder {
    pub(crate) start_number: Uint64,
    pub(crate) block_filter_hashes: Byte32Vec,
}
impl BlockFilterCheckPointsBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
    pub fn block_filter_hashes(mut self, v: Byte32Vec) -> Self {
        self.block_filter_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for BlockFilterCheckPointsBuilder {
    type Entity = BlockFilterCheckPoints;
    const NAME: &'static str = "BlockFilterCheckPointsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.start_number.as_slice().len()
            + self.block_filter_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.start_number.as_slice().len();
        offsets.push(total_size);
        total_size += self.block_filter_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.start_number.as_slice())?;
        writer.write_all(self.block_filter_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockFilterCheckPoints::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SyncMessage(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SyncMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SyncMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SyncMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for SyncMessage {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            0, 0, 0, 0, 48, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        SyncMessage::new_unchecked(v.into())
    }
}
impl SyncMessage {
    pub const ITEMS_COUNT: usize = 9;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> SyncMessageUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => GetHeaders::new_unchecked(inner).into(),
            1 => SendHeaders::new_unchecked(inner).into(),
            2 => GetBlocks::new_unchecked(inner).into(),
            3 => SendBlock::new_unchecked(inner).into(),
            4 => SetFilter::new_unchecked(inner).into(),
            5 => AddFilter::new_unchecked(inner).into(),
            6 => ClearFilter::new_unchecked(inner).into(),
            7 => FilteredBlock::new_unchecked(inner).into(),
            8 => InIBD::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> SyncMessageReader<'r> {
        SyncMessageReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SyncMessage {
    type Builder = SyncMessageBuilder;
    const NAME: &'static str = "SyncMessage";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SyncMessage(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SyncMessageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SyncMessageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct SyncMessageReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SyncMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SyncMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SyncMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> SyncMessageReader<'r> {
    pub const ITEMS_COUNT: usize = 9;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> SyncMessageUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => GetHeadersReader::new_unchecked(inner).into(),
            1 => SendHeadersReader::new_unchecked(inner).into(),
            2 => GetBlocksReader::new_unchecked(inner).into(),
            3 => SendBlockReader::new_unchecked(inner).into(),
            4 => SetFilterReader::new_unchecked(inner).into(),
            5 => AddFilterReader::new_unchecked(inner).into(),
            6 => ClearFilterReader::new_unchecked(inner).into(),
            7 => FilteredBlockReader::new_unchecked(inner).into(),
            8 => InIBDReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SyncMessageReader<'r> {
    type Entity = SyncMessage;
    const NAME: &'static str = "SyncMessageReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SyncMessageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => GetHeadersReader::verify(inner_slice, compatible),
            1 => SendHeadersReader::verify(inner_slice, compatible),
            2 => GetBlocksReader::verify(inner_slice, compatible),
            3 => SendBlockReader::verify(inner_slice, compatible),
            4 => SetFilterReader::verify(inner_slice, compatible),
            5 => AddFilterReader::verify(inner_slice, compatible),
            6 => ClearFilterReader::verify(inner_slice, compatible),
            7 => FilteredBlockReader::verify(inner_slice, compatible),
            8 => InIBDReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SyncMessageBuilder(pub(crate) SyncMessageUnion);
impl SyncMessageBuilder {
    pub const ITEMS_COUNT: usize = 9;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<SyncMessageUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for SyncMessageBuilder {
    type Entity = SyncMessage;
    const NAME: &'static str = "SyncMessageBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SyncMessage::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum SyncMessageUnion {
    GetHeaders(GetHeaders),
    SendHeaders(SendHeaders),
    GetBlocks(GetBlocks),
    SendBlock(SendBlock),
    SetFilter(SetFilter),
    AddFilter(AddFilter),
    ClearFilter(ClearFilter),
    FilteredBlock(FilteredBlock),
    InIBD(InIBD),
}
#[derive(Debug, Clone, Copy)]
pub enum SyncMessageUnionReader<'r> {
    GetHeaders(GetHeadersReader<'r>),
    SendHeaders(SendHeadersReader<'r>),
    GetBlocks(GetBlocksReader<'r>),
    SendBlock(SendBlockReader<'r>),
    SetFilter(SetFilterReader<'r>),
    AddFilter(AddFilterReader<'r>),
    ClearFilter(ClearFilterReader<'r>),
    FilteredBlock(FilteredBlockReader<'r>),
    InIBD(InIBDReader<'r>),
}
impl ::core::default::Default for SyncMessageUnion {
    fn default() -> Self {
        SyncMessageUnion::GetHeaders(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for SyncMessageUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SyncMessageUnion::GetHeaders(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetHeaders::NAME, item)
            }
            SyncMessageUnion::SendHeaders(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendHeaders::NAME, item)
            }
            SyncMessageUnion::GetBlocks(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlocks::NAME, item)
            }
            SyncMessageUnion::SendBlock(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendBlock::NAME, item)
            }
            SyncMessageUnion::SetFilter(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SetFilter::NAME, item)
            }
            SyncMessageUnion::AddFilter(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, AddFilter::NAME, item)
            }
            SyncMessageUnion::ClearFilter(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ClearFilter::NAME, item)
            }
            SyncMessageUnion::FilteredBlock(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, FilteredBlock::NAME, item)
            }
            SyncMessageUnion::InIBD(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, InIBD::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for SyncMessageUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SyncMessageUnionReader::GetHeaders(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetHeaders::NAME, item)
            }
            SyncMessageUnionReader::SendHeaders(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendHeaders::NAME, item)
            }
            SyncMessageUnionReader::GetBlocks(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlocks::NAME, item)
            }
            SyncMessageUnionReader::SendBlock(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendBlock::NAME, item)
            }
            SyncMessageUnionReader::SetFilter(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SetFilter::NAME, item)
            }
            SyncMessageUnionReader::AddFilter(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, AddFilter::NAME, item)
            }
            SyncMessageUnionReader::ClearFilter(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, ClearFilter::NAME, item)
            }
            SyncMessageUnionReader::FilteredBlock(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, FilteredBlock::NAME, item)
            }
            SyncMessageUnionReader::InIBD(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, InIBD::NAME, item)
            }
        }
    }
}
impl SyncMessageUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SyncMessageUnion::GetHeaders(ref item) => write!(f, "{}", item),
            SyncMessageUnion::SendHeaders(ref item) => write!(f, "{}", item),
            SyncMessageUnion::GetBlocks(ref item) => write!(f, "{}", item),
            SyncMessageUnion::SendBlock(ref item) => write!(f, "{}", item),
            SyncMessageUnion::SetFilter(ref item) => write!(f, "{}", item),
            SyncMessageUnion::AddFilter(ref item) => write!(f, "{}", item),
            SyncMessageUnion::ClearFilter(ref item) => write!(f, "{}", item),
            SyncMessageUnion::FilteredBlock(ref item) => write!(f, "{}", item),
            SyncMessageUnion::InIBD(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> SyncMessageUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SyncMessageUnionReader::GetHeaders(ref item) => write!(f, "{}", item),
            SyncMessageUnionReader::SendHeaders(ref item) => write!(f, "{}", item),
            SyncMessageUnionReader::GetBlocks(ref item) => write!(f, "{}", item),
            SyncMessageUnionReader::SendBlock(ref item) => write!(f, "{}", item),
            SyncMessageUnionReader::SetFilter(ref item) => write!(f, "{}", item),
            SyncMessageUnionReader::AddFilter(ref item) => write!(f, "{}", item),
            SyncMessageUnionReader::ClearFilter(ref item) => write!(f, "{}", item),
            SyncMessageUnionReader::FilteredBlock(ref item) => write!(f, "{}", item),
            SyncMessageUnionReader::InIBD(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<GetHeaders> for SyncMessageUnion {
    fn from(item: GetHeaders) -> Self {
        SyncMessageUnion::GetHeaders(item)
    }
}
impl ::core::convert::From<SendHeaders> for SyncMessageUnion {
    fn from(item: SendHeaders) -> Self {
        SyncMessageUnion::SendHeaders(item)
    }
}
impl ::core::convert::From<GetBlocks> for SyncMessageUnion {
    fn from(item: GetBlocks) -> Self {
        SyncMessageUnion::GetBlocks(item)
    }
}
impl ::core::convert::From<SendBlock> for SyncMessageUnion {
    fn from(item: SendBlock) -> Self {
        SyncMessageUnion::SendBlock(item)
    }
}
impl ::core::convert::From<SetFilter> for SyncMessageUnion {
    fn from(item: SetFilter) -> Self {
        SyncMessageUnion::SetFilter(item)
    }
}
impl ::core::convert::From<AddFilter> for SyncMessageUnion {
    fn from(item: AddFilter) -> Self {
        SyncMessageUnion::AddFilter(item)
    }
}
impl ::core::convert::From<ClearFilter> for SyncMessageUnion {
    fn from(item: ClearFilter) -> Self {
        SyncMessageUnion::ClearFilter(item)
    }
}
impl ::core::convert::From<FilteredBlock> for SyncMessageUnion {
    fn from(item: FilteredBlock) -> Self {
        SyncMessageUnion::FilteredBlock(item)
    }
}
impl ::core::convert::From<InIBD> for SyncMessageUnion {
    fn from(item: InIBD) -> Self {
        SyncMessageUnion::InIBD(item)
    }
}
impl<'r> ::core::convert::From<GetHeadersReader<'r>> for SyncMessageUnionReader<'r> {
    fn from(item: GetHeadersReader<'r>) -> Self {
        SyncMessageUnionReader::GetHeaders(item)
    }
}
impl<'r> ::core::convert::From<SendHeadersReader<'r>> for SyncMessageUnionReader<'r> {
    fn from(item: SendHeadersReader<'r>) -> Self {
        SyncMessageUnionReader::SendHeaders(item)
    }
}
impl<'r> ::core::convert::From<GetBlocksReader<'r>> for SyncMessageUnionReader<'r> {
    fn from(item: GetBlocksReader<'r>) -> Self {
        SyncMessageUnionReader::GetBlocks(item)
    }
}
impl<'r> ::core::convert::From<SendBlockReader<'r>> for SyncMessageUnionReader<'r> {
    fn from(item: SendBlockReader<'r>) -> Self {
        SyncMessageUnionReader::SendBlock(item)
    }
}
impl<'r> ::core::convert::From<SetFilterReader<'r>> for SyncMessageUnionReader<'r> {
    fn from(item: SetFilterReader<'r>) -> Self {
        SyncMessageUnionReader::SetFilter(item)
    }
}
impl<'r> ::core::convert::From<AddFilterReader<'r>> for SyncMessageUnionReader<'r> {
    fn from(item: AddFilterReader<'r>) -> Self {
        SyncMessageUnionReader::AddFilter(item)
    }
}
impl<'r> ::core::convert::From<ClearFilterReader<'r>> for SyncMessageUnionReader<'r> {
    fn from(item: ClearFilterReader<'r>) -> Self {
        SyncMessageUnionReader::ClearFilter(item)
    }
}
impl<'r> ::core::convert::From<FilteredBlockReader<'r>> for SyncMessageUnionReader<'r> {
    fn from(item: FilteredBlockReader<'r>) -> Self {
        SyncMessageUnionReader::FilteredBlock(item)
    }
}
impl<'r> ::core::convert::From<InIBDReader<'r>> for SyncMessageUnionReader<'r> {
    fn from(item: InIBDReader<'r>) -> Self {
        SyncMessageUnionReader::InIBD(item)
    }
}
impl SyncMessageUnion {
    pub const NAME: &'static str = "SyncMessageUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            SyncMessageUnion::GetHeaders(item) => item.as_bytes(),
            SyncMessageUnion::SendHeaders(item) => item.as_bytes(),
            SyncMessageUnion::GetBlocks(item) => item.as_bytes(),
            SyncMessageUnion::SendBlock(item) => item.as_bytes(),
            SyncMessageUnion::SetFilter(item) => item.as_bytes(),
            SyncMessageUnion::AddFilter(item) => item.as_bytes(),
            SyncMessageUnion::ClearFilter(item) => item.as_bytes(),
            SyncMessageUnion::FilteredBlock(item) => item.as_bytes(),
            SyncMessageUnion::InIBD(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            SyncMessageUnion::GetHeaders(item) => item.as_slice(),
            SyncMessageUnion::SendHeaders(item) => item.as_slice(),
            SyncMessageUnion::GetBlocks(item) => item.as_slice(),
            SyncMessageUnion::SendBlock(item) => item.as_slice(),
            SyncMessageUnion::SetFilter(item) => item.as_slice(),
            SyncMessageUnion::AddFilter(item) => item.as_slice(),
            SyncMessageUnion::ClearFilter(item) => item.as_slice(),
            SyncMessageUnion::FilteredBlock(item) => item.as_slice(),
            SyncMessageUnion::InIBD(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            SyncMessageUnion::GetHeaders(_) => 0,
            SyncMessageUnion::SendHeaders(_) => 1,
            SyncMessageUnion::GetBlocks(_) => 2,
            SyncMessageUnion::SendBlock(_) => 3,
            SyncMessageUnion::SetFilter(_) => 4,
            SyncMessageUnion::AddFilter(_) => 5,
            SyncMessageUnion::ClearFilter(_) => 6,
            SyncMessageUnion::FilteredBlock(_) => 7,
            SyncMessageUnion::InIBD(_) => 8,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            SyncMessageUnion::GetHeaders(_) => "GetHeaders",
            SyncMessageUnion::SendHeaders(_) => "SendHeaders",
            SyncMessageUnion::GetBlocks(_) => "GetBlocks",
            SyncMessageUnion::SendBlock(_) => "SendBlock",
            SyncMessageUnion::SetFilter(_) => "SetFilter",
            SyncMessageUnion::AddFilter(_) => "AddFilter",
            SyncMessageUnion::ClearFilter(_) => "ClearFilter",
            SyncMessageUnion::FilteredBlock(_) => "FilteredBlock",
            SyncMessageUnion::InIBD(_) => "InIBD",
        }
    }
    pub fn as_reader<'r>(&'r self) -> SyncMessageUnionReader<'r> {
        match self {
            SyncMessageUnion::GetHeaders(item) => item.as_reader().into(),
            SyncMessageUnion::SendHeaders(item) => item.as_reader().into(),
            SyncMessageUnion::GetBlocks(item) => item.as_reader().into(),
            SyncMessageUnion::SendBlock(item) => item.as_reader().into(),
            SyncMessageUnion::SetFilter(item) => item.as_reader().into(),
            SyncMessageUnion::AddFilter(item) => item.as_reader().into(),
            SyncMessageUnion::ClearFilter(item) => item.as_reader().into(),
            SyncMessageUnion::FilteredBlock(item) => item.as_reader().into(),
            SyncMessageUnion::InIBD(item) => item.as_reader().into(),
        }
    }
}
impl<'r> SyncMessageUnionReader<'r> {
    pub const NAME: &'r str = "SyncMessageUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            SyncMessageUnionReader::GetHeaders(item) => item.as_slice(),
            SyncMessageUnionReader::SendHeaders(item) => item.as_slice(),
            SyncMessageUnionReader::GetBlocks(item) => item.as_slice(),
            SyncMessageUnionReader::SendBlock(item) => item.as_slice(),
            SyncMessageUnionReader::SetFilter(item) => item.as_slice(),
            SyncMessageUnionReader::AddFilter(item) => item.as_slice(),
            SyncMessageUnionReader::ClearFilter(item) => item.as_slice(),
            SyncMessageUnionReader::FilteredBlock(item) => item.as_slice(),
            SyncMessageUnionReader::InIBD(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            SyncMessageUnionReader::GetHeaders(_) => 0,
            SyncMessageUnionReader::SendHeaders(_) => 1,
            SyncMessageUnionReader::GetBlocks(_) => 2,
            SyncMessageUnionReader::SendBlock(_) => 3,
            SyncMessageUnionReader::SetFilter(_) => 4,
            SyncMessageUnionReader::AddFilter(_) => 5,
            SyncMessageUnionReader::ClearFilter(_) => 6,
            SyncMessageUnionReader::FilteredBlock(_) => 7,
            SyncMessageUnionReader::InIBD(_) => 8,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            SyncMessageUnionReader::GetHeaders(_) => "GetHeaders",
            SyncMessageUnionReader::SendHeaders(_) => "SendHeaders",
            SyncMessageUnionReader::GetBlocks(_) => "GetBlocks",
            SyncMessageUnionReader::SendBlock(_) => "SendBlock",
            SyncMessageUnionReader::SetFilter(_) => "SetFilter",
            SyncMessageUnionReader::AddFilter(_) => "AddFilter",
            SyncMessageUnionReader::ClearFilter(_) => "ClearFilter",
            SyncMessageUnionReader::FilteredBlock(_) => "FilteredBlock",
            SyncMessageUnionReader::InIBD(_) => "InIBD",
        }
    }
}
#[derive(Clone)]
pub struct GetHeaders(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetHeaders {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetHeaders {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetHeaders {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash_stop", self.hash_stop())?;
        write!(
            f,
            ", {}: {}",
            "block_locator_hashes",
            self.block_locator_hashes()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetHeaders {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            48, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        GetHeaders::new_unchecked(v.into())
    }
}
impl GetHeaders {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn hash_stop(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn block_locator_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetHeadersReader<'r> {
        GetHeadersReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetHeaders {
    type Builder = GetHeadersBuilder;
    const NAME: &'static str = "GetHeaders";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetHeaders(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetHeadersReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetHeadersReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .hash_stop(self.hash_stop())
            .block_locator_hashes(self.block_locator_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct GetHeadersReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetHeadersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetHeadersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetHeadersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash_stop", self.hash_stop())?;
        write!(
            f,
            ", {}: {}",
            "block_locator_hashes",
            self.block_locator_hashes()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetHeadersReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn hash_stop(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn block_locator_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetHeadersReader<'r> {
    type Entity = GetHeaders;
    const NAME: &'static str = "GetHeadersReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetHeadersReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetHeadersBuilder {
    pub(crate) hash_stop: Byte32,
    pub(crate) block_locator_hashes: Byte32Vec,
}
impl GetHeadersBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn hash_stop(mut self, v: Byte32) -> Self {
        self.hash_stop = v;
        self
    }
    pub fn block_locator_hashes(mut self, v: Byte32Vec) -> Self {
        self.block_locator_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for GetHeadersBuilder {
    type Entity = GetHeaders;
    const NAME: &'static str = "GetHeadersBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.hash_stop.as_slice().len()
            + self.block_locator_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.hash_stop.as_slice().len();
        offsets.push(total_size);
        total_size += self.block_locator_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.hash_stop.as_slice())?;
        writer.write_all(self.block_locator_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetHeaders::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetBlocks(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetBlocks {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetBlocks {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetBlocks {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hashes", self.block_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetBlocks {
    fn default() -> Self {
        let v: Vec<u8> = vec![12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
        GetBlocks::new_unchecked(v.into())
    }
}
impl GetBlocks {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetBlocksReader<'r> {
        GetBlocksReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetBlocks {
    type Builder = GetBlocksBuilder;
    const NAME: &'static str = "GetBlocks";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetBlocks(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlocksReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlocksReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().block_hashes(self.block_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct GetBlocksReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetBlocksReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetBlocksReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetBlocksReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hashes", self.block_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetBlocksReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetBlocksReader<'r> {
    type Entity = GetBlocks;
    const NAME: &'static str = "GetBlocksReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetBlocksReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32VecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetBlocksBuilder {
    pub(crate) block_hashes: Byte32Vec,
}
impl GetBlocksBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn block_hashes(mut self, v: Byte32Vec) -> Self {
        self.block_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for GetBlocksBuilder {
    type Entity = GetBlocks;
    const NAME: &'static str = "GetBlocksBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.block_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.block_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.block_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetBlocks::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SendHeaders(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SendHeaders {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SendHeaders {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SendHeaders {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "headers", self.headers())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SendHeaders {
    fn default() -> Self {
        let v: Vec<u8> = vec![12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
        SendHeaders::new_unchecked(v.into())
    }
}
impl SendHeaders {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn headers(&self) -> HeaderVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            HeaderVec::new_unchecked(self.0.slice(start..end))
        } else {
            HeaderVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SendHeadersReader<'r> {
        SendHeadersReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SendHeaders {
    type Builder = SendHeadersBuilder;
    const NAME: &'static str = "SendHeaders";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SendHeaders(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendHeadersReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendHeadersReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().headers(self.headers())
    }
}
#[derive(Clone, Copy)]
pub struct SendHeadersReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SendHeadersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SendHeadersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SendHeadersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "headers", self.headers())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SendHeadersReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn headers(&self) -> HeaderVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            HeaderVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            HeaderVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SendHeadersReader<'r> {
    type Entity = SendHeaders;
    const NAME: &'static str = "SendHeadersReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SendHeadersReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HeaderVecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SendHeadersBuilder {
    pub(crate) headers: HeaderVec,
}
impl SendHeadersBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn headers(mut self, v: HeaderVec) -> Self {
        self.headers = v;
        self
    }
}
impl molecule::prelude::Builder for SendHeadersBuilder {
    type Entity = SendHeaders;
    const NAME: &'static str = "SendHeadersBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.headers.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.headers.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.headers.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SendHeaders::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SendBlock(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SendBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SendBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SendBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block", self.block())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SendBlock {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            248, 0, 0, 0, 8, 0, 0, 0, 240, 0, 0, 0, 20, 0, 0, 0, 228, 0, 0, 0, 232, 0, 0, 0, 236,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0,
        ];
        SendBlock::new_unchecked(v.into())
    }
}
impl SendBlock {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block(&self) -> Block {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Block::new_unchecked(self.0.slice(start..end))
        } else {
            Block::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SendBlockReader<'r> {
        SendBlockReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SendBlock {
    type Builder = SendBlockBuilder;
    const NAME: &'static str = "SendBlock";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SendBlock(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendBlockReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendBlockReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().block(self.block())
    }
}
#[derive(Clone, Copy)]
pub struct SendBlockReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SendBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SendBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SendBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block", self.block())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SendBlockReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block(&self) -> BlockReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            BlockReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BlockReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SendBlockReader<'r> {
    type Entity = SendBlock;
    const NAME: &'static str = "SendBlockReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SendBlockReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BlockReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SendBlockBuilder {
    pub(crate) block: Block,
}
impl SendBlockBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn block(mut self, v: Block) -> Self {
        self.block = v;
        self
    }
}
impl molecule::prelude::Builder for SendBlockBuilder {
    type Entity = SendBlock;
    const NAME: &'static str = "SendBlockBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.block.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.block.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.block.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SendBlock::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SetFilter(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SetFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SetFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SetFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash_seed", self.hash_seed())?;
        write!(f, ", {}: {}", "filter", self.filter())?;
        write!(f, ", {}: {}", "num_hashes", self.num_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SetFilter {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            25, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        SetFilter::new_unchecked(v.into())
    }
}
impl SetFilter {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn hash_seed(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn filter(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn num_hashes(&self) -> Byte {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Byte::new_unchecked(self.0.slice(start..end))
        } else {
            Byte::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SetFilterReader<'r> {
        SetFilterReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SetFilter {
    type Builder = SetFilterBuilder;
    const NAME: &'static str = "SetFilter";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SetFilter(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SetFilterReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SetFilterReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .hash_seed(self.hash_seed())
            .filter(self.filter())
            .num_hashes(self.num_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct SetFilterReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SetFilterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SetFilterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SetFilterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash_seed", self.hash_seed())?;
        write!(f, ", {}: {}", "filter", self.filter())?;
        write!(f, ", {}: {}", "num_hashes", self.num_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SetFilterReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn hash_seed(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn filter(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn num_hashes(&self) -> ByteReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            ByteReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ByteReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SetFilterReader<'r> {
    type Entity = SetFilter;
    const NAME: &'static str = "SetFilterReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SetFilterReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        ByteReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SetFilterBuilder {
    pub(crate) hash_seed: Uint32,
    pub(crate) filter: Bytes,
    pub(crate) num_hashes: Byte,
}
impl SetFilterBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn hash_seed(mut self, v: Uint32) -> Self {
        self.hash_seed = v;
        self
    }
    pub fn filter(mut self, v: Bytes) -> Self {
        self.filter = v;
        self
    }
    pub fn num_hashes(mut self, v: Byte) -> Self {
        self.num_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for SetFilterBuilder {
    type Entity = SetFilter;
    const NAME: &'static str = "SetFilterBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.hash_seed.as_slice().len()
            + self.filter.as_slice().len()
            + self.num_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.hash_seed.as_slice().len();
        offsets.push(total_size);
        total_size += self.filter.as_slice().len();
        offsets.push(total_size);
        total_size += self.num_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.hash_seed.as_slice())?;
        writer.write_all(self.filter.as_slice())?;
        writer.write_all(self.num_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SetFilter::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct AddFilter(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for AddFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for AddFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for AddFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "filter", self.filter())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for AddFilter {
    fn default() -> Self {
        let v: Vec<u8> = vec![12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
        AddFilter::new_unchecked(v.into())
    }
}
impl AddFilter {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn filter(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> AddFilterReader<'r> {
        AddFilterReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for AddFilter {
    type Builder = AddFilterBuilder;
    const NAME: &'static str = "AddFilter";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        AddFilter(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AddFilterReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AddFilterReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().filter(self.filter())
    }
}
#[derive(Clone, Copy)]
pub struct AddFilterReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AddFilterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AddFilterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AddFilterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "filter", self.filter())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> AddFilterReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn filter(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for AddFilterReader<'r> {
    type Entity = AddFilter;
    const NAME: &'static str = "AddFilterReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AddFilterReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct AddFilterBuilder {
    pub(crate) filter: Bytes,
}
impl AddFilterBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn filter(mut self, v: Bytes) -> Self {
        self.filter = v;
        self
    }
}
impl molecule::prelude::Builder for AddFilterBuilder {
    type Entity = AddFilter;
    const NAME: &'static str = "AddFilterBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.filter.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.filter.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.filter.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        AddFilter::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct ClearFilter(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for ClearFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for ClearFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for ClearFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ".. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for ClearFilter {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        ClearFilter::new_unchecked(v.into())
    }
}
impl ClearFilter {
    pub const FIELD_COUNT: usize = 0;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn as_reader<'r>(&'r self) -> ClearFilterReader<'r> {
        ClearFilterReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for ClearFilter {
    type Builder = ClearFilterBuilder;
    const NAME: &'static str = "ClearFilter";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        ClearFilter(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ClearFilterReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        ClearFilterReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
    }
}
#[derive(Clone, Copy)]
pub struct ClearFilterReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for ClearFilterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for ClearFilterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for ClearFilterReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ".. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> ClearFilterReader<'r> {
    pub const FIELD_COUNT: usize = 0;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
}
impl<'r> molecule::prelude::Reader<'r> for ClearFilterReader<'r> {
    type Entity = ClearFilter;
    const NAME: &'static str = "ClearFilterReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        ClearFilterReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len > molecule::NUMBER_SIZE && !compatible {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, !0);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct ClearFilterBuilder {}
impl ClearFilterBuilder {
    pub const FIELD_COUNT: usize = 0;
}
impl molecule::prelude::Builder for ClearFilterBuilder {
    type Entity = ClearFilter;
    const NAME: &'static str = "ClearFilterBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(
            molecule::NUMBER_SIZE as molecule::Number,
        ))?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        ClearFilter::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct FilteredBlock(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for FilteredBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for FilteredBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for FilteredBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "transactions", self.transactions())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for FilteredBlock {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            248, 0, 0, 0, 16, 0, 0, 0, 224, 0, 0, 0, 228, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 20, 0,
            0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        FilteredBlock::new_unchecked(v.into())
    }
}
impl FilteredBlock {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> Header {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Header::new_unchecked(self.0.slice(start..end))
    }
    pub fn transactions(&self) -> TransactionVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TransactionVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn proof(&self) -> MerkleProof {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            MerkleProof::new_unchecked(self.0.slice(start..end))
        } else {
            MerkleProof::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> FilteredBlockReader<'r> {
        FilteredBlockReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for FilteredBlock {
    type Builder = FilteredBlockBuilder;
    const NAME: &'static str = "FilteredBlock";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        FilteredBlock(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FilteredBlockReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FilteredBlockReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .header(self.header())
            .transactions(self.transactions())
            .proof(self.proof())
    }
}
#[derive(Clone, Copy)]
pub struct FilteredBlockReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for FilteredBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for FilteredBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for FilteredBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "transactions", self.transactions())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> FilteredBlockReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> HeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn transactions(&self) -> TransactionVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TransactionVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proof(&self) -> MerkleProofReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            MerkleProofReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            MerkleProofReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for FilteredBlockReader<'r> {
    type Entity = FilteredBlock;
    const NAME: &'static str = "FilteredBlockReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        FilteredBlockReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TransactionVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        MerkleProofReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct FilteredBlockBuilder {
    pub(crate) header: Header,
    pub(crate) transactions: TransactionVec,
    pub(crate) proof: MerkleProof,
}
impl FilteredBlockBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn header(mut self, v: Header) -> Self {
        self.header = v;
        self
    }
    pub fn transactions(mut self, v: TransactionVec) -> Self {
        self.transactions = v;
        self
    }
    pub fn proof(mut self, v: MerkleProof) -> Self {
        self.proof = v;
        self
    }
}
impl molecule::prelude::Builder for FilteredBlockBuilder {
    type Entity = FilteredBlock;
    const NAME: &'static str = "FilteredBlockBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.header.as_slice().len()
            + self.transactions.as_slice().len()
            + self.proof.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.header.as_slice().len();
        offsets.push(total_size);
        total_size += self.transactions.as_slice().len();
        offsets.push(total_size);
        total_size += self.proof.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.header.as_slice())?;
        writer.write_all(self.transactions.as_slice())?;
        writer.write_all(self.proof.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        FilteredBlock::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct MerkleProof(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for MerkleProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for MerkleProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for MerkleProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "indices", self.indices())?;
        write!(f, ", {}: {}", "lemmas", self.lemmas())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for MerkleProof {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        MerkleProof::new_unchecked(v.into())
    }
}
impl MerkleProof {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn indices(&self) -> Uint32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn lemmas(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> MerkleProofReader<'r> {
        MerkleProofReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for MerkleProof {
    type Builder = MerkleProofBuilder;
    const NAME: &'static str = "MerkleProof";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        MerkleProof(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MerkleProofReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MerkleProofReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .indices(self.indices())
            .lemmas(self.lemmas())
    }
}
#[derive(Clone, Copy)]
pub struct MerkleProofReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MerkleProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MerkleProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MerkleProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "indices", self.indices())?;
        write!(f, ", {}: {}", "lemmas", self.lemmas())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> MerkleProofReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn indices(&self) -> Uint32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn lemmas(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for MerkleProofReader<'r> {
    type Entity = MerkleProof;
    const NAME: &'static str = "MerkleProofReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MerkleProofReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint32VecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct MerkleProofBuilder {
    pub(crate) indices: Uint32Vec,
    pub(crate) lemmas: Byte32Vec,
}
impl MerkleProofBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn indices(mut self, v: Uint32Vec) -> Self {
        self.indices = v;
        self
    }
    pub fn lemmas(mut self, v: Byte32Vec) -> Self {
        self.lemmas = v;
        self
    }
}
impl molecule::prelude::Builder for MerkleProofBuilder {
    type Entity = MerkleProof;
    const NAME: &'static str = "MerkleProofBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.indices.as_slice().len()
            + self.lemmas.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.indices.as_slice().len();
        offsets.push(total_size);
        total_size += self.lemmas.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.indices.as_slice())?;
        writer.write_all(self.lemmas.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        MerkleProof::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct InIBD(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for InIBD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for InIBD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for InIBD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ".. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for InIBD {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        InIBD::new_unchecked(v.into())
    }
}
impl InIBD {
    pub const FIELD_COUNT: usize = 0;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn as_reader<'r>(&'r self) -> InIBDReader<'r> {
        InIBDReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for InIBD {
    type Builder = InIBDBuilder;
    const NAME: &'static str = "InIBD";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        InIBD(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        InIBDReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        InIBDReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
    }
}
#[derive(Clone, Copy)]
pub struct InIBDReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for InIBDReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for InIBDReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for InIBDReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ".. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> InIBDReader<'r> {
    pub const FIELD_COUNT: usize = 0;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
}
impl<'r> molecule::prelude::Reader<'r> for InIBDReader<'r> {
    type Entity = InIBD;
    const NAME: &'static str = "InIBDReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        InIBDReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len > molecule::NUMBER_SIZE && !compatible {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, !0);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct InIBDBuilder {}
impl InIBDBuilder {
    pub const FIELD_COUNT: usize = 0;
}
impl molecule::prelude::Builder for InIBDBuilder {
    type Entity = InIBD;
    const NAME: &'static str = "InIBDBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(
            molecule::NUMBER_SIZE as molecule::Number,
        ))?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        InIBD::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct HeaderDigestVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for HeaderDigestVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for HeaderDigestVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for HeaderDigestVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for HeaderDigestVec {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0];
        HeaderDigestVec::new_unchecked(v.into())
    }
}
impl HeaderDigestVec {
    pub const ITEM_SIZE: usize = 72;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<HeaderDigest> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> HeaderDigest {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        HeaderDigest::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> HeaderDigestVecReader<'r> {
        HeaderDigestVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for HeaderDigestVec {
    type Builder = HeaderDigestVecBuilder;
    const NAME: &'static str = "HeaderDigestVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        HeaderDigestVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderDigestVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderDigestVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct HeaderDigestVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for HeaderDigestVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for HeaderDigestVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for HeaderDigestVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> HeaderDigestVecReader<'r> {
    pub const ITEM_SIZE: usize = 72;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<HeaderDigestReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> HeaderDigestReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        HeaderDigestReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for HeaderDigestVecReader<'r> {
    type Entity = HeaderDigestVec;
    const NAME: &'static str = "HeaderDigestVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        HeaderDigestVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct HeaderDigestVecBuilder(pub(crate) Vec<HeaderDigest>);
impl HeaderDigestVecBuilder {
    pub const ITEM_SIZE: usize = 72;
    pub fn set(mut self, v: Vec<HeaderDigest>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: HeaderDigest) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = HeaderDigest>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: HeaderDigest) -> Option<HeaderDigest> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for HeaderDigestVecBuilder {
    type Entity = HeaderDigestVec;
    const NAME: &'static str = "HeaderDigestVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        HeaderDigestVec::new_unchecked(inner.into())
    }
}
pub struct HeaderDigestVecIterator(HeaderDigestVec, usize, usize);
impl ::core::iter::Iterator for HeaderDigestVecIterator {
    type Item = HeaderDigest;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for HeaderDigestVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for HeaderDigestVec {
    type Item = HeaderDigest;
    type IntoIter = HeaderDigestVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        HeaderDigestVecIterator(self, 0, len)
    }
}
impl<'r> HeaderDigestVecReader<'r> {
    pub fn iter<'t>(&'t self) -> HeaderDigestVecReaderIterator<'t, 'r> {
        HeaderDigestVecReaderIterator(&self, 0, self.len())
    }
}
pub struct HeaderDigestVecReaderIterator<'t, 'r>(&'t HeaderDigestVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for HeaderDigestVecReaderIterator<'t, 'r> {
    type Item = HeaderDigestReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for HeaderDigestVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct BlockProof(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "mmr_size", self.mmr_size())?;
        write!(f, ", {}: {}", "items", self.items())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BlockProof {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            24, 0, 0, 0, 12, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        BlockProof::new_unchecked(v.into())
    }
}
impl BlockProof {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn mmr_size(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn items(&self) -> HeaderDigestVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            HeaderDigestVec::new_unchecked(self.0.slice(start..end))
        } else {
            HeaderDigestVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockProofReader<'r> {
        BlockProofReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockProof {
    type Builder = BlockProofBuilder;
    const NAME: &'static str = "BlockProof";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockProof(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockProofReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockProofReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .mmr_size(self.mmr_size())
            .items(self.items())
    }
}
#[derive(Clone, Copy)]
pub struct BlockProofReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "mmr_size", self.mmr_size())?;
        write!(f, ", {}: {}", "items", self.items())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BlockProofReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn mmr_size(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn items(&self) -> HeaderDigestVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            HeaderDigestVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            HeaderDigestVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockProofReader<'r> {
    type Entity = BlockProof;
    const NAME: &'static str = "BlockProofReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockProofReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        HeaderDigestVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockProofBuilder {
    pub(crate) mmr_size: Uint64,
    pub(crate) items: HeaderDigestVec,
}
impl BlockProofBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn mmr_size(mut self, v: Uint64) -> Self {
        self.mmr_size = v;
        self
    }
    pub fn items(mut self, v: HeaderDigestVec) -> Self {
        self.items = v;
        self
    }
}
impl molecule::prelude::Builder for BlockProofBuilder {
    type Entity = BlockProof;
    const NAME: &'static str = "BlockProofBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.mmr_size.as_slice().len()
            + self.items.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.mmr_size.as_slice().len();
        offsets.push(total_size);
        total_size += self.items.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.mmr_size.as_slice())?;
        writer.write_all(self.items.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockProof::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct LightClientMessage(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for LightClientMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for LightClientMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for LightClientMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for LightClientMessage {
    fn default() -> Self {
        let v: Vec<u8> = vec![0, 0, 0, 0, 4, 0, 0, 0];
        LightClientMessage::new_unchecked(v.into())
    }
}
impl LightClientMessage {
    pub const ITEMS_COUNT: usize = 6;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> LightClientMessageUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => GetChainInfo::new_unchecked(inner).into(),
            1 => SendChainInfo::new_unchecked(inner).into(),
            2 => GetLastHeader::new_unchecked(inner).into(),
            3 => SendLastHeader::new_unchecked(inner).into(),
            4 => GetBlockProof::new_unchecked(inner).into(),
            5 => SendBlockProof::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> LightClientMessageReader<'r> {
        LightClientMessageReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for LightClientMessage {
    type Builder = LightClientMessageBuilder;
    const NAME: &'static str = "LightClientMessage";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        LightClientMessage(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LightClientMessageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LightClientMessageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct LightClientMessageReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for LightClientMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for LightClientMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for LightClientMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> LightClientMessageReader<'r> {
    pub const ITEMS_COUNT: usize = 6;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> LightClientMessageUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => GetChainInfoReader::new_unchecked(inner).into(),
            1 => SendChainInfoReader::new_unchecked(inner).into(),
            2 => GetLastHeaderReader::new_unchecked(inner).into(),
            3 => SendLastHeaderReader::new_unchecked(inner).into(),
            4 => GetBlockProofReader::new_unchecked(inner).into(),
            5 => SendBlockProofReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for LightClientMessageReader<'r> {
    type Entity = LightClientMessage;
    const NAME: &'static str = "LightClientMessageReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        LightClientMessageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => GetChainInfoReader::verify(inner_slice, compatible),
            1 => SendChainInfoReader::verify(inner_slice, compatible),
            2 => GetLastHeaderReader::verify(inner_slice, compatible),
            3 => SendLastHeaderReader::verify(inner_slice, compatible),
            4 => GetBlockProofReader::verify(inner_slice, compatible),
            5 => SendBlockProofReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct LightClientMessageBuilder(pub(crate) LightClientMessageUnion);
impl LightClientMessageBuilder {
    pub const ITEMS_COUNT: usize = 6;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<LightClientMessageUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for LightClientMessageBuilder {
    type Entity = LightClientMessage;
    const NAME: &'static str = "LightClientMessageBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        LightClientMessage::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum LightClientMessageUnion {
    GetChainInfo(GetChainInfo),
    SendChainInfo(SendChainInfo),
    GetLastHeader(GetLastHeader),
    SendLastHeader(SendLastHeader),
    GetBlockProof(GetBlockProof),
    SendBlockProof(SendBlockProof),
}
#[derive(Debug, Clone, Copy)]
pub enum LightClientMessageUnionReader<'r> {
    GetChainInfo(GetChainInfoReader<'r>),
    SendChainInfo(SendChainInfoReader<'r>),
    GetLastHeader(GetLastHeaderReader<'r>),
    SendLastHeader(SendLastHeaderReader<'r>),
    GetBlockProof(GetBlockProofReader<'r>),
    SendBlockProof(SendBlockProofReader<'r>),
}
impl ::core::default::Default for LightClientMessageUnion {
    fn default() -> Self {
        LightClientMessageUnion::GetChainInfo(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for LightClientMessageUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            LightClientMessageUnion::GetChainInfo(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetChainInfo::NAME, item)
            }
            LightClientMessageUnion::SendChainInfo(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendChainInfo::NAME, item)
            }
            LightClientMessageUnion::GetLastHeader(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetLastHeader::NAME, item)
            }
            LightClientMessageUnion::SendLastHeader(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendLastHeader::NAME, item)
            }
            LightClientMessageUnion::GetBlockProof(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlockProof::NAME, item)
            }
            LightClientMessageUnion::SendBlockProof(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendBlockProof::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for LightClientMessageUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            LightClientMessageUnionReader::GetChainInfo(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetChainInfo::NAME, item)
            }
            LightClientMessageUnionReader::SendChainInfo(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendChainInfo::NAME, item)
            }
            LightClientMessageUnionReader::GetLastHeader(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetLastHeader::NAME, item)
            }
            LightClientMessageUnionReader::SendLastHeader(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendLastHeader::NAME, item)
            }
            LightClientMessageUnionReader::GetBlockProof(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlockProof::NAME, item)
            }
            LightClientMessageUnionReader::SendBlockProof(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendBlockProof::NAME, item)
            }
        }
    }
}
impl LightClientMessageUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            LightClientMessageUnion::GetChainInfo(ref item) => write!(f, "{}", item),
            LightClientMessageUnion::SendChainInfo(ref item) => write!(f, "{}", item),
            LightClientMessageUnion::GetLastHeader(ref item) => write!(f, "{}", item),
            LightClientMessageUnion::SendLastHeader(ref item) => write!(f, "{}", item),
            LightClientMessageUnion::GetBlockProof(ref item) => write!(f, "{}", item),
            LightClientMessageUnion::SendBlockProof(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> LightClientMessageUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            LightClientMessageUnionReader::GetChainInfo(ref item) => write!(f, "{}", item),
            LightClientMessageUnionReader::SendChainInfo(ref item) => write!(f, "{}", item),
            LightClientMessageUnionReader::GetLastHeader(ref item) => write!(f, "{}", item),
            LightClientMessageUnionReader::SendLastHeader(ref item) => write!(f, "{}", item),
            LightClientMessageUnionReader::GetBlockProof(ref item) => write!(f, "{}", item),
            LightClientMessageUnionReader::SendBlockProof(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<GetChainInfo> for LightClientMessageUnion {
    fn from(item: GetChainInfo) -> Self {
        LightClientMessageUnion::GetChainInfo(item)
    }
}
impl ::core::convert::From<SendChainInfo> for LightClientMessageUnion {
    fn from(item: SendChainInfo) -> Self {
        LightClientMessageUnion::SendChainInfo(item)
    }
}
impl ::core::convert::From<GetLastHeader> for LightClientMessageUnion {
    fn from(item: GetLastHeader) -> Self {
        LightClientMessageUnion::GetLastHeader(item)
    }
}
impl ::core::convert::From<SendLastHeader> for LightClientMessageUnion {
    fn from(item: SendLastHeader) -> Self {
        LightClientMessageUnion::SendLastHeader(item)
    }
}
impl ::core::convert::From<GetBlockProof> for LightClientMessageUnion {
    fn from(item: GetBlockProof) -> Self {
        LightClientMessageUnion::GetBlockProof(item)
    }
}
impl ::core::convert::From<SendBlockProof> for LightClientMessageUnion {
    fn from(item: SendBlockProof) -> Self {
        LightClientMessageUnion::SendBlockProof(item)
    }
}
impl<'r> ::core::convert::From<GetChainInfoReader<'r>> for LightClientMessageUnionReader<'r> {
    fn from(item: GetChainInfoReader<'r>) -> Self {
        LightClientMessageUnionReader::GetChainInfo(item)
    }
}
impl<'r> ::core::convert::From<SendChainInfoReader<'r>> for LightClientMessageUnionReader<'r> {
    fn from(item: SendChainInfoReader<'r>) -> Self {
        LightClientMessageUnionReader::SendChainInfo(item)
    }
}
impl<'r> ::core::convert::From<GetLastHeaderReader<'r>> for LightClientMessageUnionReader<'r> {
    fn from(item: GetLastHeaderReader<'r>) -> Self {
        LightClientMessageUnionReader::GetLastHeader(item)
    }
}
impl<'r> ::core::convert::From<SendLastHeaderReader<'r>> for LightClientMessageUnionReader<'r> {
    fn from(item: SendLastHeaderReader<'r>) -> Self {
        LightClientMessageUnionReader::SendLastHeader(item)
    }
}
impl<'r> ::core::convert::From<GetBlockProofReader<'r>> for LightClientMessageUnionReader<'r> {
    fn from(item: GetBlockProofReader<'r>) -> Self {
        LightClientMessageUnionReader::GetBlockProof(item)
    }
}
impl<'r> ::core::convert::From<SendBlockProofReader<'r>> for LightClientMessageUnionReader<'r> {
    fn from(item: SendBlockProofReader<'r>) -> Self {
        LightClientMessageUnionReader::SendBlockProof(item)
    }
}
impl LightClientMessageUnion {
    pub const NAME: &'static str = "LightClientMessageUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            LightClientMessageUnion::GetChainInfo(item) => item.as_bytes(),
            LightClientMessageUnion::SendChainInfo(item) => item.as_bytes(),
            LightClientMessageUnion::GetLastHeader(item) => item.as_bytes(),
            LightClientMessageUnion::SendLastHeader(item) => item.as_bytes(),
            LightClientMessageUnion::GetBlockProof(item) => item.as_bytes(),
            LightClientMessageUnion::SendBlockProof(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            LightClientMessageUnion::GetChainInfo(item) => item.as_slice(),
            LightClientMessageUnion::SendChainInfo(item) => item.as_slice(),
            LightClientMessageUnion::GetLastHeader(item) => item.as_slice(),
            LightClientMessageUnion::SendLastHeader(item) => item.as_slice(),
            LightClientMessageUnion::GetBlockProof(item) => item.as_slice(),
            LightClientMessageUnion::SendBlockProof(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            LightClientMessageUnion::GetChainInfo(_) => 0,
            LightClientMessageUnion::SendChainInfo(_) => 1,
            LightClientMessageUnion::GetLastHeader(_) => 2,
            LightClientMessageUnion::SendLastHeader(_) => 3,
            LightClientMessageUnion::GetBlockProof(_) => 4,
            LightClientMessageUnion::SendBlockProof(_) => 5,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            LightClientMessageUnion::GetChainInfo(_) => "GetChainInfo",
            LightClientMessageUnion::SendChainInfo(_) => "SendChainInfo",
            LightClientMessageUnion::GetLastHeader(_) => "GetLastHeader",
            LightClientMessageUnion::SendLastHeader(_) => "SendLastHeader",
            LightClientMessageUnion::GetBlockProof(_) => "GetBlockProof",
            LightClientMessageUnion::SendBlockProof(_) => "SendBlockProof",
        }
    }
    pub fn as_reader<'r>(&'r self) -> LightClientMessageUnionReader<'r> {
        match self {
            LightClientMessageUnion::GetChainInfo(item) => item.as_reader().into(),
            LightClientMessageUnion::SendChainInfo(item) => item.as_reader().into(),
            LightClientMessageUnion::GetLastHeader(item) => item.as_reader().into(),
            LightClientMessageUnion::SendLastHeader(item) => item.as_reader().into(),
            LightClientMessageUnion::GetBlockProof(item) => item.as_reader().into(),
            LightClientMessageUnion::SendBlockProof(item) => item.as_reader().into(),
        }
    }
}
impl<'r> LightClientMessageUnionReader<'r> {
    pub const NAME: &'r str = "LightClientMessageUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            LightClientMessageUnionReader::GetChainInfo(item) => item.as_slice(),
            LightClientMessageUnionReader::SendChainInfo(item) => item.as_slice(),
            LightClientMessageUnionReader::GetLastHeader(item) => item.as_slice(),
            LightClientMessageUnionReader::SendLastHeader(item) => item.as_slice(),
            LightClientMessageUnionReader::GetBlockProof(item) => item.as_slice(),
            LightClientMessageUnionReader::SendBlockProof(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            LightClientMessageUnionReader::GetChainInfo(_) => 0,
            LightClientMessageUnionReader::SendChainInfo(_) => 1,
            LightClientMessageUnionReader::GetLastHeader(_) => 2,
            LightClientMessageUnionReader::SendLastHeader(_) => 3,
            LightClientMessageUnionReader::GetBlockProof(_) => 4,
            LightClientMessageUnionReader::SendBlockProof(_) => 5,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            LightClientMessageUnionReader::GetChainInfo(_) => "GetChainInfo",
            LightClientMessageUnionReader::SendChainInfo(_) => "SendChainInfo",
            LightClientMessageUnionReader::GetLastHeader(_) => "GetLastHeader",
            LightClientMessageUnionReader::SendLastHeader(_) => "SendLastHeader",
            LightClientMessageUnionReader::GetBlockProof(_) => "GetBlockProof",
            LightClientMessageUnionReader::SendBlockProof(_) => "SendBlockProof",
        }
    }
}
#[derive(Clone)]
pub struct GetChainInfo(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetChainInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetChainInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetChainInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ".. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetChainInfo {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        GetChainInfo::new_unchecked(v.into())
    }
}
impl GetChainInfo {
    pub const FIELD_COUNT: usize = 0;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn as_reader<'r>(&'r self) -> GetChainInfoReader<'r> {
        GetChainInfoReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetChainInfo {
    type Builder = GetChainInfoBuilder;
    const NAME: &'static str = "GetChainInfo";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetChainInfo(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetChainInfoReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetChainInfoReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
    }
}
#[derive(Clone, Copy)]
pub struct GetChainInfoReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetChainInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetChainInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetChainInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ".. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetChainInfoReader<'r> {
    pub const FIELD_COUNT: usize = 0;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetChainInfoReader<'r> {
    type Entity = GetChainInfo;
    const NAME: &'static str = "GetChainInfoReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetChainInfoReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len > molecule::NUMBER_SIZE && !compatible {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, !0);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetChainInfoBuilder {}
impl GetChainInfoBuilder {
    pub const FIELD_COUNT: usize = 0;
}
impl molecule::prelude::Builder for GetChainInfoBuilder {
    type Entity = GetChainInfo;
    const NAME: &'static str = "GetChainInfoBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(
            molecule::NUMBER_SIZE as molecule::Number,
        ))?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetChainInfo::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SendChainInfo(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SendChainInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SendChainInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SendChainInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(
            f,
            "{}: {}",
            "mmr_activated_number",
            self.mmr_activated_number()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SendChainInfo {
    fn default() -> Self {
        let v: Vec<u8> = vec![16, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        SendChainInfo::new_unchecked(v.into())
    }
}
impl SendChainInfo {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn mmr_activated_number(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Uint64::new_unchecked(self.0.slice(start..end))
        } else {
            Uint64::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SendChainInfoReader<'r> {
        SendChainInfoReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SendChainInfo {
    type Builder = SendChainInfoBuilder;
    const NAME: &'static str = "SendChainInfo";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SendChainInfo(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendChainInfoReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendChainInfoReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().mmr_activated_number(self.mmr_activated_number())
    }
}
#[derive(Clone, Copy)]
pub struct SendChainInfoReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SendChainInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SendChainInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SendChainInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(
            f,
            "{}: {}",
            "mmr_activated_number",
            self.mmr_activated_number()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SendChainInfoReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn mmr_activated_number(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Uint64Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint64Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SendChainInfoReader<'r> {
    type Entity = SendChainInfo;
    const NAME: &'static str = "SendChainInfoReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SendChainInfoReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SendChainInfoBuilder {
    pub(crate) mmr_activated_number: Uint64,
}
impl SendChainInfoBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn mmr_activated_number(mut self, v: Uint64) -> Self {
        self.mmr_activated_number = v;
        self
    }
}
impl molecule::prelude::Builder for SendChainInfoBuilder {
    type Entity = SendChainInfo;
    const NAME: &'static str = "SendChainInfoBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.mmr_activated_number.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.mmr_activated_number.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.mmr_activated_number.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SendChainInfo::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetLastHeader(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetLastHeader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetLastHeader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetLastHeader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ".. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetLastHeader {
    fn default() -> Self {
        let v: Vec<u8> = vec![4, 0, 0, 0];
        GetLastHeader::new_unchecked(v.into())
    }
}
impl GetLastHeader {
    pub const FIELD_COUNT: usize = 0;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn as_reader<'r>(&'r self) -> GetLastHeaderReader<'r> {
        GetLastHeaderReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetLastHeader {
    type Builder = GetLastHeaderBuilder;
    const NAME: &'static str = "GetLastHeader";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetLastHeader(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetLastHeaderReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetLastHeaderReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
    }
}
#[derive(Clone, Copy)]
pub struct GetLastHeaderReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetLastHeaderReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetLastHeaderReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetLastHeaderReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ".. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetLastHeaderReader<'r> {
    pub const FIELD_COUNT: usize = 0;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetLastHeaderReader<'r> {
    type Entity = GetLastHeader;
    const NAME: &'static str = "GetLastHeaderReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetLastHeaderReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len > molecule::NUMBER_SIZE && !compatible {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, !0);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetLastHeaderBuilder {}
impl GetLastHeaderBuilder {
    pub const FIELD_COUNT: usize = 0;
}
impl molecule::prelude::Builder for GetLastHeaderBuilder {
    type Entity = GetLastHeader;
    const NAME: &'static str = "GetLastHeaderBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(
            molecule::NUMBER_SIZE as molecule::Number,
        ))?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetLastHeader::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SendLastHeader(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SendLastHeader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SendLastHeader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SendLastHeader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SendLastHeader {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            216, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        SendLastHeader::new_unchecked(v.into())
    }
}
impl SendLastHeader {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> Header {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Header::new_unchecked(self.0.slice(start..end))
        } else {
            Header::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SendLastHeaderReader<'r> {
        SendLastHeaderReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SendLastHeader {
    type Builder = SendLastHeaderBuilder;
    const NAME: &'static str = "SendLastHeader";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SendLastHeader(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendLastHeaderReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendLastHeaderReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().header(self.header())
    }
}
#[derive(Clone, Copy)]
pub struct SendLastHeaderReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SendLastHeaderReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SendLastHeaderReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SendLastHeaderReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SendLastHeaderReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> HeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            HeaderReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            HeaderReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SendLastHeaderReader<'r> {
    type Entity = SendLastHeader;
    const NAME: &'static str = "SendLastHeaderReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SendLastHeaderReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SendLastHeaderBuilder {
    pub(crate) header: Header,
}
impl SendLastHeaderBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn header(mut self, v: Header) -> Self {
        self.header = v;
        self
    }
}
impl molecule::prelude::Builder for SendLastHeaderBuilder {
    type Entity = SendLastHeader;
    const NAME: &'static str = "SendLastHeaderBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.header.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.header.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.header.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SendLastHeader::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetBlockProof(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetBlockProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetBlockProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetBlockProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_hash", self.last_hash())?;
        write!(f, ", {}: {}", "numbers", self.numbers())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetBlockProof {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            48, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        GetBlockProof::new_unchecked(v.into())
    }
}
impl GetBlockProof {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn numbers(&self) -> Uint64Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Uint64Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Uint64Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetBlockProofReader<'r> {
        GetBlockProofReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetBlockProof {
    type Builder = GetBlockProofBuilder;
    const NAME: &'static str = "GetBlockProof";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetBlockProof(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockProofReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockProofReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .last_hash(self.last_hash())
            .numbers(self.numbers())
    }
}
#[derive(Clone, Copy)]
pub struct GetBlockProofReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetBlockProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetBlockProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetBlockProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_hash", self.last_hash())?;
        write!(f, ", {}: {}", "numbers", self.numbers())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetBlockProofReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn numbers(&self) -> Uint64VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Uint64VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint64VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetBlockProofReader<'r> {
    type Entity = GetBlockProof;
    const NAME: &'static str = "GetBlockProofReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetBlockProofReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64VecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetBlockProofBuilder {
    pub(crate) last_hash: Byte32,
    pub(crate) numbers: Uint64Vec,
}
impl GetBlockProofBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn last_hash(mut self, v: Byte32) -> Self {
        self.last_hash = v;
        self
    }
    pub fn numbers(mut self, v: Uint64Vec) -> Self {
        self.numbers = v;
        self
    }
}
impl molecule::prelude::Builder for GetBlockProofBuilder {
    type Entity = GetBlockProof;
    const NAME: &'static str = "GetBlockProofBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.last_hash.as_slice().len()
            + self.numbers.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.last_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.numbers.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.last_hash.as_slice())?;
        writer.write_all(self.numbers.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetBlockProof::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SendBlockProof(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SendBlockProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SendBlockProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SendBlockProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "root", self.root())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        write!(f, ", {}: {}", "headers", self.headers())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SendBlockProof {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            116, 0, 0, 0, 16, 0, 0, 0, 88, 0, 0, 0, 112, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 24, 0, 0, 0, 12, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,
        ];
        SendBlockProof::new_unchecked(v.into())
    }
}
impl SendBlockProof {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn root(&self) -> HeaderDigest {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HeaderDigest::new_unchecked(self.0.slice(start..end))
    }
    pub fn proof(&self) -> BlockProof {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BlockProof::new_unchecked(self.0.slice(start..end))
    }
    pub fn headers(&self) -> HeaderVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            HeaderVec::new_unchecked(self.0.slice(start..end))
        } else {
            HeaderVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SendBlockProofReader<'r> {
        SendBlockProofReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SendBlockProof {
    type Builder = SendBlockProofBuilder;
    const NAME: &'static str = "SendBlockProof";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SendBlockProof(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendBlockProofReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendBlockProofReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .root(self.root())
            .proof(self.proof())
            .headers(self.headers())
    }
}
#[derive(Clone, Copy)]
pub struct SendBlockProofReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SendBlockProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SendBlockProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SendBlockProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "root", self.root())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        write!(f, ", {}: {}", "headers", self.headers())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SendBlockProofReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn root(&self) -> HeaderDigestReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HeaderDigestReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proof(&self) -> BlockProofReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BlockProofReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn headers(&self) -> HeaderVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            HeaderVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            HeaderVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SendBlockProofReader<'r> {
    type Entity = SendBlockProof;
    const NAME: &'static str = "SendBlockProofReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SendBlockProofReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HeaderDigestReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BlockProofReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        HeaderVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SendBlockProofBuilder {
    pub(crate) root: HeaderDigest,
    pub(crate) proof: BlockProof,
    pub(crate) headers: HeaderVec,
}
impl SendBlockProofBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn root(mut self, v: HeaderDigest) -> Self {
        self.root = v;
        self
    }
    pub fn proof(mut self, v: BlockProof) -> Self {
        self.proof = v;
        self
    }
    pub fn headers(mut self, v: HeaderVec) -> Self {
        self.headers = v;
        self
    }
}
impl molecule::prelude::Builder for SendBlockProofBuilder {
    type Entity = SendBlockProof;
    const NAME: &'static str = "SendBlockProofBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.root.as_slice().len()
            + self.proof.as_slice().len()
            + self.headers.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.root.as_slice().len();
        offsets.push(total_size);
        total_size += self.proof.as_slice().len();
        offsets.push(total_size);
        total_size += self.headers.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.root.as_slice())?;
        writer.write_all(self.proof.as_slice())?;
        writer.write_all(self.headers.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SendBlockProof::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Time(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Time {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Time {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Time {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "timestamp", self.timestamp())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Time {
    fn default() -> Self {
        let v: Vec<u8> = vec![16, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        Time::new_unchecked(v.into())
    }
}
impl Time {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn timestamp(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Uint64::new_unchecked(self.0.slice(start..end))
        } else {
            Uint64::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TimeReader<'r> {
        TimeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Time {
    type Builder = TimeBuilder;
    const NAME: &'static str = "Time";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Time(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TimeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TimeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().timestamp(self.timestamp())
    }
}
#[derive(Clone, Copy)]
pub struct TimeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TimeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TimeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TimeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "timestamp", self.timestamp())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TimeReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn timestamp(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Uint64Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint64Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TimeReader<'r> {
    type Entity = Time;
    const NAME: &'static str = "TimeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TimeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TimeBuilder {
    pub(crate) timestamp: Uint64,
}
impl TimeBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn timestamp(mut self, v: Uint64) -> Self {
        self.timestamp = v;
        self
    }
}
impl molecule::prelude::Builder for TimeBuilder {
    type Entity = Time;
    const NAME: &'static str = "TimeBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.timestamp.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.timestamp.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.timestamp.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Time::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct RawAlert(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RawAlert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RawAlert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RawAlert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "notice_until", self.notice_until())?;
        write!(f, ", {}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "cancel", self.cancel())?;
        write!(f, ", {}: {}", "priority", self.priority())?;
        write!(f, ", {}: {}", "message", self.message())?;
        write!(f, ", {}: {}", "min_version", self.min_version())?;
        write!(f, ", {}: {}", "max_version", self.max_version())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for RawAlert {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            56, 0, 0, 0, 32, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0,
            0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        RawAlert::new_unchecked(v.into())
    }
}
impl RawAlert {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn notice_until(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn id(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn cancel(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn priority(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn message(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn min_version(&self) -> BytesOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        BytesOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn max_version(&self) -> BytesOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            BytesOpt::new_unchecked(self.0.slice(start..end))
        } else {
            BytesOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> RawAlertReader<'r> {
        RawAlertReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RawAlert {
    type Builder = RawAlertBuilder;
    const NAME: &'static str = "RawAlert";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RawAlert(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RawAlertReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RawAlertReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .notice_until(self.notice_until())
            .id(self.id())
            .cancel(self.cancel())
            .priority(self.priority())
            .message(self.message())
            .min_version(self.min_version())
            .max_version(self.max_version())
    }
}
#[derive(Clone, Copy)]
pub struct RawAlertReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RawAlertReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RawAlertReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RawAlertReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "notice_until", self.notice_until())?;
        write!(f, ", {}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "cancel", self.cancel())?;
        write!(f, ", {}: {}", "priority", self.priority())?;
        write!(f, ", {}: {}", "message", self.message())?;
        write!(f, ", {}: {}", "min_version", self.min_version())?;
        write!(f, ", {}: {}", "max_version", self.max_version())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> RawAlertReader<'r> {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn notice_until(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn id(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn cancel(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn priority(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn message(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn min_version(&self) -> BytesOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        BytesOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn max_version(&self) -> BytesOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            BytesOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for RawAlertReader<'r> {
    type Entity = RawAlert;
    const NAME: &'static str = "RawAlertReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RawAlertReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint32Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        BytesReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        BytesOptReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        BytesOptReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct RawAlertBuilder {
    pub(crate) notice_until: Uint64,
    pub(crate) id: Uint32,
    pub(crate) cancel: Uint32,
    pub(crate) priority: Uint32,
    pub(crate) message: Bytes,
    pub(crate) min_version: BytesOpt,
    pub(crate) max_version: BytesOpt,
}
impl RawAlertBuilder {
    pub const FIELD_COUNT: usize = 7;
    pub fn notice_until(mut self, v: Uint64) -> Self {
        self.notice_until = v;
        self
    }
    pub fn id(mut self, v: Uint32) -> Self {
        self.id = v;
        self
    }
    pub fn cancel(mut self, v: Uint32) -> Self {
        self.cancel = v;
        self
    }
    pub fn priority(mut self, v: Uint32) -> Self {
        self.priority = v;
        self
    }
    pub fn message(mut self, v: Bytes) -> Self {
        self.message = v;
        self
    }
    pub fn min_version(mut self, v: BytesOpt) -> Self {
        self.min_version = v;
        self
    }
    pub fn max_version(mut self, v: BytesOpt) -> Self {
        self.max_version = v;
        self
    }
}
impl molecule::prelude::Builder for RawAlertBuilder {
    type Entity = RawAlert;
    const NAME: &'static str = "RawAlertBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.notice_until.as_slice().len()
            + self.id.as_slice().len()
            + self.cancel.as_slice().len()
            + self.priority.as_slice().len()
            + self.message.as_slice().len()
            + self.min_version.as_slice().len()
            + self.max_version.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.notice_until.as_slice().len();
        offsets.push(total_size);
        total_size += self.id.as_slice().len();
        offsets.push(total_size);
        total_size += self.cancel.as_slice().len();
        offsets.push(total_size);
        total_size += self.priority.as_slice().len();
        offsets.push(total_size);
        total_size += self.message.as_slice().len();
        offsets.push(total_size);
        total_size += self.min_version.as_slice().len();
        offsets.push(total_size);
        total_size += self.max_version.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.notice_until.as_slice())?;
        writer.write_all(self.id.as_slice())?;
        writer.write_all(self.cancel.as_slice())?;
        writer.write_all(self.priority.as_slice())?;
        writer.write_all(self.message.as_slice())?;
        writer.write_all(self.min_version.as_slice())?;
        writer.write_all(self.max_version.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RawAlert::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Alert(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Alert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Alert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Alert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "raw", self.raw())?;
        write!(f, ", {}: {}", "signatures", self.signatures())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Alert {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            72, 0, 0, 0, 12, 0, 0, 0, 68, 0, 0, 0, 56, 0, 0, 0, 32, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0,
            0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
        ];
        Alert::new_unchecked(v.into())
    }
}
impl Alert {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn raw(&self) -> RawAlert {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        RawAlert::new_unchecked(self.0.slice(start..end))
    }
    pub fn signatures(&self) -> BytesVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BytesVec::new_unchecked(self.0.slice(start..end))
        } else {
            BytesVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> AlertReader<'r> {
        AlertReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Alert {
    type Builder = AlertBuilder;
    const NAME: &'static str = "Alert";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Alert(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AlertReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AlertReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .raw(self.raw())
            .signatures(self.signatures())
    }
}
#[derive(Clone, Copy)]
pub struct AlertReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AlertReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AlertReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AlertReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "raw", self.raw())?;
        write!(f, ", {}: {}", "signatures", self.signatures())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> AlertReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn raw(&self) -> RawAlertReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        RawAlertReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn signatures(&self) -> BytesVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BytesVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for AlertReader<'r> {
    type Entity = Alert;
    const NAME: &'static str = "AlertReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AlertReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        RawAlertReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct AlertBuilder {
    pub(crate) raw: RawAlert,
    pub(crate) signatures: BytesVec,
}
impl AlertBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn raw(mut self, v: RawAlert) -> Self {
        self.raw = v;
        self
    }
    pub fn signatures(mut self, v: BytesVec) -> Self {
        self.signatures = v;
        self
    }
}
impl molecule::prelude::Builder for AlertBuilder {
    type Entity = Alert;
    const NAME: &'static str = "AlertBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.raw.as_slice().len()
            + self.signatures.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.raw.as_slice().len();
        offsets.push(total_size);
        total_size += self.signatures.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.raw.as_slice())?;
        writer.write_all(self.signatures.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Alert::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Identify(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Identify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Identify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Identify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "flag", self.flag())?;
        write!(f, ", {}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "client_version", self.client_version())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Identify {
    fn default() -> Self {
        let v: Vec<u8> = vec![
            32, 0, 0, 0, 16, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0,
        ];
        Identify::new_unchecked(v.into())
    }
}
impl Identify {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn flag(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn name(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn client_version(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> IdentifyReader<'r> {
        IdentifyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Identify {
    type Builder = IdentifyBuilder;
    const NAME: &'static str = "Identify";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Identify(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        IdentifyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        IdentifyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .flag(self.flag())
            .name(self.name())
            .client_version(self.client_version())
    }
}
#[derive(Clone, Copy)]
pub struct IdentifyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for IdentifyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for IdentifyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for IdentifyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "flag", self.flag())?;
        write!(f, ", {}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "client_version", self.client_version())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> IdentifyReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn flag(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn name(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn client_version(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for IdentifyReader<'r> {
    type Entity = Identify;
    const NAME: &'static str = "IdentifyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        IdentifyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE && Self::FIELD_COUNT == 0 {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct IdentifyBuilder {
    pub(crate) flag: Uint64,
    pub(crate) name: Bytes,
    pub(crate) client_version: Bytes,
}
impl IdentifyBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn flag(mut self, v: Uint64) -> Self {
        self.flag = v;
        self
    }
    pub fn name(mut self, v: Bytes) -> Self {
        self.name = v;
        self
    }
    pub fn client_version(mut self, v: Bytes) -> Self {
        self.client_version = v;
        self
    }
}
impl molecule::prelude::Builder for IdentifyBuilder {
    type Entity = Identify;
    const NAME: &'static str = "IdentifyBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.flag.as_slice().len()
            + self.name.as_slice().len()
            + self.client_version.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.flag.as_slice().len();
        offsets.push(total_size);
        total_size += self.name.as_slice().len();
        offsets.push(total_size);
        total_size += self.client_version.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.flag.as_slice())?;
        writer.write_all(self.name.as_slice())?;
        writer.write_all(self.client_version.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Identify::new_unchecked(inner.into())
    }
}
