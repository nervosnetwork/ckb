// Generated by Molecule 0.7.5

use super::blockchain::*;
use molecule::prelude::*;
#[derive(Clone)]
pub struct BoolOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BoolOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BoolOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BoolOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for BoolOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BoolOpt::new_unchecked(v)
    }
}
impl BoolOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Bool> {
        if self.is_none() {
            None
        } else {
            Some(Bool::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BoolOptReader<'r> {
        BoolOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BoolOpt {
    type Builder = BoolOptBuilder;
    const NAME: &'static str = "BoolOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BoolOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BoolOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BoolOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct BoolOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BoolOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BoolOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BoolOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> BoolOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<BoolReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(BoolReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BoolOptReader<'r> {
    type Entity = BoolOpt;
    const NAME: &'static str = "BoolOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BoolOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            BoolReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BoolOptBuilder(pub(crate) Option<Bool>);
impl BoolOptBuilder {
    pub fn set(mut self, v: Option<Bool>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for BoolOptBuilder {
    type Entity = BoolOpt;
    const NAME: &'static str = "BoolOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BoolOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Byte32Opt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Byte32Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Byte32Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Byte32Opt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for Byte32Opt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Byte32Opt::new_unchecked(v)
    }
}
impl Byte32Opt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Byte32> {
        if self.is_none() {
            None
        } else {
            Some(Byte32::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> Byte32OptReader<'r> {
        Byte32OptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Byte32Opt {
    type Builder = Byte32OptBuilder;
    const NAME: &'static str = "Byte32Opt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Byte32Opt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte32OptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Byte32OptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct Byte32OptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Byte32OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Byte32OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Byte32OptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> Byte32OptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Byte32Reader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(Byte32Reader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for Byte32OptReader<'r> {
    type Entity = Byte32Opt;
    const NAME: &'static str = "Byte32OptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Byte32OptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            Byte32Reader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct Byte32OptBuilder(pub(crate) Option<Byte32>);
impl Byte32OptBuilder {
    pub fn set(mut self, v: Option<Byte32>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for Byte32OptBuilder {
    type Entity = Byte32Opt;
    const NAME: &'static str = "Byte32OptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Byte32Opt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Bool(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Bool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Bool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Bool {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for Bool {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Bool::new_unchecked(v)
    }
}
impl Bool {
    const DEFAULT_VALUE: [u8; 1] = [0];
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> BoolReader<'r> {
        BoolReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Bool {
    type Builder = BoolBuilder;
    const NAME: &'static str = "Bool";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Bool(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BoolReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BoolReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0()])
    }
}
#[derive(Clone, Copy)]
pub struct BoolReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BoolReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> BoolReader<'r> {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for BoolReader<'r> {
    type Entity = Bool;
    const NAME: &'static str = "BoolReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BoolReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct BoolBuilder(pub(crate) [Byte; 1]);
impl ::core::fmt::Debug for BoolBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for BoolBuilder {
    fn default() -> Self {
        BoolBuilder([Byte::default()])
    }
}
impl BoolBuilder {
    pub const TOTAL_SIZE: usize = 1;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 1;
    pub fn set(mut self, v: [Byte; 1]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
}
impl molecule::prelude::Builder for BoolBuilder {
    type Entity = Bool;
    const NAME: &'static str = "BoolBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Bool::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BeUint32(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BeUint32 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BeUint32 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BeUint32 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for BeUint32 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BeUint32::new_unchecked(v)
    }
}
impl BeUint32 {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> BeUint32Reader<'r> {
        BeUint32Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BeUint32 {
    type Builder = BeUint32Builder;
    const NAME: &'static str = "BeUint32";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BeUint32(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BeUint32Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BeUint32Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([self.nth0(), self.nth1(), self.nth2(), self.nth3()])
    }
}
#[derive(Clone, Copy)]
pub struct BeUint32Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BeUint32Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BeUint32Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BeUint32Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> BeUint32Reader<'r> {
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for BeUint32Reader<'r> {
    type Entity = BeUint32;
    const NAME: &'static str = "BeUint32Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BeUint32Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct BeUint32Builder(pub(crate) [Byte; 4]);
impl ::core::fmt::Debug for BeUint32Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for BeUint32Builder {
    fn default() -> Self {
        BeUint32Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl BeUint32Builder {
    pub const TOTAL_SIZE: usize = 4;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 4;
    pub fn set(mut self, v: [Byte; 4]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
}
impl molecule::prelude::Builder for BeUint32Builder {
    type Entity = BeUint32;
    const NAME: &'static str = "BeUint32Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BeUint32::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BeUint64(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BeUint64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BeUint64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BeUint64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl ::core::default::Default for BeUint64 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BeUint64::new_unchecked(v)
    }
}
impl BeUint64 {
    const DEFAULT_VALUE: [u8; 8] = [0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 8;
    pub fn nth0(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(0..1))
    }
    pub fn nth1(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(1..2))
    }
    pub fn nth2(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(2..3))
    }
    pub fn nth3(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(3..4))
    }
    pub fn nth4(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(4..5))
    }
    pub fn nth5(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(5..6))
    }
    pub fn nth6(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(6..7))
    }
    pub fn nth7(&self) -> Byte {
        Byte::new_unchecked(self.0.slice(7..8))
    }
    pub fn raw_data(&self) -> molecule::bytes::Bytes {
        self.as_bytes()
    }
    pub fn as_reader<'r>(&'r self) -> BeUint64Reader<'r> {
        BeUint64Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BeUint64 {
    type Builder = BeUint64Builder;
    const NAME: &'static str = "BeUint64";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BeUint64(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BeUint64Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BeUint64Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set([
            self.nth0(),
            self.nth1(),
            self.nth2(),
            self.nth3(),
            self.nth4(),
            self.nth5(),
            self.nth6(),
            self.nth7(),
        ])
    }
}
#[derive(Clone, Copy)]
pub struct BeUint64Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BeUint64Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BeUint64Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BeUint64Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        let raw_data = hex_string(&self.raw_data());
        write!(f, "{}(0x{})", Self::NAME, raw_data)
    }
}
impl<'r> BeUint64Reader<'r> {
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 8;
    pub fn nth0(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[0..1])
    }
    pub fn nth1(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[1..2])
    }
    pub fn nth2(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[2..3])
    }
    pub fn nth3(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[3..4])
    }
    pub fn nth4(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[4..5])
    }
    pub fn nth5(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[5..6])
    }
    pub fn nth6(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[6..7])
    }
    pub fn nth7(&self) -> ByteReader<'r> {
        ByteReader::new_unchecked(&self.as_slice()[7..8])
    }
    pub fn raw_data(&self) -> &'r [u8] {
        self.as_slice()
    }
}
impl<'r> molecule::prelude::Reader<'r> for BeUint64Reader<'r> {
    type Entity = BeUint64;
    const NAME: &'static str = "BeUint64Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BeUint64Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
pub struct BeUint64Builder(pub(crate) [Byte; 8]);
impl ::core::fmt::Debug for BeUint64Builder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:?})", Self::NAME, &self.0[..])
    }
}
impl ::core::default::Default for BeUint64Builder {
    fn default() -> Self {
        BeUint64Builder([
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
            Byte::default(),
        ])
    }
}
impl BeUint64Builder {
    pub const TOTAL_SIZE: usize = 8;
    pub const ITEM_SIZE: usize = 1;
    pub const ITEM_COUNT: usize = 8;
    pub fn set(mut self, v: [Byte; 8]) -> Self {
        self.0 = v;
        self
    }
    pub fn nth0(mut self, v: Byte) -> Self {
        self.0[0] = v;
        self
    }
    pub fn nth1(mut self, v: Byte) -> Self {
        self.0[1] = v;
        self
    }
    pub fn nth2(mut self, v: Byte) -> Self {
        self.0[2] = v;
        self
    }
    pub fn nth3(mut self, v: Byte) -> Self {
        self.0[3] = v;
        self
    }
    pub fn nth4(mut self, v: Byte) -> Self {
        self.0[4] = v;
        self
    }
    pub fn nth5(mut self, v: Byte) -> Self {
        self.0[5] = v;
        self
    }
    pub fn nth6(mut self, v: Byte) -> Self {
        self.0[6] = v;
        self
    }
    pub fn nth7(mut self, v: Byte) -> Self {
        self.0[7] = v;
        self
    }
}
impl molecule::prelude::Builder for BeUint64Builder {
    type Entity = BeUint64;
    const NAME: &'static str = "BeUint64Builder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.0[0].as_slice())?;
        writer.write_all(self.0[1].as_slice())?;
        writer.write_all(self.0[2].as_slice())?;
        writer.write_all(self.0[3].as_slice())?;
        writer.write_all(self.0[4].as_slice())?;
        writer.write_all(self.0[5].as_slice())?;
        writer.write_all(self.0[6].as_slice())?;
        writer.write_all(self.0[7].as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BeUint64::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Uint32Vec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Uint32Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Uint32Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Uint32Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for Uint32Vec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Uint32Vec::new_unchecked(v)
    }
}
impl Uint32Vec {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Uint32> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Uint32 {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> Uint32VecReader<'r> {
        Uint32VecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Uint32Vec {
    type Builder = Uint32VecBuilder;
    const NAME: &'static str = "Uint32Vec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Uint32Vec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint32VecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint32VecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct Uint32VecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Uint32VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Uint32VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Uint32VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> Uint32VecReader<'r> {
    pub const ITEM_SIZE: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Uint32Reader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Uint32Reader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Uint32VecReader<'r> {
    type Entity = Uint32Vec;
    const NAME: &'static str = "Uint32VecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Uint32VecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct Uint32VecBuilder(pub(crate) Vec<Uint32>);
impl Uint32VecBuilder {
    pub const ITEM_SIZE: usize = 4;
    pub fn set(mut self, v: Vec<Uint32>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Uint32) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Uint32>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Uint32) -> Option<Uint32> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for Uint32VecBuilder {
    type Entity = Uint32Vec;
    const NAME: &'static str = "Uint32VecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Uint32Vec::new_unchecked(inner.into())
    }
}
pub struct Uint32VecIterator(Uint32Vec, usize, usize);
impl ::core::iter::Iterator for Uint32VecIterator {
    type Item = Uint32;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for Uint32VecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for Uint32Vec {
    type Item = Uint32;
    type IntoIter = Uint32VecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        Uint32VecIterator(self, 0, len)
    }
}
impl<'r> Uint32VecReader<'r> {
    pub fn iter<'t>(&'t self) -> Uint32VecReaderIterator<'t, 'r> {
        Uint32VecReaderIterator(&self, 0, self.len())
    }
}
pub struct Uint32VecReaderIterator<'t, 'r>(&'t Uint32VecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for Uint32VecReaderIterator<'t, 'r> {
    type Item = Uint32Reader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for Uint32VecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Uint64Vec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Uint64Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Uint64Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Uint64Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for Uint64Vec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Uint64Vec::new_unchecked(v)
    }
}
impl Uint64Vec {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Uint64> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Uint64 {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> Uint64VecReader<'r> {
        Uint64VecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Uint64Vec {
    type Builder = Uint64VecBuilder;
    const NAME: &'static str = "Uint64Vec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Uint64Vec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint64VecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint64VecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct Uint64VecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Uint64VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Uint64VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Uint64VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> Uint64VecReader<'r> {
    pub const ITEM_SIZE: usize = 8;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Uint64Reader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Uint64Reader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Uint64VecReader<'r> {
    type Entity = Uint64Vec;
    const NAME: &'static str = "Uint64VecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Uint64VecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct Uint64VecBuilder(pub(crate) Vec<Uint64>);
impl Uint64VecBuilder {
    pub const ITEM_SIZE: usize = 8;
    pub fn set(mut self, v: Vec<Uint64>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Uint64) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Uint64>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Uint64) -> Option<Uint64> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for Uint64VecBuilder {
    type Entity = Uint64Vec;
    const NAME: &'static str = "Uint64VecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Uint64Vec::new_unchecked(inner.into())
    }
}
pub struct Uint64VecIterator(Uint64Vec, usize, usize);
impl ::core::iter::Iterator for Uint64VecIterator {
    type Item = Uint64;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for Uint64VecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for Uint64Vec {
    type Item = Uint64;
    type IntoIter = Uint64VecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        Uint64VecIterator(self, 0, len)
    }
}
impl<'r> Uint64VecReader<'r> {
    pub fn iter<'t>(&'t self) -> Uint64VecReaderIterator<'t, 'r> {
        Uint64VecReaderIterator(&self, 0, self.len())
    }
}
pub struct Uint64VecReaderIterator<'t, 'r>(&'t Uint64VecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for Uint64VecReaderIterator<'t, 'r> {
    type Item = Uint64Reader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for Uint64VecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Uint256Vec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Uint256Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Uint256Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Uint256Vec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for Uint256Vec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Uint256Vec::new_unchecked(v)
    }
}
impl Uint256Vec {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 32;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Uint256> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Uint256 {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Uint256::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> Uint256VecReader<'r> {
        Uint256VecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Uint256Vec {
    type Builder = Uint256VecBuilder;
    const NAME: &'static str = "Uint256Vec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Uint256Vec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint256VecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint256VecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct Uint256VecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Uint256VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Uint256VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Uint256VecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> Uint256VecReader<'r> {
    pub const ITEM_SIZE: usize = 32;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Uint256Reader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Uint256Reader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Uint256Reader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for Uint256VecReader<'r> {
    type Entity = Uint256Vec;
    const NAME: &'static str = "Uint256VecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Uint256VecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct Uint256VecBuilder(pub(crate) Vec<Uint256>);
impl Uint256VecBuilder {
    pub const ITEM_SIZE: usize = 32;
    pub fn set(mut self, v: Vec<Uint256>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Uint256) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Uint256>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Uint256) -> Option<Uint256> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for Uint256VecBuilder {
    type Entity = Uint256Vec;
    const NAME: &'static str = "Uint256VecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Uint256Vec::new_unchecked(inner.into())
    }
}
pub struct Uint256VecIterator(Uint256Vec, usize, usize);
impl ::core::iter::Iterator for Uint256VecIterator {
    type Item = Uint256;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for Uint256VecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for Uint256Vec {
    type Item = Uint256;
    type IntoIter = Uint256VecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        Uint256VecIterator(self, 0, len)
    }
}
impl<'r> Uint256VecReader<'r> {
    pub fn iter<'t>(&'t self) -> Uint256VecReaderIterator<'t, 'r> {
        Uint256VecReaderIterator(&self, 0, self.len())
    }
}
pub struct Uint256VecReaderIterator<'t, 'r>(&'t Uint256VecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for Uint256VecReaderIterator<'t, 'r> {
    type Item = Uint256Reader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for Uint256VecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct CellOutputOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CellOutputOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CellOutputOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CellOutputOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for CellOutputOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        CellOutputOpt::new_unchecked(v)
    }
}
impl CellOutputOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<CellOutput> {
        if self.is_none() {
            None
        } else {
            Some(CellOutput::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CellOutputOptReader<'r> {
        CellOutputOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CellOutputOpt {
    type Builder = CellOutputOptBuilder;
    const NAME: &'static str = "CellOutputOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CellOutputOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CellOutputOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CellOutputOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct CellOutputOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CellOutputOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CellOutputOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CellOutputOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> CellOutputOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<CellOutputReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(CellOutputReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CellOutputOptReader<'r> {
    type Entity = CellOutputOpt;
    const NAME: &'static str = "CellOutputOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CellOutputOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            CellOutputReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CellOutputOptBuilder(pub(crate) Option<CellOutput>);
impl CellOutputOptBuilder {
    pub fn set(mut self, v: Option<CellOutput>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for CellOutputOptBuilder {
    type Entity = CellOutputOpt;
    const NAME: &'static str = "CellOutputOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CellOutputOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct HeaderVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for HeaderVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for HeaderVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for HeaderVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for HeaderVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        HeaderVec::new_unchecked(v)
    }
}
impl HeaderVec {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 208;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<Header> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> Header {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        Header::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> HeaderVecReader<'r> {
        HeaderVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for HeaderVec {
    type Builder = HeaderVecBuilder;
    const NAME: &'static str = "HeaderVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        HeaderVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct HeaderVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for HeaderVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for HeaderVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for HeaderVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> HeaderVecReader<'r> {
    pub const ITEM_SIZE: usize = 208;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<HeaderReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> HeaderReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        HeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for HeaderVecReader<'r> {
    type Entity = HeaderVec;
    const NAME: &'static str = "HeaderVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        HeaderVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct HeaderVecBuilder(pub(crate) Vec<Header>);
impl HeaderVecBuilder {
    pub const ITEM_SIZE: usize = 208;
    pub fn set(mut self, v: Vec<Header>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: Header) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = Header>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: Header) -> Option<Header> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for HeaderVecBuilder {
    type Entity = HeaderVec;
    const NAME: &'static str = "HeaderVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        HeaderVec::new_unchecked(inner.into())
    }
}
pub struct HeaderVecIterator(HeaderVec, usize, usize);
impl ::core::iter::Iterator for HeaderVecIterator {
    type Item = Header;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for HeaderVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for HeaderVec {
    type Item = Header;
    type IntoIter = HeaderVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        HeaderVecIterator(self, 0, len)
    }
}
impl<'r> HeaderVecReader<'r> {
    pub fn iter<'t>(&'t self) -> HeaderVecReaderIterator<'t, 'r> {
        HeaderVecReaderIterator(&self, 0, self.len())
    }
}
pub struct HeaderVecReaderIterator<'t, 'r>(&'t HeaderVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for HeaderVecReaderIterator<'t, 'r> {
    type Item = HeaderReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for HeaderVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct OutPointVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for OutPointVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for OutPointVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for OutPointVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for OutPointVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        OutPointVec::new_unchecked(v)
    }
}
impl OutPointVec {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 36;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<OutPoint> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> OutPoint {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        OutPoint::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> OutPointVecReader<'r> {
        OutPointVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for OutPointVec {
    type Builder = OutPointVecBuilder;
    const NAME: &'static str = "OutPointVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        OutPointVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        OutPointVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        OutPointVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct OutPointVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for OutPointVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for OutPointVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for OutPointVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> OutPointVecReader<'r> {
    pub const ITEM_SIZE: usize = 36;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<OutPointReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> OutPointReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        OutPointReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for OutPointVecReader<'r> {
    type Entity = OutPointVec;
    const NAME: &'static str = "OutPointVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        OutPointVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct OutPointVecBuilder(pub(crate) Vec<OutPoint>);
impl OutPointVecBuilder {
    pub const ITEM_SIZE: usize = 36;
    pub fn set(mut self, v: Vec<OutPoint>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: OutPoint) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = OutPoint>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: OutPoint) -> Option<OutPoint> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for OutPointVecBuilder {
    type Entity = OutPointVec;
    const NAME: &'static str = "OutPointVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        OutPointVec::new_unchecked(inner.into())
    }
}
pub struct OutPointVecIterator(OutPointVec, usize, usize);
impl ::core::iter::Iterator for OutPointVecIterator {
    type Item = OutPoint;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for OutPointVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for OutPointVec {
    type Item = OutPoint;
    type IntoIter = OutPointVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        OutPointVecIterator(self, 0, len)
    }
}
impl<'r> OutPointVecReader<'r> {
    pub fn iter<'t>(&'t self) -> OutPointVecReaderIterator<'t, 'r> {
        OutPointVecReaderIterator(&self, 0, self.len())
    }
}
pub struct OutPointVecReaderIterator<'t, 'r>(&'t OutPointVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for OutPointVecReaderIterator<'t, 'r> {
    type Item = OutPointReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for OutPointVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct Uint64VecOpt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Uint64VecOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Uint64VecOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Uint64VecOpt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl ::core::default::Default for Uint64VecOpt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Uint64VecOpt::new_unchecked(v)
    }
}
impl Uint64VecOpt {
    const DEFAULT_VALUE: [u8; 0] = [];
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Uint64Vec> {
        if self.is_none() {
            None
        } else {
            Some(Uint64Vec::new_unchecked(self.0.clone()))
        }
    }
    pub fn as_reader<'r>(&'r self) -> Uint64VecOptReader<'r> {
        Uint64VecOptReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Uint64VecOpt {
    type Builder = Uint64VecOptBuilder;
    const NAME: &'static str = "Uint64VecOpt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Uint64VecOpt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint64VecOptReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        Uint64VecOptReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_opt())
    }
}
#[derive(Clone, Copy)]
pub struct Uint64VecOptReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for Uint64VecOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for Uint64VecOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for Uint64VecOptReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        if let Some(v) = self.to_opt() {
            write!(f, "{}(Some({}))", Self::NAME, v)
        } else {
            write!(f, "{}(None)", Self::NAME)
        }
    }
}
impl<'r> Uint64VecOptReader<'r> {
    pub fn is_none(&self) -> bool {
        self.0.is_empty()
    }
    pub fn is_some(&self) -> bool {
        !self.0.is_empty()
    }
    pub fn to_opt(&self) -> Option<Uint64VecReader<'r>> {
        if self.is_none() {
            None
        } else {
            Some(Uint64VecReader::new_unchecked(self.as_slice()))
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for Uint64VecOptReader<'r> {
    type Entity = Uint64VecOpt;
    const NAME: &'static str = "Uint64VecOptReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        Uint64VecOptReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        if !slice.is_empty() {
            Uint64VecReader::verify(&slice[..], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct Uint64VecOptBuilder(pub(crate) Option<Uint64Vec>);
impl Uint64VecOptBuilder {
    pub fn set(mut self, v: Option<Uint64Vec>) -> Self {
        self.0 = v;
        self
    }
}
impl molecule::prelude::Builder for Uint64VecOptBuilder {
    type Entity = Uint64VecOpt;
    const NAME: &'static str = "Uint64VecOptBuilder";
    fn expected_length(&self) -> usize {
        self.0
            .as_ref()
            .map(|ref inner| inner.as_slice().len())
            .unwrap_or(0)
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        self.0
            .as_ref()
            .map(|ref inner| writer.write_all(inner.as_slice()))
            .unwrap_or(Ok(()))
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Uint64VecOpt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct HeaderDigest(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for HeaderDigest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for HeaderDigest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for HeaderDigest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "children_hash", self.children_hash())?;
        write!(f, ", {}: {}", "total_difficulty", self.total_difficulty())?;
        write!(f, ", {}: {}", "start_number", self.start_number())?;
        write!(f, ", {}: {}", "end_number", self.end_number())?;
        write!(f, ", {}: {}", "start_epoch", self.start_epoch())?;
        write!(f, ", {}: {}", "end_epoch", self.end_epoch())?;
        write!(f, ", {}: {}", "start_timestamp", self.start_timestamp())?;
        write!(f, ", {}: {}", "end_timestamp", self.end_timestamp())?;
        write!(
            f,
            ", {}: {}",
            "start_compact_target",
            self.start_compact_target()
        )?;
        write!(
            f,
            ", {}: {}",
            "end_compact_target",
            self.end_compact_target()
        )?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for HeaderDigest {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        HeaderDigest::new_unchecked(v)
    }
}
impl HeaderDigest {
    const DEFAULT_VALUE: [u8; 120] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 120;
    pub const FIELD_SIZES: [usize; 10] = [32, 32, 8, 8, 8, 8, 8, 8, 4, 4];
    pub const FIELD_COUNT: usize = 10;
    pub fn children_hash(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(0..32))
    }
    pub fn total_difficulty(&self) -> Uint256 {
        Uint256::new_unchecked(self.0.slice(32..64))
    }
    pub fn start_number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(64..72))
    }
    pub fn end_number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(72..80))
    }
    pub fn start_epoch(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(80..88))
    }
    pub fn end_epoch(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(88..96))
    }
    pub fn start_timestamp(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(96..104))
    }
    pub fn end_timestamp(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(104..112))
    }
    pub fn start_compact_target(&self) -> Uint32 {
        Uint32::new_unchecked(self.0.slice(112..116))
    }
    pub fn end_compact_target(&self) -> Uint32 {
        Uint32::new_unchecked(self.0.slice(116..120))
    }
    pub fn as_reader<'r>(&'r self) -> HeaderDigestReader<'r> {
        HeaderDigestReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for HeaderDigest {
    type Builder = HeaderDigestBuilder;
    const NAME: &'static str = "HeaderDigest";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        HeaderDigest(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderDigestReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderDigestReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .children_hash(self.children_hash())
            .total_difficulty(self.total_difficulty())
            .start_number(self.start_number())
            .end_number(self.end_number())
            .start_epoch(self.start_epoch())
            .end_epoch(self.end_epoch())
            .start_timestamp(self.start_timestamp())
            .end_timestamp(self.end_timestamp())
            .start_compact_target(self.start_compact_target())
            .end_compact_target(self.end_compact_target())
    }
}
#[derive(Clone, Copy)]
pub struct HeaderDigestReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for HeaderDigestReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for HeaderDigestReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for HeaderDigestReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "children_hash", self.children_hash())?;
        write!(f, ", {}: {}", "total_difficulty", self.total_difficulty())?;
        write!(f, ", {}: {}", "start_number", self.start_number())?;
        write!(f, ", {}: {}", "end_number", self.end_number())?;
        write!(f, ", {}: {}", "start_epoch", self.start_epoch())?;
        write!(f, ", {}: {}", "end_epoch", self.end_epoch())?;
        write!(f, ", {}: {}", "start_timestamp", self.start_timestamp())?;
        write!(f, ", {}: {}", "end_timestamp", self.end_timestamp())?;
        write!(
            f,
            ", {}: {}",
            "start_compact_target",
            self.start_compact_target()
        )?;
        write!(
            f,
            ", {}: {}",
            "end_compact_target",
            self.end_compact_target()
        )?;
        write!(f, " }}")
    }
}
impl<'r> HeaderDigestReader<'r> {
    pub const TOTAL_SIZE: usize = 120;
    pub const FIELD_SIZES: [usize; 10] = [32, 32, 8, 8, 8, 8, 8, 8, 4, 4];
    pub const FIELD_COUNT: usize = 10;
    pub fn children_hash(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[0..32])
    }
    pub fn total_difficulty(&self) -> Uint256Reader<'r> {
        Uint256Reader::new_unchecked(&self.as_slice()[32..64])
    }
    pub fn start_number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[64..72])
    }
    pub fn end_number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[72..80])
    }
    pub fn start_epoch(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[80..88])
    }
    pub fn end_epoch(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[88..96])
    }
    pub fn start_timestamp(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[96..104])
    }
    pub fn end_timestamp(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[104..112])
    }
    pub fn start_compact_target(&self) -> Uint32Reader<'r> {
        Uint32Reader::new_unchecked(&self.as_slice()[112..116])
    }
    pub fn end_compact_target(&self) -> Uint32Reader<'r> {
        Uint32Reader::new_unchecked(&self.as_slice()[116..120])
    }
}
impl<'r> molecule::prelude::Reader<'r> for HeaderDigestReader<'r> {
    type Entity = HeaderDigest;
    const NAME: &'static str = "HeaderDigestReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        HeaderDigestReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct HeaderDigestBuilder {
    pub(crate) children_hash: Byte32,
    pub(crate) total_difficulty: Uint256,
    pub(crate) start_number: Uint64,
    pub(crate) end_number: Uint64,
    pub(crate) start_epoch: Uint64,
    pub(crate) end_epoch: Uint64,
    pub(crate) start_timestamp: Uint64,
    pub(crate) end_timestamp: Uint64,
    pub(crate) start_compact_target: Uint32,
    pub(crate) end_compact_target: Uint32,
}
impl HeaderDigestBuilder {
    pub const TOTAL_SIZE: usize = 120;
    pub const FIELD_SIZES: [usize; 10] = [32, 32, 8, 8, 8, 8, 8, 8, 4, 4];
    pub const FIELD_COUNT: usize = 10;
    pub fn children_hash(mut self, v: Byte32) -> Self {
        self.children_hash = v;
        self
    }
    pub fn total_difficulty(mut self, v: Uint256) -> Self {
        self.total_difficulty = v;
        self
    }
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
    pub fn end_number(mut self, v: Uint64) -> Self {
        self.end_number = v;
        self
    }
    pub fn start_epoch(mut self, v: Uint64) -> Self {
        self.start_epoch = v;
        self
    }
    pub fn end_epoch(mut self, v: Uint64) -> Self {
        self.end_epoch = v;
        self
    }
    pub fn start_timestamp(mut self, v: Uint64) -> Self {
        self.start_timestamp = v;
        self
    }
    pub fn end_timestamp(mut self, v: Uint64) -> Self {
        self.end_timestamp = v;
        self
    }
    pub fn start_compact_target(mut self, v: Uint32) -> Self {
        self.start_compact_target = v;
        self
    }
    pub fn end_compact_target(mut self, v: Uint32) -> Self {
        self.end_compact_target = v;
        self
    }
}
impl molecule::prelude::Builder for HeaderDigestBuilder {
    type Entity = HeaderDigest;
    const NAME: &'static str = "HeaderDigestBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.children_hash.as_slice())?;
        writer.write_all(self.total_difficulty.as_slice())?;
        writer.write_all(self.start_number.as_slice())?;
        writer.write_all(self.end_number.as_slice())?;
        writer.write_all(self.start_epoch.as_slice())?;
        writer.write_all(self.end_epoch.as_slice())?;
        writer.write_all(self.start_timestamp.as_slice())?;
        writer.write_all(self.end_timestamp.as_slice())?;
        writer.write_all(self.start_compact_target.as_slice())?;
        writer.write_all(self.end_compact_target.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        HeaderDigest::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct HeaderView(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for HeaderView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for HeaderView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for HeaderView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash", self.hash())?;
        write!(f, ", {}: {}", "data", self.data())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for HeaderView {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        HeaderView::new_unchecked(v)
    }
}
impl HeaderView {
    const DEFAULT_VALUE: [u8; 240] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 240;
    pub const FIELD_SIZES: [usize; 2] = [32, 208];
    pub const FIELD_COUNT: usize = 2;
    pub fn hash(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(0..32))
    }
    pub fn data(&self) -> Header {
        Header::new_unchecked(self.0.slice(32..240))
    }
    pub fn as_reader<'r>(&'r self) -> HeaderViewReader<'r> {
        HeaderViewReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for HeaderView {
    type Builder = HeaderViewBuilder;
    const NAME: &'static str = "HeaderView";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        HeaderView(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderViewReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderViewReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().hash(self.hash()).data(self.data())
    }
}
#[derive(Clone, Copy)]
pub struct HeaderViewReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for HeaderViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for HeaderViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for HeaderViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash", self.hash())?;
        write!(f, ", {}: {}", "data", self.data())?;
        write!(f, " }}")
    }
}
impl<'r> HeaderViewReader<'r> {
    pub const TOTAL_SIZE: usize = 240;
    pub const FIELD_SIZES: [usize; 2] = [32, 208];
    pub const FIELD_COUNT: usize = 2;
    pub fn hash(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[0..32])
    }
    pub fn data(&self) -> HeaderReader<'r> {
        HeaderReader::new_unchecked(&self.as_slice()[32..240])
    }
}
impl<'r> molecule::prelude::Reader<'r> for HeaderViewReader<'r> {
    type Entity = HeaderView;
    const NAME: &'static str = "HeaderViewReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        HeaderViewReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct HeaderViewBuilder {
    pub(crate) hash: Byte32,
    pub(crate) data: Header,
}
impl HeaderViewBuilder {
    pub const TOTAL_SIZE: usize = 240;
    pub const FIELD_SIZES: [usize; 2] = [32, 208];
    pub const FIELD_COUNT: usize = 2;
    pub fn hash(mut self, v: Byte32) -> Self {
        self.hash = v;
        self
    }
    pub fn data(mut self, v: Header) -> Self {
        self.data = v;
        self
    }
}
impl molecule::prelude::Builder for HeaderViewBuilder {
    type Entity = HeaderView;
    const NAME: &'static str = "HeaderViewBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.hash.as_slice())?;
        writer.write_all(self.data.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        HeaderView::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct UncleBlockVecView(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for UncleBlockVecView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for UncleBlockVecView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for UncleBlockVecView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hashes", self.hashes())?;
        write!(f, ", {}: {}", "data", self.data())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for UncleBlockVecView {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        UncleBlockVecView::new_unchecked(v)
    }
}
impl UncleBlockVecView {
    const DEFAULT_VALUE: [u8; 20] = [
        20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn data(&self) -> UncleBlockVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            UncleBlockVec::new_unchecked(self.0.slice(start..end))
        } else {
            UncleBlockVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> UncleBlockVecViewReader<'r> {
        UncleBlockVecViewReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for UncleBlockVecView {
    type Builder = UncleBlockVecViewBuilder;
    const NAME: &'static str = "UncleBlockVecView";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        UncleBlockVecView(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UncleBlockVecViewReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        UncleBlockVecViewReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().hashes(self.hashes()).data(self.data())
    }
}
#[derive(Clone, Copy)]
pub struct UncleBlockVecViewReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for UncleBlockVecViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for UncleBlockVecViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for UncleBlockVecViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hashes", self.hashes())?;
        write!(f, ", {}: {}", "data", self.data())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> UncleBlockVecViewReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn data(&self) -> UncleBlockVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            UncleBlockVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            UncleBlockVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for UncleBlockVecViewReader<'r> {
    type Entity = UncleBlockVecView;
    const NAME: &'static str = "UncleBlockVecViewReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        UncleBlockVecViewReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32VecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        UncleBlockVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct UncleBlockVecViewBuilder {
    pub(crate) hashes: Byte32Vec,
    pub(crate) data: UncleBlockVec,
}
impl UncleBlockVecViewBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn hashes(mut self, v: Byte32Vec) -> Self {
        self.hashes = v;
        self
    }
    pub fn data(mut self, v: UncleBlockVec) -> Self {
        self.data = v;
        self
    }
}
impl molecule::prelude::Builder for UncleBlockVecViewBuilder {
    type Entity = UncleBlockVecView;
    const NAME: &'static str = "UncleBlockVecViewBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.hashes.as_slice().len()
            + self.data.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.hashes.as_slice().len();
        offsets.push(total_size);
        total_size += self.data.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.hashes.as_slice())?;
        writer.write_all(self.data.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        UncleBlockVecView::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransactionView(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransactionView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransactionView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransactionView {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash", self.hash())?;
        write!(f, ", {}: {}", "witness_hash", self.witness_hash())?;
        write!(f, ", {}: {}", "data", self.data())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransactionView {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TransactionView::new_unchecked(v)
    }
}
impl TransactionView {
    const DEFAULT_VALUE: [u8; 148] = [
        148, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 0, 0, 12, 0, 0, 0,
        64, 0, 0, 0, 52, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0,
        48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0,
        0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn witness_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn data(&self) -> Transaction {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Transaction::new_unchecked(self.0.slice(start..end))
        } else {
            Transaction::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TransactionViewReader<'r> {
        TransactionViewReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransactionView {
    type Builder = TransactionViewBuilder;
    const NAME: &'static str = "TransactionView";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransactionView(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionViewReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionViewReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .hash(self.hash())
            .witness_hash(self.witness_hash())
            .data(self.data())
    }
}
#[derive(Clone, Copy)]
pub struct TransactionViewReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransactionViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransactionViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransactionViewReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash", self.hash())?;
        write!(f, ", {}: {}", "witness_hash", self.witness_hash())?;
        write!(f, ", {}: {}", "data", self.data())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TransactionViewReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn witness_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn data(&self) -> TransactionReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            TransactionReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            TransactionReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransactionViewReader<'r> {
    type Entity = TransactionView;
    const NAME: &'static str = "TransactionViewReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransactionViewReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        TransactionReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TransactionViewBuilder {
    pub(crate) hash: Byte32,
    pub(crate) witness_hash: Byte32,
    pub(crate) data: Transaction,
}
impl TransactionViewBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn hash(mut self, v: Byte32) -> Self {
        self.hash = v;
        self
    }
    pub fn witness_hash(mut self, v: Byte32) -> Self {
        self.witness_hash = v;
        self
    }
    pub fn data(mut self, v: Transaction) -> Self {
        self.data = v;
        self
    }
}
impl molecule::prelude::Builder for TransactionViewBuilder {
    type Entity = TransactionView;
    const NAME: &'static str = "TransactionViewBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.hash.as_slice().len()
            + self.witness_hash.as_slice().len()
            + self.data.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.witness_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.data.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.hash.as_slice())?;
        writer.write_all(self.witness_hash.as_slice())?;
        writer.write_all(self.data.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransactionView::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlockExt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockExt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockExt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockExt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "total_difficulty", self.total_difficulty())?;
        write!(
            f,
            ", {}: {}",
            "total_uncles_count",
            self.total_uncles_count()
        )?;
        write!(f, ", {}: {}", "received_at", self.received_at())?;
        write!(f, ", {}: {}", "txs_fees", self.txs_fees())?;
        write!(f, ", {}: {}", "verified", self.verified())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BlockExt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BlockExt::new_unchecked(v)
    }
}
impl BlockExt {
    const DEFAULT_VALUE: [u8; 76] = [
        76, 0, 0, 0, 24, 0, 0, 0, 56, 0, 0, 0, 64, 0, 0, 0, 72, 0, 0, 0, 76, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn total_difficulty(&self) -> Uint256 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint256::new_unchecked(self.0.slice(start..end))
    }
    pub fn total_uncles_count(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn received_at(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn txs_fees(&self) -> Uint64Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn verified(&self) -> BoolOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            BoolOpt::new_unchecked(self.0.slice(start..end))
        } else {
            BoolOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockExtReader<'r> {
        BlockExtReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockExt {
    type Builder = BlockExtBuilder;
    const NAME: &'static str = "BlockExt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockExt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockExtReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockExtReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .total_difficulty(self.total_difficulty())
            .total_uncles_count(self.total_uncles_count())
            .received_at(self.received_at())
            .txs_fees(self.txs_fees())
            .verified(self.verified())
    }
}
#[derive(Clone, Copy)]
pub struct BlockExtReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockExtReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockExtReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockExtReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "total_difficulty", self.total_difficulty())?;
        write!(
            f,
            ", {}: {}",
            "total_uncles_count",
            self.total_uncles_count()
        )?;
        write!(f, ", {}: {}", "received_at", self.received_at())?;
        write!(f, ", {}: {}", "txs_fees", self.txs_fees())?;
        write!(f, ", {}: {}", "verified", self.verified())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BlockExtReader<'r> {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn total_difficulty(&self) -> Uint256Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint256Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn total_uncles_count(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn received_at(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn txs_fees(&self) -> Uint64VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn verified(&self) -> BoolOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            BoolOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BoolOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockExtReader<'r> {
    type Entity = BlockExt;
    const NAME: &'static str = "BlockExtReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockExtReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint256Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint64Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint64VecReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        BoolOptReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockExtBuilder {
    pub(crate) total_difficulty: Uint256,
    pub(crate) total_uncles_count: Uint64,
    pub(crate) received_at: Uint64,
    pub(crate) txs_fees: Uint64Vec,
    pub(crate) verified: BoolOpt,
}
impl BlockExtBuilder {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_difficulty(mut self, v: Uint256) -> Self {
        self.total_difficulty = v;
        self
    }
    pub fn total_uncles_count(mut self, v: Uint64) -> Self {
        self.total_uncles_count = v;
        self
    }
    pub fn received_at(mut self, v: Uint64) -> Self {
        self.received_at = v;
        self
    }
    pub fn txs_fees(mut self, v: Uint64Vec) -> Self {
        self.txs_fees = v;
        self
    }
    pub fn verified(mut self, v: BoolOpt) -> Self {
        self.verified = v;
        self
    }
}
impl molecule::prelude::Builder for BlockExtBuilder {
    type Entity = BlockExt;
    const NAME: &'static str = "BlockExtBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.total_difficulty.as_slice().len()
            + self.total_uncles_count.as_slice().len()
            + self.received_at.as_slice().len()
            + self.txs_fees.as_slice().len()
            + self.verified.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.total_difficulty.as_slice().len();
        offsets.push(total_size);
        total_size += self.total_uncles_count.as_slice().len();
        offsets.push(total_size);
        total_size += self.received_at.as_slice().len();
        offsets.push(total_size);
        total_size += self.txs_fees.as_slice().len();
        offsets.push(total_size);
        total_size += self.verified.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.total_difficulty.as_slice())?;
        writer.write_all(self.total_uncles_count.as_slice())?;
        writer.write_all(self.received_at.as_slice())?;
        writer.write_all(self.txs_fees.as_slice())?;
        writer.write_all(self.verified.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockExt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlockExtV1(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockExtV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockExtV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockExtV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "total_difficulty", self.total_difficulty())?;
        write!(
            f,
            ", {}: {}",
            "total_uncles_count",
            self.total_uncles_count()
        )?;
        write!(f, ", {}: {}", "received_at", self.received_at())?;
        write!(f, ", {}: {}", "txs_fees", self.txs_fees())?;
        write!(f, ", {}: {}", "verified", self.verified())?;
        write!(f, ", {}: {}", "cycles", self.cycles())?;
        write!(f, ", {}: {}", "txs_sizes", self.txs_sizes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BlockExtV1 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BlockExtV1::new_unchecked(v)
    }
}
impl BlockExtV1 {
    const DEFAULT_VALUE: [u8; 84] = [
        84, 0, 0, 0, 32, 0, 0, 0, 64, 0, 0, 0, 72, 0, 0, 0, 80, 0, 0, 0, 84, 0, 0, 0, 84, 0, 0, 0,
        84, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn total_difficulty(&self) -> Uint256 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint256::new_unchecked(self.0.slice(start..end))
    }
    pub fn total_uncles_count(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn received_at(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn txs_fees(&self) -> Uint64Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn verified(&self) -> BoolOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        BoolOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn cycles(&self) -> Uint64VecOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint64VecOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn txs_sizes(&self) -> Uint64VecOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            Uint64VecOpt::new_unchecked(self.0.slice(start..end))
        } else {
            Uint64VecOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockExtV1Reader<'r> {
        BlockExtV1Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockExtV1 {
    type Builder = BlockExtV1Builder;
    const NAME: &'static str = "BlockExtV1";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockExtV1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockExtV1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockExtV1Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .total_difficulty(self.total_difficulty())
            .total_uncles_count(self.total_uncles_count())
            .received_at(self.received_at())
            .txs_fees(self.txs_fees())
            .verified(self.verified())
            .cycles(self.cycles())
            .txs_sizes(self.txs_sizes())
    }
}
#[derive(Clone, Copy)]
pub struct BlockExtV1Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockExtV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockExtV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockExtV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "total_difficulty", self.total_difficulty())?;
        write!(
            f,
            ", {}: {}",
            "total_uncles_count",
            self.total_uncles_count()
        )?;
        write!(f, ", {}: {}", "received_at", self.received_at())?;
        write!(f, ", {}: {}", "txs_fees", self.txs_fees())?;
        write!(f, ", {}: {}", "verified", self.verified())?;
        write!(f, ", {}: {}", "cycles", self.cycles())?;
        write!(f, ", {}: {}", "txs_sizes", self.txs_sizes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BlockExtV1Reader<'r> {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn total_difficulty(&self) -> Uint256Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint256Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn total_uncles_count(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn received_at(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn txs_fees(&self) -> Uint64VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn verified(&self) -> BoolOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        BoolOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn cycles(&self) -> Uint64VecOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        Uint64VecOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn txs_sizes(&self) -> Uint64VecOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            Uint64VecOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint64VecOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockExtV1Reader<'r> {
    type Entity = BlockExtV1;
    const NAME: &'static str = "BlockExtV1Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockExtV1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint256Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint64Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint64Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint64VecReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        BoolOptReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Uint64VecOptReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Uint64VecOptReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockExtV1Builder {
    pub(crate) total_difficulty: Uint256,
    pub(crate) total_uncles_count: Uint64,
    pub(crate) received_at: Uint64,
    pub(crate) txs_fees: Uint64Vec,
    pub(crate) verified: BoolOpt,
    pub(crate) cycles: Uint64VecOpt,
    pub(crate) txs_sizes: Uint64VecOpt,
}
impl BlockExtV1Builder {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_difficulty(mut self, v: Uint256) -> Self {
        self.total_difficulty = v;
        self
    }
    pub fn total_uncles_count(mut self, v: Uint64) -> Self {
        self.total_uncles_count = v;
        self
    }
    pub fn received_at(mut self, v: Uint64) -> Self {
        self.received_at = v;
        self
    }
    pub fn txs_fees(mut self, v: Uint64Vec) -> Self {
        self.txs_fees = v;
        self
    }
    pub fn verified(mut self, v: BoolOpt) -> Self {
        self.verified = v;
        self
    }
    pub fn cycles(mut self, v: Uint64VecOpt) -> Self {
        self.cycles = v;
        self
    }
    pub fn txs_sizes(mut self, v: Uint64VecOpt) -> Self {
        self.txs_sizes = v;
        self
    }
}
impl molecule::prelude::Builder for BlockExtV1Builder {
    type Entity = BlockExtV1;
    const NAME: &'static str = "BlockExtV1Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.total_difficulty.as_slice().len()
            + self.total_uncles_count.as_slice().len()
            + self.received_at.as_slice().len()
            + self.txs_fees.as_slice().len()
            + self.verified.as_slice().len()
            + self.cycles.as_slice().len()
            + self.txs_sizes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.total_difficulty.as_slice().len();
        offsets.push(total_size);
        total_size += self.total_uncles_count.as_slice().len();
        offsets.push(total_size);
        total_size += self.received_at.as_slice().len();
        offsets.push(total_size);
        total_size += self.txs_fees.as_slice().len();
        offsets.push(total_size);
        total_size += self.verified.as_slice().len();
        offsets.push(total_size);
        total_size += self.cycles.as_slice().len();
        offsets.push(total_size);
        total_size += self.txs_sizes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.total_difficulty.as_slice())?;
        writer.write_all(self.total_uncles_count.as_slice())?;
        writer.write_all(self.received_at.as_slice())?;
        writer.write_all(self.txs_fees.as_slice())?;
        writer.write_all(self.verified.as_slice())?;
        writer.write_all(self.cycles.as_slice())?;
        writer.write_all(self.txs_sizes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockExtV1::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct EpochExt(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for EpochExt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for EpochExt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for EpochExt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(
            f,
            "{}: {}",
            "previous_epoch_hash_rate",
            self.previous_epoch_hash_rate()
        )?;
        write!(
            f,
            ", {}: {}",
            "last_block_hash_in_previous_epoch",
            self.last_block_hash_in_previous_epoch()
        )?;
        write!(f, ", {}: {}", "compact_target", self.compact_target())?;
        write!(f, ", {}: {}", "number", self.number())?;
        write!(f, ", {}: {}", "base_block_reward", self.base_block_reward())?;
        write!(f, ", {}: {}", "remainder_reward", self.remainder_reward())?;
        write!(f, ", {}: {}", "start_number", self.start_number())?;
        write!(f, ", {}: {}", "length", self.length())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for EpochExt {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        EpochExt::new_unchecked(v)
    }
}
impl EpochExt {
    const DEFAULT_VALUE: [u8; 108] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 108;
    pub const FIELD_SIZES: [usize; 8] = [32, 32, 4, 8, 8, 8, 8, 8];
    pub const FIELD_COUNT: usize = 8;
    pub fn previous_epoch_hash_rate(&self) -> Uint256 {
        Uint256::new_unchecked(self.0.slice(0..32))
    }
    pub fn last_block_hash_in_previous_epoch(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(32..64))
    }
    pub fn compact_target(&self) -> Uint32 {
        Uint32::new_unchecked(self.0.slice(64..68))
    }
    pub fn number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(68..76))
    }
    pub fn base_block_reward(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(76..84))
    }
    pub fn remainder_reward(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(84..92))
    }
    pub fn start_number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(92..100))
    }
    pub fn length(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(100..108))
    }
    pub fn as_reader<'r>(&'r self) -> EpochExtReader<'r> {
        EpochExtReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for EpochExt {
    type Builder = EpochExtBuilder;
    const NAME: &'static str = "EpochExt";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        EpochExt(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        EpochExtReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        EpochExtReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .previous_epoch_hash_rate(self.previous_epoch_hash_rate())
            .last_block_hash_in_previous_epoch(self.last_block_hash_in_previous_epoch())
            .compact_target(self.compact_target())
            .number(self.number())
            .base_block_reward(self.base_block_reward())
            .remainder_reward(self.remainder_reward())
            .start_number(self.start_number())
            .length(self.length())
    }
}
#[derive(Clone, Copy)]
pub struct EpochExtReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for EpochExtReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for EpochExtReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for EpochExtReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(
            f,
            "{}: {}",
            "previous_epoch_hash_rate",
            self.previous_epoch_hash_rate()
        )?;
        write!(
            f,
            ", {}: {}",
            "last_block_hash_in_previous_epoch",
            self.last_block_hash_in_previous_epoch()
        )?;
        write!(f, ", {}: {}", "compact_target", self.compact_target())?;
        write!(f, ", {}: {}", "number", self.number())?;
        write!(f, ", {}: {}", "base_block_reward", self.base_block_reward())?;
        write!(f, ", {}: {}", "remainder_reward", self.remainder_reward())?;
        write!(f, ", {}: {}", "start_number", self.start_number())?;
        write!(f, ", {}: {}", "length", self.length())?;
        write!(f, " }}")
    }
}
impl<'r> EpochExtReader<'r> {
    pub const TOTAL_SIZE: usize = 108;
    pub const FIELD_SIZES: [usize; 8] = [32, 32, 4, 8, 8, 8, 8, 8];
    pub const FIELD_COUNT: usize = 8;
    pub fn previous_epoch_hash_rate(&self) -> Uint256Reader<'r> {
        Uint256Reader::new_unchecked(&self.as_slice()[0..32])
    }
    pub fn last_block_hash_in_previous_epoch(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[32..64])
    }
    pub fn compact_target(&self) -> Uint32Reader<'r> {
        Uint32Reader::new_unchecked(&self.as_slice()[64..68])
    }
    pub fn number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[68..76])
    }
    pub fn base_block_reward(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[76..84])
    }
    pub fn remainder_reward(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[84..92])
    }
    pub fn start_number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[92..100])
    }
    pub fn length(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[100..108])
    }
}
impl<'r> molecule::prelude::Reader<'r> for EpochExtReader<'r> {
    type Entity = EpochExt;
    const NAME: &'static str = "EpochExtReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        EpochExtReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct EpochExtBuilder {
    pub(crate) previous_epoch_hash_rate: Uint256,
    pub(crate) last_block_hash_in_previous_epoch: Byte32,
    pub(crate) compact_target: Uint32,
    pub(crate) number: Uint64,
    pub(crate) base_block_reward: Uint64,
    pub(crate) remainder_reward: Uint64,
    pub(crate) start_number: Uint64,
    pub(crate) length: Uint64,
}
impl EpochExtBuilder {
    pub const TOTAL_SIZE: usize = 108;
    pub const FIELD_SIZES: [usize; 8] = [32, 32, 4, 8, 8, 8, 8, 8];
    pub const FIELD_COUNT: usize = 8;
    pub fn previous_epoch_hash_rate(mut self, v: Uint256) -> Self {
        self.previous_epoch_hash_rate = v;
        self
    }
    pub fn last_block_hash_in_previous_epoch(mut self, v: Byte32) -> Self {
        self.last_block_hash_in_previous_epoch = v;
        self
    }
    pub fn compact_target(mut self, v: Uint32) -> Self {
        self.compact_target = v;
        self
    }
    pub fn number(mut self, v: Uint64) -> Self {
        self.number = v;
        self
    }
    pub fn base_block_reward(mut self, v: Uint64) -> Self {
        self.base_block_reward = v;
        self
    }
    pub fn remainder_reward(mut self, v: Uint64) -> Self {
        self.remainder_reward = v;
        self
    }
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
    pub fn length(mut self, v: Uint64) -> Self {
        self.length = v;
        self
    }
}
impl molecule::prelude::Builder for EpochExtBuilder {
    type Entity = EpochExt;
    const NAME: &'static str = "EpochExtBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.previous_epoch_hash_rate.as_slice())?;
        writer.write_all(self.last_block_hash_in_previous_epoch.as_slice())?;
        writer.write_all(self.compact_target.as_slice())?;
        writer.write_all(self.number.as_slice())?;
        writer.write_all(self.base_block_reward.as_slice())?;
        writer.write_all(self.remainder_reward.as_slice())?;
        writer.write_all(self.start_number.as_slice())?;
        writer.write_all(self.length.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        EpochExt::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransactionKey(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransactionKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransactionKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransactionKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_number", self.block_number())?;
        write!(f, ", {}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "index", self.index())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransactionKey {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TransactionKey::new_unchecked(v)
    }
}
impl TransactionKey {
    const DEFAULT_VALUE: [u8; 44] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 44;
    pub const FIELD_SIZES: [usize; 3] = [8, 32, 4];
    pub const FIELD_COUNT: usize = 3;
    pub fn block_number(&self) -> BeUint64 {
        BeUint64::new_unchecked(self.0.slice(0..8))
    }
    pub fn block_hash(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(8..40))
    }
    pub fn index(&self) -> BeUint32 {
        BeUint32::new_unchecked(self.0.slice(40..44))
    }
    pub fn as_reader<'r>(&'r self) -> TransactionKeyReader<'r> {
        TransactionKeyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransactionKey {
    type Builder = TransactionKeyBuilder;
    const NAME: &'static str = "TransactionKey";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransactionKey(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionKeyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionKeyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .block_number(self.block_number())
            .block_hash(self.block_hash())
            .index(self.index())
    }
}
#[derive(Clone, Copy)]
pub struct TransactionKeyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransactionKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransactionKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransactionKeyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_number", self.block_number())?;
        write!(f, ", {}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "index", self.index())?;
        write!(f, " }}")
    }
}
impl<'r> TransactionKeyReader<'r> {
    pub const TOTAL_SIZE: usize = 44;
    pub const FIELD_SIZES: [usize; 3] = [8, 32, 4];
    pub const FIELD_COUNT: usize = 3;
    pub fn block_number(&self) -> BeUint64Reader<'r> {
        BeUint64Reader::new_unchecked(&self.as_slice()[0..8])
    }
    pub fn block_hash(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[8..40])
    }
    pub fn index(&self) -> BeUint32Reader<'r> {
        BeUint32Reader::new_unchecked(&self.as_slice()[40..44])
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransactionKeyReader<'r> {
    type Entity = TransactionKey;
    const NAME: &'static str = "TransactionKeyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransactionKeyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TransactionKeyBuilder {
    pub(crate) block_number: BeUint64,
    pub(crate) block_hash: Byte32,
    pub(crate) index: BeUint32,
}
impl TransactionKeyBuilder {
    pub const TOTAL_SIZE: usize = 44;
    pub const FIELD_SIZES: [usize; 3] = [8, 32, 4];
    pub const FIELD_COUNT: usize = 3;
    pub fn block_number(mut self, v: BeUint64) -> Self {
        self.block_number = v;
        self
    }
    pub fn block_hash(mut self, v: Byte32) -> Self {
        self.block_hash = v;
        self
    }
    pub fn index(mut self, v: BeUint32) -> Self {
        self.index = v;
        self
    }
}
impl molecule::prelude::Builder for TransactionKeyBuilder {
    type Entity = TransactionKey;
    const NAME: &'static str = "TransactionKeyBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.block_number.as_slice())?;
        writer.write_all(self.block_hash.as_slice())?;
        writer.write_all(self.index.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransactionKey::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct NumberHash(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for NumberHash {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for NumberHash {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for NumberHash {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "number", self.number())?;
        write!(f, ", {}: {}", "block_hash", self.block_hash())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for NumberHash {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        NumberHash::new_unchecked(v)
    }
}
impl NumberHash {
    const DEFAULT_VALUE: [u8; 40] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 40;
    pub const FIELD_SIZES: [usize; 2] = [8, 32];
    pub const FIELD_COUNT: usize = 2;
    pub fn number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(0..8))
    }
    pub fn block_hash(&self) -> Byte32 {
        Byte32::new_unchecked(self.0.slice(8..40))
    }
    pub fn as_reader<'r>(&'r self) -> NumberHashReader<'r> {
        NumberHashReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for NumberHash {
    type Builder = NumberHashBuilder;
    const NAME: &'static str = "NumberHash";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        NumberHash(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberHashReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        NumberHashReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .number(self.number())
            .block_hash(self.block_hash())
    }
}
#[derive(Clone, Copy)]
pub struct NumberHashReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for NumberHashReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for NumberHashReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for NumberHashReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "number", self.number())?;
        write!(f, ", {}: {}", "block_hash", self.block_hash())?;
        write!(f, " }}")
    }
}
impl<'r> NumberHashReader<'r> {
    pub const TOTAL_SIZE: usize = 40;
    pub const FIELD_SIZES: [usize; 2] = [8, 32];
    pub const FIELD_COUNT: usize = 2;
    pub fn number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[0..8])
    }
    pub fn block_hash(&self) -> Byte32Reader<'r> {
        Byte32Reader::new_unchecked(&self.as_slice()[8..40])
    }
}
impl<'r> molecule::prelude::Reader<'r> for NumberHashReader<'r> {
    type Entity = NumberHash;
    const NAME: &'static str = "NumberHashReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        NumberHashReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct NumberHashBuilder {
    pub(crate) number: Uint64,
    pub(crate) block_hash: Byte32,
}
impl NumberHashBuilder {
    pub const TOTAL_SIZE: usize = 40;
    pub const FIELD_SIZES: [usize; 2] = [8, 32];
    pub const FIELD_COUNT: usize = 2;
    pub fn number(mut self, v: Uint64) -> Self {
        self.number = v;
        self
    }
    pub fn block_hash(mut self, v: Byte32) -> Self {
        self.block_hash = v;
        self
    }
}
impl molecule::prelude::Builder for NumberHashBuilder {
    type Entity = NumberHash;
    const NAME: &'static str = "NumberHashBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.number.as_slice())?;
        writer.write_all(self.block_hash.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        NumberHash::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct TransactionInfo(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for TransactionInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for TransactionInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for TransactionInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_number", self.block_number())?;
        write!(f, ", {}: {}", "block_epoch", self.block_epoch())?;
        write!(f, ", {}: {}", "key", self.key())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for TransactionInfo {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        TransactionInfo::new_unchecked(v)
    }
}
impl TransactionInfo {
    const DEFAULT_VALUE: [u8; 60] = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const TOTAL_SIZE: usize = 60;
    pub const FIELD_SIZES: [usize; 3] = [8, 8, 44];
    pub const FIELD_COUNT: usize = 3;
    pub fn block_number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(0..8))
    }
    pub fn block_epoch(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(8..16))
    }
    pub fn key(&self) -> TransactionKey {
        TransactionKey::new_unchecked(self.0.slice(16..60))
    }
    pub fn as_reader<'r>(&'r self) -> TransactionInfoReader<'r> {
        TransactionInfoReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for TransactionInfo {
    type Builder = TransactionInfoBuilder;
    const NAME: &'static str = "TransactionInfo";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        TransactionInfo(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionInfoReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TransactionInfoReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .block_number(self.block_number())
            .block_epoch(self.block_epoch())
            .key(self.key())
    }
}
#[derive(Clone, Copy)]
pub struct TransactionInfoReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TransactionInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TransactionInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TransactionInfoReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_number", self.block_number())?;
        write!(f, ", {}: {}", "block_epoch", self.block_epoch())?;
        write!(f, ", {}: {}", "key", self.key())?;
        write!(f, " }}")
    }
}
impl<'r> TransactionInfoReader<'r> {
    pub const TOTAL_SIZE: usize = 60;
    pub const FIELD_SIZES: [usize; 3] = [8, 8, 44];
    pub const FIELD_COUNT: usize = 3;
    pub fn block_number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[0..8])
    }
    pub fn block_epoch(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[8..16])
    }
    pub fn key(&self) -> TransactionKeyReader<'r> {
        TransactionKeyReader::new_unchecked(&self.as_slice()[16..60])
    }
}
impl<'r> molecule::prelude::Reader<'r> for TransactionInfoReader<'r> {
    type Entity = TransactionInfo;
    const NAME: &'static str = "TransactionInfoReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TransactionInfoReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TransactionInfoBuilder {
    pub(crate) block_number: Uint64,
    pub(crate) block_epoch: Uint64,
    pub(crate) key: TransactionKey,
}
impl TransactionInfoBuilder {
    pub const TOTAL_SIZE: usize = 60;
    pub const FIELD_SIZES: [usize; 3] = [8, 8, 44];
    pub const FIELD_COUNT: usize = 3;
    pub fn block_number(mut self, v: Uint64) -> Self {
        self.block_number = v;
        self
    }
    pub fn block_epoch(mut self, v: Uint64) -> Self {
        self.block_epoch = v;
        self
    }
    pub fn key(mut self, v: TransactionKey) -> Self {
        self.key = v;
        self
    }
}
impl molecule::prelude::Builder for TransactionInfoBuilder {
    type Entity = TransactionInfo;
    const NAME: &'static str = "TransactionInfoBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.block_number.as_slice())?;
        writer.write_all(self.block_epoch.as_slice())?;
        writer.write_all(self.key.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        TransactionInfo::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct CellEntry(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CellEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CellEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CellEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "output", self.output())?;
        write!(f, ", {}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "block_number", self.block_number())?;
        write!(f, ", {}: {}", "block_epoch", self.block_epoch())?;
        write!(f, ", {}: {}", "index", self.index())?;
        write!(f, ", {}: {}", "data_size", self.data_size())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for CellEntry {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        CellEntry::new_unchecked(v)
    }
}
impl CellEntry {
    const DEFAULT_VALUE: [u8; 165] = [
        165, 0, 0, 0, 28, 0, 0, 0, 105, 0, 0, 0, 137, 0, 0, 0, 145, 0, 0, 0, 153, 0, 0, 0, 157, 0,
        0, 0, 77, 0, 0, 0, 16, 0, 0, 0, 24, 0, 0, 0, 77, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0,
        0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn output(&self) -> CellOutput {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        CellOutput::new_unchecked(self.0.slice(start..end))
    }
    pub fn block_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn block_number(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn block_epoch(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn index(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn data_size(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Uint64::new_unchecked(self.0.slice(start..end))
        } else {
            Uint64::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CellEntryReader<'r> {
        CellEntryReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CellEntry {
    type Builder = CellEntryBuilder;
    const NAME: &'static str = "CellEntry";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CellEntry(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CellEntryReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CellEntryReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .output(self.output())
            .block_hash(self.block_hash())
            .block_number(self.block_number())
            .block_epoch(self.block_epoch())
            .index(self.index())
            .data_size(self.data_size())
    }
}
#[derive(Clone, Copy)]
pub struct CellEntryReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CellEntryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CellEntryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CellEntryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "output", self.output())?;
        write!(f, ", {}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "block_number", self.block_number())?;
        write!(f, ", {}: {}", "block_epoch", self.block_epoch())?;
        write!(f, ", {}: {}", "index", self.index())?;
        write!(f, ", {}: {}", "data_size", self.data_size())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> CellEntryReader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn output(&self) -> CellOutputReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        CellOutputReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn block_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn block_number(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn block_epoch(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn index(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn data_size(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Uint64Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint64Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CellEntryReader<'r> {
    type Entity = CellEntry;
    const NAME: &'static str = "CellEntryReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CellEntryReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        CellOutputReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint64Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint64Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Uint32Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Uint64Reader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CellEntryBuilder {
    pub(crate) output: CellOutput,
    pub(crate) block_hash: Byte32,
    pub(crate) block_number: Uint64,
    pub(crate) block_epoch: Uint64,
    pub(crate) index: Uint32,
    pub(crate) data_size: Uint64,
}
impl CellEntryBuilder {
    pub const FIELD_COUNT: usize = 6;
    pub fn output(mut self, v: CellOutput) -> Self {
        self.output = v;
        self
    }
    pub fn block_hash(mut self, v: Byte32) -> Self {
        self.block_hash = v;
        self
    }
    pub fn block_number(mut self, v: Uint64) -> Self {
        self.block_number = v;
        self
    }
    pub fn block_epoch(mut self, v: Uint64) -> Self {
        self.block_epoch = v;
        self
    }
    pub fn index(mut self, v: Uint32) -> Self {
        self.index = v;
        self
    }
    pub fn data_size(mut self, v: Uint64) -> Self {
        self.data_size = v;
        self
    }
}
impl molecule::prelude::Builder for CellEntryBuilder {
    type Entity = CellEntry;
    const NAME: &'static str = "CellEntryBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.output.as_slice().len()
            + self.block_hash.as_slice().len()
            + self.block_number.as_slice().len()
            + self.block_epoch.as_slice().len()
            + self.index.as_slice().len()
            + self.data_size.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.output.as_slice().len();
        offsets.push(total_size);
        total_size += self.block_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.block_number.as_slice().len();
        offsets.push(total_size);
        total_size += self.block_epoch.as_slice().len();
        offsets.push(total_size);
        total_size += self.index.as_slice().len();
        offsets.push(total_size);
        total_size += self.data_size.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.output.as_slice())?;
        writer.write_all(self.block_hash.as_slice())?;
        writer.write_all(self.block_number.as_slice())?;
        writer.write_all(self.block_epoch.as_slice())?;
        writer.write_all(self.index.as_slice())?;
        writer.write_all(self.data_size.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CellEntry::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct CellDataEntry(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CellDataEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CellDataEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CellDataEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "output_data", self.output_data())?;
        write!(f, ", {}: {}", "output_data_hash", self.output_data_hash())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for CellDataEntry {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        CellDataEntry::new_unchecked(v)
    }
}
impl CellDataEntry {
    const DEFAULT_VALUE: [u8; 48] = [
        48, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn output_data(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn output_data_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CellDataEntryReader<'r> {
        CellDataEntryReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CellDataEntry {
    type Builder = CellDataEntryBuilder;
    const NAME: &'static str = "CellDataEntry";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CellDataEntry(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CellDataEntryReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CellDataEntryReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .output_data(self.output_data())
            .output_data_hash(self.output_data_hash())
    }
}
#[derive(Clone, Copy)]
pub struct CellDataEntryReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CellDataEntryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CellDataEntryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CellDataEntryReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "output_data", self.output_data())?;
        write!(f, ", {}: {}", "output_data_hash", self.output_data_hash())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> CellDataEntryReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn output_data(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn output_data_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CellDataEntryReader<'r> {
    type Entity = CellDataEntry;
    const NAME: &'static str = "CellDataEntryReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CellDataEntryReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BytesReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CellDataEntryBuilder {
    pub(crate) output_data: Bytes,
    pub(crate) output_data_hash: Byte32,
}
impl CellDataEntryBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn output_data(mut self, v: Bytes) -> Self {
        self.output_data = v;
        self
    }
    pub fn output_data_hash(mut self, v: Byte32) -> Self {
        self.output_data_hash = v;
        self
    }
}
impl molecule::prelude::Builder for CellDataEntryBuilder {
    type Entity = CellDataEntry;
    const NAME: &'static str = "CellDataEntryBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.output_data.as_slice().len()
            + self.output_data_hash.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.output_data.as_slice().len();
        offsets.push(total_size);
        total_size += self.output_data_hash.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.output_data.as_slice())?;
        writer.write_all(self.output_data_hash.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CellDataEntry::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct RelayMessage(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RelayMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RelayMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RelayMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for RelayMessage {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        RelayMessage::new_unchecked(v)
    }
}
impl RelayMessage {
    const DEFAULT_VALUE: [u8; 252] = [
        0, 0, 0, 0, 248, 0, 0, 0, 24, 0, 0, 0, 232, 0, 0, 0, 236, 0, 0, 0, 240, 0, 0, 0, 244, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 8;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> RelayMessageUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => CompactBlock::new_unchecked(inner).into(),
            1 => RelayTransactions::new_unchecked(inner).into(),
            2 => RelayTransactionHashes::new_unchecked(inner).into(),
            3 => GetRelayTransactions::new_unchecked(inner).into(),
            4 => GetBlockTransactions::new_unchecked(inner).into(),
            5 => BlockTransactions::new_unchecked(inner).into(),
            6 => GetBlockProposal::new_unchecked(inner).into(),
            7 => BlockProposal::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> RelayMessageReader<'r> {
        RelayMessageReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RelayMessage {
    type Builder = RelayMessageBuilder;
    const NAME: &'static str = "RelayMessage";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RelayMessage(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayMessageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayMessageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct RelayMessageReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RelayMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RelayMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RelayMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> RelayMessageReader<'r> {
    pub const ITEMS_COUNT: usize = 8;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> RelayMessageUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => CompactBlockReader::new_unchecked(inner).into(),
            1 => RelayTransactionsReader::new_unchecked(inner).into(),
            2 => RelayTransactionHashesReader::new_unchecked(inner).into(),
            3 => GetRelayTransactionsReader::new_unchecked(inner).into(),
            4 => GetBlockTransactionsReader::new_unchecked(inner).into(),
            5 => BlockTransactionsReader::new_unchecked(inner).into(),
            6 => GetBlockProposalReader::new_unchecked(inner).into(),
            7 => BlockProposalReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for RelayMessageReader<'r> {
    type Entity = RelayMessage;
    const NAME: &'static str = "RelayMessageReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RelayMessageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => CompactBlockReader::verify(inner_slice, compatible),
            1 => RelayTransactionsReader::verify(inner_slice, compatible),
            2 => RelayTransactionHashesReader::verify(inner_slice, compatible),
            3 => GetRelayTransactionsReader::verify(inner_slice, compatible),
            4 => GetBlockTransactionsReader::verify(inner_slice, compatible),
            5 => BlockTransactionsReader::verify(inner_slice, compatible),
            6 => GetBlockProposalReader::verify(inner_slice, compatible),
            7 => BlockProposalReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct RelayMessageBuilder(pub(crate) RelayMessageUnion);
impl RelayMessageBuilder {
    pub const ITEMS_COUNT: usize = 8;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<RelayMessageUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for RelayMessageBuilder {
    type Entity = RelayMessage;
    const NAME: &'static str = "RelayMessageBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RelayMessage::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum RelayMessageUnion {
    CompactBlock(CompactBlock),
    RelayTransactions(RelayTransactions),
    RelayTransactionHashes(RelayTransactionHashes),
    GetRelayTransactions(GetRelayTransactions),
    GetBlockTransactions(GetBlockTransactions),
    BlockTransactions(BlockTransactions),
    GetBlockProposal(GetBlockProposal),
    BlockProposal(BlockProposal),
}
#[derive(Debug, Clone, Copy)]
pub enum RelayMessageUnionReader<'r> {
    CompactBlock(CompactBlockReader<'r>),
    RelayTransactions(RelayTransactionsReader<'r>),
    RelayTransactionHashes(RelayTransactionHashesReader<'r>),
    GetRelayTransactions(GetRelayTransactionsReader<'r>),
    GetBlockTransactions(GetBlockTransactionsReader<'r>),
    BlockTransactions(BlockTransactionsReader<'r>),
    GetBlockProposal(GetBlockProposalReader<'r>),
    BlockProposal(BlockProposalReader<'r>),
}
impl ::core::default::Default for RelayMessageUnion {
    fn default() -> Self {
        RelayMessageUnion::CompactBlock(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for RelayMessageUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            RelayMessageUnion::CompactBlock(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, CompactBlock::NAME, item)
            }
            RelayMessageUnion::RelayTransactions(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, RelayTransactions::NAME, item)
            }
            RelayMessageUnion::RelayTransactionHashes(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    RelayTransactionHashes::NAME,
                    item
                )
            }
            RelayMessageUnion::GetRelayTransactions(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetRelayTransactions::NAME,
                    item
                )
            }
            RelayMessageUnion::GetBlockTransactions(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetBlockTransactions::NAME,
                    item
                )
            }
            RelayMessageUnion::BlockTransactions(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockTransactions::NAME, item)
            }
            RelayMessageUnion::GetBlockProposal(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlockProposal::NAME, item)
            }
            RelayMessageUnion::BlockProposal(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockProposal::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for RelayMessageUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            RelayMessageUnionReader::CompactBlock(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, CompactBlock::NAME, item)
            }
            RelayMessageUnionReader::RelayTransactions(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, RelayTransactions::NAME, item)
            }
            RelayMessageUnionReader::RelayTransactionHashes(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    RelayTransactionHashes::NAME,
                    item
                )
            }
            RelayMessageUnionReader::GetRelayTransactions(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetRelayTransactions::NAME,
                    item
                )
            }
            RelayMessageUnionReader::GetBlockTransactions(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetBlockTransactions::NAME,
                    item
                )
            }
            RelayMessageUnionReader::BlockTransactions(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockTransactions::NAME, item)
            }
            RelayMessageUnionReader::GetBlockProposal(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlockProposal::NAME, item)
            }
            RelayMessageUnionReader::BlockProposal(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockProposal::NAME, item)
            }
        }
    }
}
impl RelayMessageUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            RelayMessageUnion::CompactBlock(ref item) => write!(f, "{}", item),
            RelayMessageUnion::RelayTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnion::RelayTransactionHashes(ref item) => write!(f, "{}", item),
            RelayMessageUnion::GetRelayTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnion::GetBlockTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnion::BlockTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnion::GetBlockProposal(ref item) => write!(f, "{}", item),
            RelayMessageUnion::BlockProposal(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> RelayMessageUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            RelayMessageUnionReader::CompactBlock(ref item) => write!(f, "{}", item),
            RelayMessageUnionReader::RelayTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnionReader::RelayTransactionHashes(ref item) => write!(f, "{}", item),
            RelayMessageUnionReader::GetRelayTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnionReader::GetBlockTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnionReader::BlockTransactions(ref item) => write!(f, "{}", item),
            RelayMessageUnionReader::GetBlockProposal(ref item) => write!(f, "{}", item),
            RelayMessageUnionReader::BlockProposal(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<CompactBlock> for RelayMessageUnion {
    fn from(item: CompactBlock) -> Self {
        RelayMessageUnion::CompactBlock(item)
    }
}
impl ::core::convert::From<RelayTransactions> for RelayMessageUnion {
    fn from(item: RelayTransactions) -> Self {
        RelayMessageUnion::RelayTransactions(item)
    }
}
impl ::core::convert::From<RelayTransactionHashes> for RelayMessageUnion {
    fn from(item: RelayTransactionHashes) -> Self {
        RelayMessageUnion::RelayTransactionHashes(item)
    }
}
impl ::core::convert::From<GetRelayTransactions> for RelayMessageUnion {
    fn from(item: GetRelayTransactions) -> Self {
        RelayMessageUnion::GetRelayTransactions(item)
    }
}
impl ::core::convert::From<GetBlockTransactions> for RelayMessageUnion {
    fn from(item: GetBlockTransactions) -> Self {
        RelayMessageUnion::GetBlockTransactions(item)
    }
}
impl ::core::convert::From<BlockTransactions> for RelayMessageUnion {
    fn from(item: BlockTransactions) -> Self {
        RelayMessageUnion::BlockTransactions(item)
    }
}
impl ::core::convert::From<GetBlockProposal> for RelayMessageUnion {
    fn from(item: GetBlockProposal) -> Self {
        RelayMessageUnion::GetBlockProposal(item)
    }
}
impl ::core::convert::From<BlockProposal> for RelayMessageUnion {
    fn from(item: BlockProposal) -> Self {
        RelayMessageUnion::BlockProposal(item)
    }
}
impl<'r> ::core::convert::From<CompactBlockReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: CompactBlockReader<'r>) -> Self {
        RelayMessageUnionReader::CompactBlock(item)
    }
}
impl<'r> ::core::convert::From<RelayTransactionsReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: RelayTransactionsReader<'r>) -> Self {
        RelayMessageUnionReader::RelayTransactions(item)
    }
}
impl<'r> ::core::convert::From<RelayTransactionHashesReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: RelayTransactionHashesReader<'r>) -> Self {
        RelayMessageUnionReader::RelayTransactionHashes(item)
    }
}
impl<'r> ::core::convert::From<GetRelayTransactionsReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: GetRelayTransactionsReader<'r>) -> Self {
        RelayMessageUnionReader::GetRelayTransactions(item)
    }
}
impl<'r> ::core::convert::From<GetBlockTransactionsReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: GetBlockTransactionsReader<'r>) -> Self {
        RelayMessageUnionReader::GetBlockTransactions(item)
    }
}
impl<'r> ::core::convert::From<BlockTransactionsReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: BlockTransactionsReader<'r>) -> Self {
        RelayMessageUnionReader::BlockTransactions(item)
    }
}
impl<'r> ::core::convert::From<GetBlockProposalReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: GetBlockProposalReader<'r>) -> Self {
        RelayMessageUnionReader::GetBlockProposal(item)
    }
}
impl<'r> ::core::convert::From<BlockProposalReader<'r>> for RelayMessageUnionReader<'r> {
    fn from(item: BlockProposalReader<'r>) -> Self {
        RelayMessageUnionReader::BlockProposal(item)
    }
}
impl RelayMessageUnion {
    pub const NAME: &'static str = "RelayMessageUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            RelayMessageUnion::CompactBlock(item) => item.as_bytes(),
            RelayMessageUnion::RelayTransactions(item) => item.as_bytes(),
            RelayMessageUnion::RelayTransactionHashes(item) => item.as_bytes(),
            RelayMessageUnion::GetRelayTransactions(item) => item.as_bytes(),
            RelayMessageUnion::GetBlockTransactions(item) => item.as_bytes(),
            RelayMessageUnion::BlockTransactions(item) => item.as_bytes(),
            RelayMessageUnion::GetBlockProposal(item) => item.as_bytes(),
            RelayMessageUnion::BlockProposal(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            RelayMessageUnion::CompactBlock(item) => item.as_slice(),
            RelayMessageUnion::RelayTransactions(item) => item.as_slice(),
            RelayMessageUnion::RelayTransactionHashes(item) => item.as_slice(),
            RelayMessageUnion::GetRelayTransactions(item) => item.as_slice(),
            RelayMessageUnion::GetBlockTransactions(item) => item.as_slice(),
            RelayMessageUnion::BlockTransactions(item) => item.as_slice(),
            RelayMessageUnion::GetBlockProposal(item) => item.as_slice(),
            RelayMessageUnion::BlockProposal(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            RelayMessageUnion::CompactBlock(_) => 0,
            RelayMessageUnion::RelayTransactions(_) => 1,
            RelayMessageUnion::RelayTransactionHashes(_) => 2,
            RelayMessageUnion::GetRelayTransactions(_) => 3,
            RelayMessageUnion::GetBlockTransactions(_) => 4,
            RelayMessageUnion::BlockTransactions(_) => 5,
            RelayMessageUnion::GetBlockProposal(_) => 6,
            RelayMessageUnion::BlockProposal(_) => 7,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            RelayMessageUnion::CompactBlock(_) => "CompactBlock",
            RelayMessageUnion::RelayTransactions(_) => "RelayTransactions",
            RelayMessageUnion::RelayTransactionHashes(_) => "RelayTransactionHashes",
            RelayMessageUnion::GetRelayTransactions(_) => "GetRelayTransactions",
            RelayMessageUnion::GetBlockTransactions(_) => "GetBlockTransactions",
            RelayMessageUnion::BlockTransactions(_) => "BlockTransactions",
            RelayMessageUnion::GetBlockProposal(_) => "GetBlockProposal",
            RelayMessageUnion::BlockProposal(_) => "BlockProposal",
        }
    }
    pub fn as_reader<'r>(&'r self) -> RelayMessageUnionReader<'r> {
        match self {
            RelayMessageUnion::CompactBlock(item) => item.as_reader().into(),
            RelayMessageUnion::RelayTransactions(item) => item.as_reader().into(),
            RelayMessageUnion::RelayTransactionHashes(item) => item.as_reader().into(),
            RelayMessageUnion::GetRelayTransactions(item) => item.as_reader().into(),
            RelayMessageUnion::GetBlockTransactions(item) => item.as_reader().into(),
            RelayMessageUnion::BlockTransactions(item) => item.as_reader().into(),
            RelayMessageUnion::GetBlockProposal(item) => item.as_reader().into(),
            RelayMessageUnion::BlockProposal(item) => item.as_reader().into(),
        }
    }
}
impl<'r> RelayMessageUnionReader<'r> {
    pub const NAME: &'r str = "RelayMessageUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            RelayMessageUnionReader::CompactBlock(item) => item.as_slice(),
            RelayMessageUnionReader::RelayTransactions(item) => item.as_slice(),
            RelayMessageUnionReader::RelayTransactionHashes(item) => item.as_slice(),
            RelayMessageUnionReader::GetRelayTransactions(item) => item.as_slice(),
            RelayMessageUnionReader::GetBlockTransactions(item) => item.as_slice(),
            RelayMessageUnionReader::BlockTransactions(item) => item.as_slice(),
            RelayMessageUnionReader::GetBlockProposal(item) => item.as_slice(),
            RelayMessageUnionReader::BlockProposal(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            RelayMessageUnionReader::CompactBlock(_) => 0,
            RelayMessageUnionReader::RelayTransactions(_) => 1,
            RelayMessageUnionReader::RelayTransactionHashes(_) => 2,
            RelayMessageUnionReader::GetRelayTransactions(_) => 3,
            RelayMessageUnionReader::GetBlockTransactions(_) => 4,
            RelayMessageUnionReader::BlockTransactions(_) => 5,
            RelayMessageUnionReader::GetBlockProposal(_) => 6,
            RelayMessageUnionReader::BlockProposal(_) => 7,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            RelayMessageUnionReader::CompactBlock(_) => "CompactBlock",
            RelayMessageUnionReader::RelayTransactions(_) => "RelayTransactions",
            RelayMessageUnionReader::RelayTransactionHashes(_) => "RelayTransactionHashes",
            RelayMessageUnionReader::GetRelayTransactions(_) => "GetRelayTransactions",
            RelayMessageUnionReader::GetBlockTransactions(_) => "GetBlockTransactions",
            RelayMessageUnionReader::BlockTransactions(_) => "BlockTransactions",
            RelayMessageUnionReader::GetBlockProposal(_) => "GetBlockProposal",
            RelayMessageUnionReader::BlockProposal(_) => "BlockProposal",
        }
    }
}
#[derive(Clone)]
pub struct CompactBlock(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CompactBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CompactBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CompactBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "short_ids", self.short_ids())?;
        write!(
            f,
            ", {}: {}",
            "prefilled_transactions",
            self.prefilled_transactions()
        )?;
        write!(f, ", {}: {}", "uncles", self.uncles())?;
        write!(f, ", {}: {}", "proposals", self.proposals())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for CompactBlock {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        CompactBlock::new_unchecked(v)
    }
}
impl CompactBlock {
    const DEFAULT_VALUE: [u8; 248] = [
        248, 0, 0, 0, 24, 0, 0, 0, 232, 0, 0, 0, 236, 0, 0, 0, 240, 0, 0, 0, 244, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> Header {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Header::new_unchecked(self.0.slice(start..end))
    }
    pub fn short_ids(&self) -> ProposalShortIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ProposalShortIdVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn prefilled_transactions(&self) -> IndexTransactionVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        IndexTransactionVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn uncles(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposals(&self) -> ProposalShortIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            ProposalShortIdVec::new_unchecked(self.0.slice(start..end))
        } else {
            ProposalShortIdVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CompactBlockReader<'r> {
        CompactBlockReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CompactBlock {
    type Builder = CompactBlockBuilder;
    const NAME: &'static str = "CompactBlock";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CompactBlock(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CompactBlockReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CompactBlockReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .header(self.header())
            .short_ids(self.short_ids())
            .prefilled_transactions(self.prefilled_transactions())
            .uncles(self.uncles())
            .proposals(self.proposals())
    }
}
#[derive(Clone, Copy)]
pub struct CompactBlockReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CompactBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CompactBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CompactBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "short_ids", self.short_ids())?;
        write!(
            f,
            ", {}: {}",
            "prefilled_transactions",
            self.prefilled_transactions()
        )?;
        write!(f, ", {}: {}", "uncles", self.uncles())?;
        write!(f, ", {}: {}", "proposals", self.proposals())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> CompactBlockReader<'r> {
    pub const FIELD_COUNT: usize = 5;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> HeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn short_ids(&self) -> ProposalShortIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ProposalShortIdVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn prefilled_transactions(&self) -> IndexTransactionVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        IndexTransactionVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn uncles(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposals(&self) -> ProposalShortIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[24..]) as usize;
            ProposalShortIdVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ProposalShortIdVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CompactBlockReader<'r> {
    type Entity = CompactBlock;
    const NAME: &'static str = "CompactBlockReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CompactBlockReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ProposalShortIdVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        IndexTransactionVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        ProposalShortIdVecReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CompactBlockBuilder {
    pub(crate) header: Header,
    pub(crate) short_ids: ProposalShortIdVec,
    pub(crate) prefilled_transactions: IndexTransactionVec,
    pub(crate) uncles: Byte32Vec,
    pub(crate) proposals: ProposalShortIdVec,
}
impl CompactBlockBuilder {
    pub const FIELD_COUNT: usize = 5;
    pub fn header(mut self, v: Header) -> Self {
        self.header = v;
        self
    }
    pub fn short_ids(mut self, v: ProposalShortIdVec) -> Self {
        self.short_ids = v;
        self
    }
    pub fn prefilled_transactions(mut self, v: IndexTransactionVec) -> Self {
        self.prefilled_transactions = v;
        self
    }
    pub fn uncles(mut self, v: Byte32Vec) -> Self {
        self.uncles = v;
        self
    }
    pub fn proposals(mut self, v: ProposalShortIdVec) -> Self {
        self.proposals = v;
        self
    }
}
impl molecule::prelude::Builder for CompactBlockBuilder {
    type Entity = CompactBlock;
    const NAME: &'static str = "CompactBlockBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.header.as_slice().len()
            + self.short_ids.as_slice().len()
            + self.prefilled_transactions.as_slice().len()
            + self.uncles.as_slice().len()
            + self.proposals.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.header.as_slice().len();
        offsets.push(total_size);
        total_size += self.short_ids.as_slice().len();
        offsets.push(total_size);
        total_size += self.prefilled_transactions.as_slice().len();
        offsets.push(total_size);
        total_size += self.uncles.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposals.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.header.as_slice())?;
        writer.write_all(self.short_ids.as_slice())?;
        writer.write_all(self.prefilled_transactions.as_slice())?;
        writer.write_all(self.uncles.as_slice())?;
        writer.write_all(self.proposals.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CompactBlock::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct CompactBlockV1(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for CompactBlockV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for CompactBlockV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for CompactBlockV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "short_ids", self.short_ids())?;
        write!(
            f,
            ", {}: {}",
            "prefilled_transactions",
            self.prefilled_transactions()
        )?;
        write!(f, ", {}: {}", "uncles", self.uncles())?;
        write!(f, ", {}: {}", "proposals", self.proposals())?;
        write!(f, ", {}: {}", "extension", self.extension())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for CompactBlockV1 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        CompactBlockV1::new_unchecked(v)
    }
}
impl CompactBlockV1 {
    const DEFAULT_VALUE: [u8; 256] = [
        0, 1, 0, 0, 28, 0, 0, 0, 236, 0, 0, 0, 240, 0, 0, 0, 244, 0, 0, 0, 248, 0, 0, 0, 252, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> Header {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Header::new_unchecked(self.0.slice(start..end))
    }
    pub fn short_ids(&self) -> ProposalShortIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ProposalShortIdVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn prefilled_transactions(&self) -> IndexTransactionVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        IndexTransactionVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn uncles(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposals(&self) -> ProposalShortIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        ProposalShortIdVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn extension(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> CompactBlockV1Reader<'r> {
        CompactBlockV1Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for CompactBlockV1 {
    type Builder = CompactBlockV1Builder;
    const NAME: &'static str = "CompactBlockV1";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        CompactBlockV1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CompactBlockV1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        CompactBlockV1Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .header(self.header())
            .short_ids(self.short_ids())
            .prefilled_transactions(self.prefilled_transactions())
            .uncles(self.uncles())
            .proposals(self.proposals())
            .extension(self.extension())
    }
}
#[derive(Clone, Copy)]
pub struct CompactBlockV1Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for CompactBlockV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for CompactBlockV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for CompactBlockV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "short_ids", self.short_ids())?;
        write!(
            f,
            ", {}: {}",
            "prefilled_transactions",
            self.prefilled_transactions()
        )?;
        write!(f, ", {}: {}", "uncles", self.uncles())?;
        write!(f, ", {}: {}", "proposals", self.proposals())?;
        write!(f, ", {}: {}", "extension", self.extension())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> CompactBlockV1Reader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> HeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn short_ids(&self) -> ProposalShortIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        ProposalShortIdVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn prefilled_transactions(&self) -> IndexTransactionVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        IndexTransactionVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn uncles(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposals(&self) -> ProposalShortIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        ProposalShortIdVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn extension(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for CompactBlockV1Reader<'r> {
    type Entity = CompactBlockV1;
    const NAME: &'static str = "CompactBlockV1Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        CompactBlockV1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ProposalShortIdVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        IndexTransactionVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        ProposalShortIdVecReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        BytesReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct CompactBlockV1Builder {
    pub(crate) header: Header,
    pub(crate) short_ids: ProposalShortIdVec,
    pub(crate) prefilled_transactions: IndexTransactionVec,
    pub(crate) uncles: Byte32Vec,
    pub(crate) proposals: ProposalShortIdVec,
    pub(crate) extension: Bytes,
}
impl CompactBlockV1Builder {
    pub const FIELD_COUNT: usize = 6;
    pub fn header(mut self, v: Header) -> Self {
        self.header = v;
        self
    }
    pub fn short_ids(mut self, v: ProposalShortIdVec) -> Self {
        self.short_ids = v;
        self
    }
    pub fn prefilled_transactions(mut self, v: IndexTransactionVec) -> Self {
        self.prefilled_transactions = v;
        self
    }
    pub fn uncles(mut self, v: Byte32Vec) -> Self {
        self.uncles = v;
        self
    }
    pub fn proposals(mut self, v: ProposalShortIdVec) -> Self {
        self.proposals = v;
        self
    }
    pub fn extension(mut self, v: Bytes) -> Self {
        self.extension = v;
        self
    }
}
impl molecule::prelude::Builder for CompactBlockV1Builder {
    type Entity = CompactBlockV1;
    const NAME: &'static str = "CompactBlockV1Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.header.as_slice().len()
            + self.short_ids.as_slice().len()
            + self.prefilled_transactions.as_slice().len()
            + self.uncles.as_slice().len()
            + self.proposals.as_slice().len()
            + self.extension.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.header.as_slice().len();
        offsets.push(total_size);
        total_size += self.short_ids.as_slice().len();
        offsets.push(total_size);
        total_size += self.prefilled_transactions.as_slice().len();
        offsets.push(total_size);
        total_size += self.uncles.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposals.as_slice().len();
        offsets.push(total_size);
        total_size += self.extension.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.header.as_slice())?;
        writer.write_all(self.short_ids.as_slice())?;
        writer.write_all(self.prefilled_transactions.as_slice())?;
        writer.write_all(self.uncles.as_slice())?;
        writer.write_all(self.proposals.as_slice())?;
        writer.write_all(self.extension.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        CompactBlockV1::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct RelayTransaction(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RelayTransaction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RelayTransaction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RelayTransaction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cycles", self.cycles())?;
        write!(f, ", {}: {}", "transaction", self.transaction())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for RelayTransaction {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        RelayTransaction::new_unchecked(v)
    }
}
impl RelayTransaction {
    const DEFAULT_VALUE: [u8; 88] = [
        88, 0, 0, 0, 12, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 0, 0, 12, 0, 0, 0,
        64, 0, 0, 0, 52, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0,
        48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0,
        0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cycles(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn transaction(&self) -> Transaction {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Transaction::new_unchecked(self.0.slice(start..end))
        } else {
            Transaction::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> RelayTransactionReader<'r> {
        RelayTransactionReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RelayTransaction {
    type Builder = RelayTransactionBuilder;
    const NAME: &'static str = "RelayTransaction";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RelayTransaction(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .cycles(self.cycles())
            .transaction(self.transaction())
    }
}
#[derive(Clone, Copy)]
pub struct RelayTransactionReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RelayTransactionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RelayTransactionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RelayTransactionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "cycles", self.cycles())?;
        write!(f, ", {}: {}", "transaction", self.transaction())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> RelayTransactionReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn cycles(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn transaction(&self) -> TransactionReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            TransactionReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            TransactionReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for RelayTransactionReader<'r> {
    type Entity = RelayTransaction;
    const NAME: &'static str = "RelayTransactionReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RelayTransactionReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TransactionReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct RelayTransactionBuilder {
    pub(crate) cycles: Uint64,
    pub(crate) transaction: Transaction,
}
impl RelayTransactionBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn cycles(mut self, v: Uint64) -> Self {
        self.cycles = v;
        self
    }
    pub fn transaction(mut self, v: Transaction) -> Self {
        self.transaction = v;
        self
    }
}
impl molecule::prelude::Builder for RelayTransactionBuilder {
    type Entity = RelayTransaction;
    const NAME: &'static str = "RelayTransactionBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.cycles.as_slice().len()
            + self.transaction.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.cycles.as_slice().len();
        offsets.push(total_size);
        total_size += self.transaction.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.cycles.as_slice())?;
        writer.write_all(self.transaction.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RelayTransaction::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct RelayTransactionVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RelayTransactionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RelayTransactionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RelayTransactionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for RelayTransactionVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        RelayTransactionVec::new_unchecked(v)
    }
}
impl RelayTransactionVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<RelayTransaction> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> RelayTransaction {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            RelayTransaction::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            RelayTransaction::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> RelayTransactionVecReader<'r> {
        RelayTransactionVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RelayTransactionVec {
    type Builder = RelayTransactionVecBuilder;
    const NAME: &'static str = "RelayTransactionVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RelayTransactionVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct RelayTransactionVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RelayTransactionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RelayTransactionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RelayTransactionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> RelayTransactionVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<RelayTransactionReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> RelayTransactionReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            RelayTransactionReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            RelayTransactionReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for RelayTransactionVecReader<'r> {
    type Entity = RelayTransactionVec;
    const NAME: &'static str = "RelayTransactionVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RelayTransactionVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            RelayTransactionReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct RelayTransactionVecBuilder(pub(crate) Vec<RelayTransaction>);
impl RelayTransactionVecBuilder {
    pub fn set(mut self, v: Vec<RelayTransaction>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: RelayTransaction) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = RelayTransaction>>(
        mut self,
        iter: T,
    ) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: RelayTransaction) -> Option<RelayTransaction> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for RelayTransactionVecBuilder {
    type Entity = RelayTransactionVec;
    const NAME: &'static str = "RelayTransactionVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RelayTransactionVec::new_unchecked(inner.into())
    }
}
pub struct RelayTransactionVecIterator(RelayTransactionVec, usize, usize);
impl ::core::iter::Iterator for RelayTransactionVecIterator {
    type Item = RelayTransaction;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for RelayTransactionVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for RelayTransactionVec {
    type Item = RelayTransaction;
    type IntoIter = RelayTransactionVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        RelayTransactionVecIterator(self, 0, len)
    }
}
impl<'r> RelayTransactionVecReader<'r> {
    pub fn iter<'t>(&'t self) -> RelayTransactionVecReaderIterator<'t, 'r> {
        RelayTransactionVecReaderIterator(&self, 0, self.len())
    }
}
pub struct RelayTransactionVecReaderIterator<'t, 'r>(
    &'t RelayTransactionVecReader<'r>,
    usize,
    usize,
);
impl<'t: 'r, 'r> ::core::iter::Iterator for RelayTransactionVecReaderIterator<'t, 'r> {
    type Item = RelayTransactionReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for RelayTransactionVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct RelayTransactions(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RelayTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RelayTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RelayTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "transactions", self.transactions())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for RelayTransactions {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        RelayTransactions::new_unchecked(v)
    }
}
impl RelayTransactions {
    const DEFAULT_VALUE: [u8; 12] = [12, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn transactions(&self) -> RelayTransactionVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            RelayTransactionVec::new_unchecked(self.0.slice(start..end))
        } else {
            RelayTransactionVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> RelayTransactionsReader<'r> {
        RelayTransactionsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RelayTransactions {
    type Builder = RelayTransactionsBuilder;
    const NAME: &'static str = "RelayTransactions";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RelayTransactions(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().transactions(self.transactions())
    }
}
#[derive(Clone, Copy)]
pub struct RelayTransactionsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RelayTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RelayTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RelayTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "transactions", self.transactions())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> RelayTransactionsReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn transactions(&self) -> RelayTransactionVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            RelayTransactionVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            RelayTransactionVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for RelayTransactionsReader<'r> {
    type Entity = RelayTransactions;
    const NAME: &'static str = "RelayTransactionsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RelayTransactionsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        RelayTransactionVecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct RelayTransactionsBuilder {
    pub(crate) transactions: RelayTransactionVec,
}
impl RelayTransactionsBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn transactions(mut self, v: RelayTransactionVec) -> Self {
        self.transactions = v;
        self
    }
}
impl molecule::prelude::Builder for RelayTransactionsBuilder {
    type Entity = RelayTransactions;
    const NAME: &'static str = "RelayTransactionsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.transactions.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.transactions.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.transactions.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RelayTransactions::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct RelayTransactionHashes(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RelayTransactionHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RelayTransactionHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RelayTransactionHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "tx_hashes", self.tx_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for RelayTransactionHashes {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        RelayTransactionHashes::new_unchecked(v)
    }
}
impl RelayTransactionHashes {
    const DEFAULT_VALUE: [u8; 12] = [12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn tx_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> RelayTransactionHashesReader<'r> {
        RelayTransactionHashesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RelayTransactionHashes {
    type Builder = RelayTransactionHashesBuilder;
    const NAME: &'static str = "RelayTransactionHashes";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RelayTransactionHashes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionHashesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RelayTransactionHashesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().tx_hashes(self.tx_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct RelayTransactionHashesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RelayTransactionHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RelayTransactionHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RelayTransactionHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "tx_hashes", self.tx_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> RelayTransactionHashesReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn tx_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for RelayTransactionHashesReader<'r> {
    type Entity = RelayTransactionHashes;
    const NAME: &'static str = "RelayTransactionHashesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RelayTransactionHashesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32VecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct RelayTransactionHashesBuilder {
    pub(crate) tx_hashes: Byte32Vec,
}
impl RelayTransactionHashesBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn tx_hashes(mut self, v: Byte32Vec) -> Self {
        self.tx_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for RelayTransactionHashesBuilder {
    type Entity = RelayTransactionHashes;
    const NAME: &'static str = "RelayTransactionHashesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.tx_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.tx_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.tx_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RelayTransactionHashes::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetRelayTransactions(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetRelayTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetRelayTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetRelayTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "tx_hashes", self.tx_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetRelayTransactions {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        GetRelayTransactions::new_unchecked(v)
    }
}
impl GetRelayTransactions {
    const DEFAULT_VALUE: [u8; 12] = [12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn tx_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetRelayTransactionsReader<'r> {
        GetRelayTransactionsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetRelayTransactions {
    type Builder = GetRelayTransactionsBuilder;
    const NAME: &'static str = "GetRelayTransactions";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetRelayTransactions(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetRelayTransactionsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetRelayTransactionsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().tx_hashes(self.tx_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct GetRelayTransactionsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetRelayTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetRelayTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetRelayTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "tx_hashes", self.tx_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetRelayTransactionsReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn tx_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetRelayTransactionsReader<'r> {
    type Entity = GetRelayTransactions;
    const NAME: &'static str = "GetRelayTransactionsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetRelayTransactionsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32VecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetRelayTransactionsBuilder {
    pub(crate) tx_hashes: Byte32Vec,
}
impl GetRelayTransactionsBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn tx_hashes(mut self, v: Byte32Vec) -> Self {
        self.tx_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for GetRelayTransactionsBuilder {
    type Entity = GetRelayTransactions;
    const NAME: &'static str = "GetRelayTransactionsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.tx_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.tx_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.tx_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetRelayTransactions::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetBlockTransactions(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetBlockTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetBlockTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetBlockTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "indexes", self.indexes())?;
        write!(f, ", {}: {}", "uncle_indexes", self.uncle_indexes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetBlockTransactions {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        GetBlockTransactions::new_unchecked(v)
    }
}
impl GetBlockTransactions {
    const DEFAULT_VALUE: [u8; 56] = [
        56, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn indexes(&self) -> Uint32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn uncle_indexes(&self) -> Uint32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Uint32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Uint32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetBlockTransactionsReader<'r> {
        GetBlockTransactionsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetBlockTransactions {
    type Builder = GetBlockTransactionsBuilder;
    const NAME: &'static str = "GetBlockTransactions";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetBlockTransactions(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockTransactionsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockTransactionsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .block_hash(self.block_hash())
            .indexes(self.indexes())
            .uncle_indexes(self.uncle_indexes())
    }
}
#[derive(Clone, Copy)]
pub struct GetBlockTransactionsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetBlockTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetBlockTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetBlockTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "indexes", self.indexes())?;
        write!(f, ", {}: {}", "uncle_indexes", self.uncle_indexes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetBlockTransactionsReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn indexes(&self) -> Uint32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn uncle_indexes(&self) -> Uint32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Uint32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetBlockTransactionsReader<'r> {
    type Entity = GetBlockTransactions;
    const NAME: &'static str = "GetBlockTransactionsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetBlockTransactionsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint32VecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint32VecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetBlockTransactionsBuilder {
    pub(crate) block_hash: Byte32,
    pub(crate) indexes: Uint32Vec,
    pub(crate) uncle_indexes: Uint32Vec,
}
impl GetBlockTransactionsBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn block_hash(mut self, v: Byte32) -> Self {
        self.block_hash = v;
        self
    }
    pub fn indexes(mut self, v: Uint32Vec) -> Self {
        self.indexes = v;
        self
    }
    pub fn uncle_indexes(mut self, v: Uint32Vec) -> Self {
        self.uncle_indexes = v;
        self
    }
}
impl molecule::prelude::Builder for GetBlockTransactionsBuilder {
    type Entity = GetBlockTransactions;
    const NAME: &'static str = "GetBlockTransactionsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.block_hash.as_slice().len()
            + self.indexes.as_slice().len()
            + self.uncle_indexes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.block_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.indexes.as_slice().len();
        offsets.push(total_size);
        total_size += self.uncle_indexes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.block_hash.as_slice())?;
        writer.write_all(self.indexes.as_slice())?;
        writer.write_all(self.uncle_indexes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetBlockTransactions::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlockTransactions(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockTransactions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "transactions", self.transactions())?;
        write!(f, ", {}: {}", "uncles", self.uncles())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BlockTransactions {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BlockTransactions::new_unchecked(v)
    }
}
impl BlockTransactions {
    const DEFAULT_VALUE: [u8; 56] = [
        56, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn transactions(&self) -> TransactionVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TransactionVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn uncles(&self) -> UncleBlockVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            UncleBlockVec::new_unchecked(self.0.slice(start..end))
        } else {
            UncleBlockVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockTransactionsReader<'r> {
        BlockTransactionsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockTransactions {
    type Builder = BlockTransactionsBuilder;
    const NAME: &'static str = "BlockTransactions";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockTransactions(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockTransactionsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockTransactionsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .block_hash(self.block_hash())
            .transactions(self.transactions())
            .uncles(self.uncles())
    }
}
#[derive(Clone, Copy)]
pub struct BlockTransactionsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockTransactionsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "transactions", self.transactions())?;
        write!(f, ", {}: {}", "uncles", self.uncles())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BlockTransactionsReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn transactions(&self) -> TransactionVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        TransactionVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn uncles(&self) -> UncleBlockVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            UncleBlockVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            UncleBlockVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockTransactionsReader<'r> {
    type Entity = BlockTransactions;
    const NAME: &'static str = "BlockTransactionsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockTransactionsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TransactionVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        UncleBlockVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockTransactionsBuilder {
    pub(crate) block_hash: Byte32,
    pub(crate) transactions: TransactionVec,
    pub(crate) uncles: UncleBlockVec,
}
impl BlockTransactionsBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn block_hash(mut self, v: Byte32) -> Self {
        self.block_hash = v;
        self
    }
    pub fn transactions(mut self, v: TransactionVec) -> Self {
        self.transactions = v;
        self
    }
    pub fn uncles(mut self, v: UncleBlockVec) -> Self {
        self.uncles = v;
        self
    }
}
impl molecule::prelude::Builder for BlockTransactionsBuilder {
    type Entity = BlockTransactions;
    const NAME: &'static str = "BlockTransactionsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.block_hash.as_slice().len()
            + self.transactions.as_slice().len()
            + self.uncles.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.block_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.transactions.as_slice().len();
        offsets.push(total_size);
        total_size += self.uncles.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.block_hash.as_slice())?;
        writer.write_all(self.transactions.as_slice())?;
        writer.write_all(self.uncles.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockTransactions::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetBlockProposal(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetBlockProposal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetBlockProposal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetBlockProposal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "proposals", self.proposals())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetBlockProposal {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        GetBlockProposal::new_unchecked(v)
    }
}
impl GetBlockProposal {
    const DEFAULT_VALUE: [u8; 48] = [
        48, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn proposals(&self) -> ProposalShortIdVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            ProposalShortIdVec::new_unchecked(self.0.slice(start..end))
        } else {
            ProposalShortIdVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetBlockProposalReader<'r> {
        GetBlockProposalReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetBlockProposal {
    type Builder = GetBlockProposalBuilder;
    const NAME: &'static str = "GetBlockProposal";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetBlockProposal(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockProposalReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockProposalReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .block_hash(self.block_hash())
            .proposals(self.proposals())
    }
}
#[derive(Clone, Copy)]
pub struct GetBlockProposalReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetBlockProposalReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetBlockProposalReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetBlockProposalReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hash", self.block_hash())?;
        write!(f, ", {}: {}", "proposals", self.proposals())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetBlockProposalReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proposals(&self) -> ProposalShortIdVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            ProposalShortIdVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            ProposalShortIdVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetBlockProposalReader<'r> {
    type Entity = GetBlockProposal;
    const NAME: &'static str = "GetBlockProposalReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetBlockProposalReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        ProposalShortIdVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetBlockProposalBuilder {
    pub(crate) block_hash: Byte32,
    pub(crate) proposals: ProposalShortIdVec,
}
impl GetBlockProposalBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn block_hash(mut self, v: Byte32) -> Self {
        self.block_hash = v;
        self
    }
    pub fn proposals(mut self, v: ProposalShortIdVec) -> Self {
        self.proposals = v;
        self
    }
}
impl molecule::prelude::Builder for GetBlockProposalBuilder {
    type Entity = GetBlockProposal;
    const NAME: &'static str = "GetBlockProposalBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.block_hash.as_slice().len()
            + self.proposals.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.block_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.proposals.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.block_hash.as_slice())?;
        writer.write_all(self.proposals.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetBlockProposal::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlockProposal(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockProposal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockProposal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockProposal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "transactions", self.transactions())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BlockProposal {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BlockProposal::new_unchecked(v)
    }
}
impl BlockProposal {
    const DEFAULT_VALUE: [u8; 12] = [12, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn transactions(&self) -> TransactionVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            TransactionVec::new_unchecked(self.0.slice(start..end))
        } else {
            TransactionVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockProposalReader<'r> {
        BlockProposalReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockProposal {
    type Builder = BlockProposalBuilder;
    const NAME: &'static str = "BlockProposal";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockProposal(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockProposalReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockProposalReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().transactions(self.transactions())
    }
}
#[derive(Clone, Copy)]
pub struct BlockProposalReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockProposalReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockProposalReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockProposalReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "transactions", self.transactions())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BlockProposalReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn transactions(&self) -> TransactionVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            TransactionVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            TransactionVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockProposalReader<'r> {
    type Entity = BlockProposal;
    const NAME: &'static str = "BlockProposalReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockProposalReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        TransactionVecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockProposalBuilder {
    pub(crate) transactions: TransactionVec,
}
impl BlockProposalBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn transactions(mut self, v: TransactionVec) -> Self {
        self.transactions = v;
        self
    }
}
impl molecule::prelude::Builder for BlockProposalBuilder {
    type Entity = BlockProposal;
    const NAME: &'static str = "BlockProposalBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.transactions.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.transactions.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.transactions.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockProposal::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct IndexTransaction(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for IndexTransaction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for IndexTransaction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for IndexTransaction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "index", self.index())?;
        write!(f, ", {}: {}", "transaction", self.transaction())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for IndexTransaction {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        IndexTransaction::new_unchecked(v)
    }
}
impl IndexTransaction {
    const DEFAULT_VALUE: [u8; 84] = [
        84, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 68, 0, 0, 0, 12, 0, 0, 0, 64, 0, 0, 0,
        52, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn index(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn transaction(&self) -> Transaction {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Transaction::new_unchecked(self.0.slice(start..end))
        } else {
            Transaction::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> IndexTransactionReader<'r> {
        IndexTransactionReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for IndexTransaction {
    type Builder = IndexTransactionBuilder;
    const NAME: &'static str = "IndexTransaction";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        IndexTransaction(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        IndexTransactionReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        IndexTransactionReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .index(self.index())
            .transaction(self.transaction())
    }
}
#[derive(Clone, Copy)]
pub struct IndexTransactionReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for IndexTransactionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for IndexTransactionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for IndexTransactionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "index", self.index())?;
        write!(f, ", {}: {}", "transaction", self.transaction())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> IndexTransactionReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn index(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn transaction(&self) -> TransactionReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            TransactionReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            TransactionReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for IndexTransactionReader<'r> {
    type Entity = IndexTransaction;
    const NAME: &'static str = "IndexTransactionReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        IndexTransactionReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        TransactionReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct IndexTransactionBuilder {
    pub(crate) index: Uint32,
    pub(crate) transaction: Transaction,
}
impl IndexTransactionBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn index(mut self, v: Uint32) -> Self {
        self.index = v;
        self
    }
    pub fn transaction(mut self, v: Transaction) -> Self {
        self.transaction = v;
        self
    }
}
impl molecule::prelude::Builder for IndexTransactionBuilder {
    type Entity = IndexTransaction;
    const NAME: &'static str = "IndexTransactionBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.index.as_slice().len()
            + self.transaction.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.index.as_slice().len();
        offsets.push(total_size);
        total_size += self.transaction.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.index.as_slice())?;
        writer.write_all(self.transaction.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        IndexTransaction::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct IndexTransactionVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for IndexTransactionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for IndexTransactionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for IndexTransactionVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for IndexTransactionVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        IndexTransactionVec::new_unchecked(v)
    }
}
impl IndexTransactionVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<IndexTransaction> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> IndexTransaction {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            IndexTransaction::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            IndexTransaction::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> IndexTransactionVecReader<'r> {
        IndexTransactionVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for IndexTransactionVec {
    type Builder = IndexTransactionVecBuilder;
    const NAME: &'static str = "IndexTransactionVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        IndexTransactionVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        IndexTransactionVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        IndexTransactionVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct IndexTransactionVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for IndexTransactionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for IndexTransactionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for IndexTransactionVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> IndexTransactionVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<IndexTransactionReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> IndexTransactionReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            IndexTransactionReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            IndexTransactionReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for IndexTransactionVecReader<'r> {
    type Entity = IndexTransactionVec;
    const NAME: &'static str = "IndexTransactionVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        IndexTransactionVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            IndexTransactionReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct IndexTransactionVecBuilder(pub(crate) Vec<IndexTransaction>);
impl IndexTransactionVecBuilder {
    pub fn set(mut self, v: Vec<IndexTransaction>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: IndexTransaction) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = IndexTransaction>>(
        mut self,
        iter: T,
    ) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: IndexTransaction) -> Option<IndexTransaction> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for IndexTransactionVecBuilder {
    type Entity = IndexTransactionVec;
    const NAME: &'static str = "IndexTransactionVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        IndexTransactionVec::new_unchecked(inner.into())
    }
}
pub struct IndexTransactionVecIterator(IndexTransactionVec, usize, usize);
impl ::core::iter::Iterator for IndexTransactionVecIterator {
    type Item = IndexTransaction;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for IndexTransactionVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for IndexTransactionVec {
    type Item = IndexTransaction;
    type IntoIter = IndexTransactionVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        IndexTransactionVecIterator(self, 0, len)
    }
}
impl<'r> IndexTransactionVecReader<'r> {
    pub fn iter<'t>(&'t self) -> IndexTransactionVecReaderIterator<'t, 'r> {
        IndexTransactionVecReaderIterator(&self, 0, self.len())
    }
}
pub struct IndexTransactionVecReaderIterator<'t, 'r>(
    &'t IndexTransactionVecReader<'r>,
    usize,
    usize,
);
impl<'t: 'r, 'r> ::core::iter::Iterator for IndexTransactionVecReaderIterator<'t, 'r> {
    type Item = IndexTransactionReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for IndexTransactionVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct BlockFilterMessage(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockFilterMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockFilterMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockFilterMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for BlockFilterMessage {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BlockFilterMessage::new_unchecked(v)
    }
}
impl BlockFilterMessage {
    const DEFAULT_VALUE: [u8; 12] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const ITEMS_COUNT: usize = 6;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> BlockFilterMessageUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => GetBlockFilters::new_unchecked(inner).into(),
            1 => BlockFilters::new_unchecked(inner).into(),
            2 => GetBlockFilterHashes::new_unchecked(inner).into(),
            3 => BlockFilterHashes::new_unchecked(inner).into(),
            4 => GetBlockFilterCheckPoints::new_unchecked(inner).into(),
            5 => BlockFilterCheckPoints::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockFilterMessageReader<'r> {
        BlockFilterMessageReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockFilterMessage {
    type Builder = BlockFilterMessageBuilder;
    const NAME: &'static str = "BlockFilterMessage";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockFilterMessage(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFilterMessageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFilterMessageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct BlockFilterMessageReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockFilterMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockFilterMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockFilterMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> BlockFilterMessageReader<'r> {
    pub const ITEMS_COUNT: usize = 6;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> BlockFilterMessageUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => GetBlockFiltersReader::new_unchecked(inner).into(),
            1 => BlockFiltersReader::new_unchecked(inner).into(),
            2 => GetBlockFilterHashesReader::new_unchecked(inner).into(),
            3 => BlockFilterHashesReader::new_unchecked(inner).into(),
            4 => GetBlockFilterCheckPointsReader::new_unchecked(inner).into(),
            5 => BlockFilterCheckPointsReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockFilterMessageReader<'r> {
    type Entity = BlockFilterMessage;
    const NAME: &'static str = "BlockFilterMessageReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockFilterMessageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => GetBlockFiltersReader::verify(inner_slice, compatible),
            1 => BlockFiltersReader::verify(inner_slice, compatible),
            2 => GetBlockFilterHashesReader::verify(inner_slice, compatible),
            3 => BlockFilterHashesReader::verify(inner_slice, compatible),
            4 => GetBlockFilterCheckPointsReader::verify(inner_slice, compatible),
            5 => BlockFilterCheckPointsReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockFilterMessageBuilder(pub(crate) BlockFilterMessageUnion);
impl BlockFilterMessageBuilder {
    pub const ITEMS_COUNT: usize = 6;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<BlockFilterMessageUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for BlockFilterMessageBuilder {
    type Entity = BlockFilterMessage;
    const NAME: &'static str = "BlockFilterMessageBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockFilterMessage::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum BlockFilterMessageUnion {
    GetBlockFilters(GetBlockFilters),
    BlockFilters(BlockFilters),
    GetBlockFilterHashes(GetBlockFilterHashes),
    BlockFilterHashes(BlockFilterHashes),
    GetBlockFilterCheckPoints(GetBlockFilterCheckPoints),
    BlockFilterCheckPoints(BlockFilterCheckPoints),
}
#[derive(Debug, Clone, Copy)]
pub enum BlockFilterMessageUnionReader<'r> {
    GetBlockFilters(GetBlockFiltersReader<'r>),
    BlockFilters(BlockFiltersReader<'r>),
    GetBlockFilterHashes(GetBlockFilterHashesReader<'r>),
    BlockFilterHashes(BlockFilterHashesReader<'r>),
    GetBlockFilterCheckPoints(GetBlockFilterCheckPointsReader<'r>),
    BlockFilterCheckPoints(BlockFilterCheckPointsReader<'r>),
}
impl ::core::default::Default for BlockFilterMessageUnion {
    fn default() -> Self {
        BlockFilterMessageUnion::GetBlockFilters(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for BlockFilterMessageUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BlockFilterMessageUnion::GetBlockFilters(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlockFilters::NAME, item)
            }
            BlockFilterMessageUnion::BlockFilters(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockFilters::NAME, item)
            }
            BlockFilterMessageUnion::GetBlockFilterHashes(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetBlockFilterHashes::NAME,
                    item
                )
            }
            BlockFilterMessageUnion::BlockFilterHashes(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockFilterHashes::NAME, item)
            }
            BlockFilterMessageUnion::GetBlockFilterCheckPoints(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetBlockFilterCheckPoints::NAME,
                    item
                )
            }
            BlockFilterMessageUnion::BlockFilterCheckPoints(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    BlockFilterCheckPoints::NAME,
                    item
                )
            }
        }
    }
}
impl<'r> ::core::fmt::Display for BlockFilterMessageUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BlockFilterMessageUnionReader::GetBlockFilters(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlockFilters::NAME, item)
            }
            BlockFilterMessageUnionReader::BlockFilters(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockFilters::NAME, item)
            }
            BlockFilterMessageUnionReader::GetBlockFilterHashes(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetBlockFilterHashes::NAME,
                    item
                )
            }
            BlockFilterMessageUnionReader::BlockFilterHashes(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, BlockFilterHashes::NAME, item)
            }
            BlockFilterMessageUnionReader::GetBlockFilterCheckPoints(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetBlockFilterCheckPoints::NAME,
                    item
                )
            }
            BlockFilterMessageUnionReader::BlockFilterCheckPoints(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    BlockFilterCheckPoints::NAME,
                    item
                )
            }
        }
    }
}
impl BlockFilterMessageUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BlockFilterMessageUnion::GetBlockFilters(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnion::BlockFilters(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnion::GetBlockFilterHashes(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnion::BlockFilterHashes(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnion::GetBlockFilterCheckPoints(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnion::BlockFilterCheckPoints(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> BlockFilterMessageUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            BlockFilterMessageUnionReader::GetBlockFilters(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnionReader::BlockFilters(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnionReader::GetBlockFilterHashes(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnionReader::BlockFilterHashes(ref item) => write!(f, "{}", item),
            BlockFilterMessageUnionReader::GetBlockFilterCheckPoints(ref item) => {
                write!(f, "{}", item)
            }
            BlockFilterMessageUnionReader::BlockFilterCheckPoints(ref item) => {
                write!(f, "{}", item)
            }
        }
    }
}
impl ::core::convert::From<GetBlockFilters> for BlockFilterMessageUnion {
    fn from(item: GetBlockFilters) -> Self {
        BlockFilterMessageUnion::GetBlockFilters(item)
    }
}
impl ::core::convert::From<BlockFilters> for BlockFilterMessageUnion {
    fn from(item: BlockFilters) -> Self {
        BlockFilterMessageUnion::BlockFilters(item)
    }
}
impl ::core::convert::From<GetBlockFilterHashes> for BlockFilterMessageUnion {
    fn from(item: GetBlockFilterHashes) -> Self {
        BlockFilterMessageUnion::GetBlockFilterHashes(item)
    }
}
impl ::core::convert::From<BlockFilterHashes> for BlockFilterMessageUnion {
    fn from(item: BlockFilterHashes) -> Self {
        BlockFilterMessageUnion::BlockFilterHashes(item)
    }
}
impl ::core::convert::From<GetBlockFilterCheckPoints> for BlockFilterMessageUnion {
    fn from(item: GetBlockFilterCheckPoints) -> Self {
        BlockFilterMessageUnion::GetBlockFilterCheckPoints(item)
    }
}
impl ::core::convert::From<BlockFilterCheckPoints> for BlockFilterMessageUnion {
    fn from(item: BlockFilterCheckPoints) -> Self {
        BlockFilterMessageUnion::BlockFilterCheckPoints(item)
    }
}
impl<'r> ::core::convert::From<GetBlockFiltersReader<'r>> for BlockFilterMessageUnionReader<'r> {
    fn from(item: GetBlockFiltersReader<'r>) -> Self {
        BlockFilterMessageUnionReader::GetBlockFilters(item)
    }
}
impl<'r> ::core::convert::From<BlockFiltersReader<'r>> for BlockFilterMessageUnionReader<'r> {
    fn from(item: BlockFiltersReader<'r>) -> Self {
        BlockFilterMessageUnionReader::BlockFilters(item)
    }
}
impl<'r> ::core::convert::From<GetBlockFilterHashesReader<'r>>
    for BlockFilterMessageUnionReader<'r>
{
    fn from(item: GetBlockFilterHashesReader<'r>) -> Self {
        BlockFilterMessageUnionReader::GetBlockFilterHashes(item)
    }
}
impl<'r> ::core::convert::From<BlockFilterHashesReader<'r>> for BlockFilterMessageUnionReader<'r> {
    fn from(item: BlockFilterHashesReader<'r>) -> Self {
        BlockFilterMessageUnionReader::BlockFilterHashes(item)
    }
}
impl<'r> ::core::convert::From<GetBlockFilterCheckPointsReader<'r>>
    for BlockFilterMessageUnionReader<'r>
{
    fn from(item: GetBlockFilterCheckPointsReader<'r>) -> Self {
        BlockFilterMessageUnionReader::GetBlockFilterCheckPoints(item)
    }
}
impl<'r> ::core::convert::From<BlockFilterCheckPointsReader<'r>>
    for BlockFilterMessageUnionReader<'r>
{
    fn from(item: BlockFilterCheckPointsReader<'r>) -> Self {
        BlockFilterMessageUnionReader::BlockFilterCheckPoints(item)
    }
}
impl BlockFilterMessageUnion {
    pub const NAME: &'static str = "BlockFilterMessageUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            BlockFilterMessageUnion::GetBlockFilters(item) => item.as_bytes(),
            BlockFilterMessageUnion::BlockFilters(item) => item.as_bytes(),
            BlockFilterMessageUnion::GetBlockFilterHashes(item) => item.as_bytes(),
            BlockFilterMessageUnion::BlockFilterHashes(item) => item.as_bytes(),
            BlockFilterMessageUnion::GetBlockFilterCheckPoints(item) => item.as_bytes(),
            BlockFilterMessageUnion::BlockFilterCheckPoints(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            BlockFilterMessageUnion::GetBlockFilters(item) => item.as_slice(),
            BlockFilterMessageUnion::BlockFilters(item) => item.as_slice(),
            BlockFilterMessageUnion::GetBlockFilterHashes(item) => item.as_slice(),
            BlockFilterMessageUnion::BlockFilterHashes(item) => item.as_slice(),
            BlockFilterMessageUnion::GetBlockFilterCheckPoints(item) => item.as_slice(),
            BlockFilterMessageUnion::BlockFilterCheckPoints(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            BlockFilterMessageUnion::GetBlockFilters(_) => 0,
            BlockFilterMessageUnion::BlockFilters(_) => 1,
            BlockFilterMessageUnion::GetBlockFilterHashes(_) => 2,
            BlockFilterMessageUnion::BlockFilterHashes(_) => 3,
            BlockFilterMessageUnion::GetBlockFilterCheckPoints(_) => 4,
            BlockFilterMessageUnion::BlockFilterCheckPoints(_) => 5,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            BlockFilterMessageUnion::GetBlockFilters(_) => "GetBlockFilters",
            BlockFilterMessageUnion::BlockFilters(_) => "BlockFilters",
            BlockFilterMessageUnion::GetBlockFilterHashes(_) => "GetBlockFilterHashes",
            BlockFilterMessageUnion::BlockFilterHashes(_) => "BlockFilterHashes",
            BlockFilterMessageUnion::GetBlockFilterCheckPoints(_) => "GetBlockFilterCheckPoints",
            BlockFilterMessageUnion::BlockFilterCheckPoints(_) => "BlockFilterCheckPoints",
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockFilterMessageUnionReader<'r> {
        match self {
            BlockFilterMessageUnion::GetBlockFilters(item) => item.as_reader().into(),
            BlockFilterMessageUnion::BlockFilters(item) => item.as_reader().into(),
            BlockFilterMessageUnion::GetBlockFilterHashes(item) => item.as_reader().into(),
            BlockFilterMessageUnion::BlockFilterHashes(item) => item.as_reader().into(),
            BlockFilterMessageUnion::GetBlockFilterCheckPoints(item) => item.as_reader().into(),
            BlockFilterMessageUnion::BlockFilterCheckPoints(item) => item.as_reader().into(),
        }
    }
}
impl<'r> BlockFilterMessageUnionReader<'r> {
    pub const NAME: &'r str = "BlockFilterMessageUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            BlockFilterMessageUnionReader::GetBlockFilters(item) => item.as_slice(),
            BlockFilterMessageUnionReader::BlockFilters(item) => item.as_slice(),
            BlockFilterMessageUnionReader::GetBlockFilterHashes(item) => item.as_slice(),
            BlockFilterMessageUnionReader::BlockFilterHashes(item) => item.as_slice(),
            BlockFilterMessageUnionReader::GetBlockFilterCheckPoints(item) => item.as_slice(),
            BlockFilterMessageUnionReader::BlockFilterCheckPoints(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            BlockFilterMessageUnionReader::GetBlockFilters(_) => 0,
            BlockFilterMessageUnionReader::BlockFilters(_) => 1,
            BlockFilterMessageUnionReader::GetBlockFilterHashes(_) => 2,
            BlockFilterMessageUnionReader::BlockFilterHashes(_) => 3,
            BlockFilterMessageUnionReader::GetBlockFilterCheckPoints(_) => 4,
            BlockFilterMessageUnionReader::BlockFilterCheckPoints(_) => 5,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            BlockFilterMessageUnionReader::GetBlockFilters(_) => "GetBlockFilters",
            BlockFilterMessageUnionReader::BlockFilters(_) => "BlockFilters",
            BlockFilterMessageUnionReader::GetBlockFilterHashes(_) => "GetBlockFilterHashes",
            BlockFilterMessageUnionReader::BlockFilterHashes(_) => "BlockFilterHashes",
            BlockFilterMessageUnionReader::GetBlockFilterCheckPoints(_) => {
                "GetBlockFilterCheckPoints"
            }
            BlockFilterMessageUnionReader::BlockFilterCheckPoints(_) => "BlockFilterCheckPoints",
        }
    }
}
#[derive(Clone)]
pub struct GetBlockFilters(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetBlockFilters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetBlockFilters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetBlockFilters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetBlockFilters {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        GetBlockFilters::new_unchecked(v)
    }
}
impl GetBlockFilters {
    const DEFAULT_VALUE: [u8; 8] = [0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(0..8))
    }
    pub fn as_reader<'r>(&'r self) -> GetBlockFiltersReader<'r> {
        GetBlockFiltersReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetBlockFilters {
    type Builder = GetBlockFiltersBuilder;
    const NAME: &'static str = "GetBlockFilters";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetBlockFilters(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockFiltersReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockFiltersReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().start_number(self.start_number())
    }
}
#[derive(Clone, Copy)]
pub struct GetBlockFiltersReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetBlockFiltersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetBlockFiltersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetBlockFiltersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, " }}")
    }
}
impl<'r> GetBlockFiltersReader<'r> {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[0..8])
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetBlockFiltersReader<'r> {
    type Entity = GetBlockFilters;
    const NAME: &'static str = "GetBlockFiltersReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetBlockFiltersReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetBlockFiltersBuilder {
    pub(crate) start_number: Uint64,
}
impl GetBlockFiltersBuilder {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
}
impl molecule::prelude::Builder for GetBlockFiltersBuilder {
    type Entity = GetBlockFilters;
    const NAME: &'static str = "GetBlockFiltersBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.start_number.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetBlockFilters::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlockFilters(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockFilters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockFilters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockFilters {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, ", {}: {}", "block_hashes", self.block_hashes())?;
        write!(f, ", {}: {}", "filters", self.filters())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BlockFilters {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BlockFilters::new_unchecked(v)
    }
}
impl BlockFilters {
    const DEFAULT_VALUE: [u8; 32] = [
        32, 0, 0, 0, 16, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4,
        0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn start_number(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn block_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn filters(&self) -> BytesVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesVec::new_unchecked(self.0.slice(start..end))
        } else {
            BytesVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockFiltersReader<'r> {
        BlockFiltersReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockFilters {
    type Builder = BlockFiltersBuilder;
    const NAME: &'static str = "BlockFilters";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockFilters(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFiltersReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFiltersReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .start_number(self.start_number())
            .block_hashes(self.block_hashes())
            .filters(self.filters())
    }
}
#[derive(Clone, Copy)]
pub struct BlockFiltersReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockFiltersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockFiltersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockFiltersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, ", {}: {}", "block_hashes", self.block_hashes())?;
        write!(f, ", {}: {}", "filters", self.filters())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BlockFiltersReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn start_number(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn block_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn filters(&self) -> BytesVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockFiltersReader<'r> {
    type Entity = BlockFilters;
    const NAME: &'static str = "BlockFiltersReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockFiltersReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockFiltersBuilder {
    pub(crate) start_number: Uint64,
    pub(crate) block_hashes: Byte32Vec,
    pub(crate) filters: BytesVec,
}
impl BlockFiltersBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
    pub fn block_hashes(mut self, v: Byte32Vec) -> Self {
        self.block_hashes = v;
        self
    }
    pub fn filters(mut self, v: BytesVec) -> Self {
        self.filters = v;
        self
    }
}
impl molecule::prelude::Builder for BlockFiltersBuilder {
    type Entity = BlockFilters;
    const NAME: &'static str = "BlockFiltersBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.start_number.as_slice().len()
            + self.block_hashes.as_slice().len()
            + self.filters.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.start_number.as_slice().len();
        offsets.push(total_size);
        total_size += self.block_hashes.as_slice().len();
        offsets.push(total_size);
        total_size += self.filters.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.start_number.as_slice())?;
        writer.write_all(self.block_hashes.as_slice())?;
        writer.write_all(self.filters.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockFilters::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetBlockFilterHashes(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetBlockFilterHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetBlockFilterHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetBlockFilterHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetBlockFilterHashes {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        GetBlockFilterHashes::new_unchecked(v)
    }
}
impl GetBlockFilterHashes {
    const DEFAULT_VALUE: [u8; 8] = [0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(0..8))
    }
    pub fn as_reader<'r>(&'r self) -> GetBlockFilterHashesReader<'r> {
        GetBlockFilterHashesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetBlockFilterHashes {
    type Builder = GetBlockFilterHashesBuilder;
    const NAME: &'static str = "GetBlockFilterHashes";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetBlockFilterHashes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockFilterHashesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockFilterHashesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().start_number(self.start_number())
    }
}
#[derive(Clone, Copy)]
pub struct GetBlockFilterHashesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetBlockFilterHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetBlockFilterHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetBlockFilterHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, " }}")
    }
}
impl<'r> GetBlockFilterHashesReader<'r> {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[0..8])
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetBlockFilterHashesReader<'r> {
    type Entity = GetBlockFilterHashes;
    const NAME: &'static str = "GetBlockFilterHashesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetBlockFilterHashesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetBlockFilterHashesBuilder {
    pub(crate) start_number: Uint64,
}
impl GetBlockFilterHashesBuilder {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
}
impl molecule::prelude::Builder for GetBlockFilterHashesBuilder {
    type Entity = GetBlockFilterHashes;
    const NAME: &'static str = "GetBlockFilterHashesBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.start_number.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetBlockFilterHashes::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlockFilterHashes(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockFilterHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockFilterHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockFilterHashes {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(
            f,
            ", {}: {}",
            "parent_block_filter_hash",
            self.parent_block_filter_hash()
        )?;
        write!(
            f,
            ", {}: {}",
            "block_filter_hashes",
            self.block_filter_hashes()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BlockFilterHashes {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BlockFilterHashes::new_unchecked(v)
    }
}
impl BlockFilterHashes {
    const DEFAULT_VALUE: [u8; 60] = [
        60, 0, 0, 0, 16, 0, 0, 0, 24, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn start_number(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn parent_block_filter_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn block_filter_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockFilterHashesReader<'r> {
        BlockFilterHashesReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockFilterHashes {
    type Builder = BlockFilterHashesBuilder;
    const NAME: &'static str = "BlockFilterHashes";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockFilterHashes(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFilterHashesReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFilterHashesReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .start_number(self.start_number())
            .parent_block_filter_hash(self.parent_block_filter_hash())
            .block_filter_hashes(self.block_filter_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct BlockFilterHashesReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockFilterHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockFilterHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockFilterHashesReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(
            f,
            ", {}: {}",
            "parent_block_filter_hash",
            self.parent_block_filter_hash()
        )?;
        write!(
            f,
            ", {}: {}",
            "block_filter_hashes",
            self.block_filter_hashes()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BlockFilterHashesReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn start_number(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn parent_block_filter_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn block_filter_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockFilterHashesReader<'r> {
    type Entity = BlockFilterHashes;
    const NAME: &'static str = "BlockFilterHashesReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockFilterHashesReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockFilterHashesBuilder {
    pub(crate) start_number: Uint64,
    pub(crate) parent_block_filter_hash: Byte32,
    pub(crate) block_filter_hashes: Byte32Vec,
}
impl BlockFilterHashesBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
    pub fn parent_block_filter_hash(mut self, v: Byte32) -> Self {
        self.parent_block_filter_hash = v;
        self
    }
    pub fn block_filter_hashes(mut self, v: Byte32Vec) -> Self {
        self.block_filter_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for BlockFilterHashesBuilder {
    type Entity = BlockFilterHashes;
    const NAME: &'static str = "BlockFilterHashesBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.start_number.as_slice().len()
            + self.parent_block_filter_hash.as_slice().len()
            + self.block_filter_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.start_number.as_slice().len();
        offsets.push(total_size);
        total_size += self.parent_block_filter_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.block_filter_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.start_number.as_slice())?;
        writer.write_all(self.parent_block_filter_hash.as_slice())?;
        writer.write_all(self.block_filter_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockFilterHashes::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetBlockFilterCheckPoints(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetBlockFilterCheckPoints {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetBlockFilterCheckPoints {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetBlockFilterCheckPoints {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetBlockFilterCheckPoints {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        GetBlockFilterCheckPoints::new_unchecked(v)
    }
}
impl GetBlockFilterCheckPoints {
    const DEFAULT_VALUE: [u8; 8] = [0, 0, 0, 0, 0, 0, 0, 0];
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(&self) -> Uint64 {
        Uint64::new_unchecked(self.0.slice(0..8))
    }
    pub fn as_reader<'r>(&'r self) -> GetBlockFilterCheckPointsReader<'r> {
        GetBlockFilterCheckPointsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetBlockFilterCheckPoints {
    type Builder = GetBlockFilterCheckPointsBuilder;
    const NAME: &'static str = "GetBlockFilterCheckPoints";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetBlockFilterCheckPoints(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockFilterCheckPointsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlockFilterCheckPointsReader::from_compatible_slice(slice)
            .map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().start_number(self.start_number())
    }
}
#[derive(Clone, Copy)]
pub struct GetBlockFilterCheckPointsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetBlockFilterCheckPointsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetBlockFilterCheckPointsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetBlockFilterCheckPointsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(f, " }}")
    }
}
impl<'r> GetBlockFilterCheckPointsReader<'r> {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(&self) -> Uint64Reader<'r> {
        Uint64Reader::new_unchecked(&self.as_slice()[0..8])
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetBlockFilterCheckPointsReader<'r> {
    type Entity = GetBlockFilterCheckPoints;
    const NAME: &'static str = "GetBlockFilterCheckPointsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetBlockFilterCheckPointsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len != Self::TOTAL_SIZE {
            return ve!(Self, TotalSizeNotMatch, Self::TOTAL_SIZE, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetBlockFilterCheckPointsBuilder {
    pub(crate) start_number: Uint64,
}
impl GetBlockFilterCheckPointsBuilder {
    pub const TOTAL_SIZE: usize = 8;
    pub const FIELD_SIZES: [usize; 1] = [8];
    pub const FIELD_COUNT: usize = 1;
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
}
impl molecule::prelude::Builder for GetBlockFilterCheckPointsBuilder {
    type Entity = GetBlockFilterCheckPoints;
    const NAME: &'static str = "GetBlockFilterCheckPointsBuilder";
    fn expected_length(&self) -> usize {
        Self::TOTAL_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(self.start_number.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetBlockFilterCheckPoints::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct BlockFilterCheckPoints(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for BlockFilterCheckPoints {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for BlockFilterCheckPoints {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for BlockFilterCheckPoints {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(
            f,
            ", {}: {}",
            "block_filter_hashes",
            self.block_filter_hashes()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for BlockFilterCheckPoints {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        BlockFilterCheckPoints::new_unchecked(v)
    }
}
impl BlockFilterCheckPoints {
    const DEFAULT_VALUE: [u8; 24] = [
        24, 0, 0, 0, 12, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn start_number(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn block_filter_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> BlockFilterCheckPointsReader<'r> {
        BlockFilterCheckPointsReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for BlockFilterCheckPoints {
    type Builder = BlockFilterCheckPointsBuilder;
    const NAME: &'static str = "BlockFilterCheckPoints";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        BlockFilterCheckPoints(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFilterCheckPointsReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        BlockFilterCheckPointsReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .start_number(self.start_number())
            .block_filter_hashes(self.block_filter_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct BlockFilterCheckPointsReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for BlockFilterCheckPointsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for BlockFilterCheckPointsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for BlockFilterCheckPointsReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "start_number", self.start_number())?;
        write!(
            f,
            ", {}: {}",
            "block_filter_hashes",
            self.block_filter_hashes()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> BlockFilterCheckPointsReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn start_number(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn block_filter_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for BlockFilterCheckPointsReader<'r> {
    type Entity = BlockFilterCheckPoints;
    const NAME: &'static str = "BlockFilterCheckPointsReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        BlockFilterCheckPointsReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct BlockFilterCheckPointsBuilder {
    pub(crate) start_number: Uint64,
    pub(crate) block_filter_hashes: Byte32Vec,
}
impl BlockFilterCheckPointsBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
    pub fn block_filter_hashes(mut self, v: Byte32Vec) -> Self {
        self.block_filter_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for BlockFilterCheckPointsBuilder {
    type Entity = BlockFilterCheckPoints;
    const NAME: &'static str = "BlockFilterCheckPointsBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.start_number.as_slice().len()
            + self.block_filter_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.start_number.as_slice().len();
        offsets.push(total_size);
        total_size += self.block_filter_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.start_number.as_slice())?;
        writer.write_all(self.block_filter_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        BlockFilterCheckPoints::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SyncMessage(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SyncMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SyncMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SyncMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for SyncMessage {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SyncMessage::new_unchecked(v)
    }
}
impl SyncMessage {
    const DEFAULT_VALUE: [u8; 52] = [
        0, 0, 0, 0, 48, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const ITEMS_COUNT: usize = 5;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> SyncMessageUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => GetHeaders::new_unchecked(inner).into(),
            1 => SendHeaders::new_unchecked(inner).into(),
            2 => GetBlocks::new_unchecked(inner).into(),
            3 => SendBlock::new_unchecked(inner).into(),
            8 => InIBD::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> SyncMessageReader<'r> {
        SyncMessageReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SyncMessage {
    type Builder = SyncMessageBuilder;
    const NAME: &'static str = "SyncMessage";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SyncMessage(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SyncMessageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SyncMessageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct SyncMessageReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SyncMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SyncMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SyncMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> SyncMessageReader<'r> {
    pub const ITEMS_COUNT: usize = 5;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> SyncMessageUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => GetHeadersReader::new_unchecked(inner).into(),
            1 => SendHeadersReader::new_unchecked(inner).into(),
            2 => GetBlocksReader::new_unchecked(inner).into(),
            3 => SendBlockReader::new_unchecked(inner).into(),
            8 => InIBDReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SyncMessageReader<'r> {
    type Entity = SyncMessage;
    const NAME: &'static str = "SyncMessageReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SyncMessageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => GetHeadersReader::verify(inner_slice, compatible),
            1 => SendHeadersReader::verify(inner_slice, compatible),
            2 => GetBlocksReader::verify(inner_slice, compatible),
            3 => SendBlockReader::verify(inner_slice, compatible),
            8 => InIBDReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SyncMessageBuilder(pub(crate) SyncMessageUnion);
impl SyncMessageBuilder {
    pub const ITEMS_COUNT: usize = 5;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<SyncMessageUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for SyncMessageBuilder {
    type Entity = SyncMessage;
    const NAME: &'static str = "SyncMessageBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SyncMessage::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum SyncMessageUnion {
    GetHeaders(GetHeaders),
    SendHeaders(SendHeaders),
    GetBlocks(GetBlocks),
    SendBlock(SendBlock),
    InIBD(InIBD),
}
#[derive(Debug, Clone, Copy)]
pub enum SyncMessageUnionReader<'r> {
    GetHeaders(GetHeadersReader<'r>),
    SendHeaders(SendHeadersReader<'r>),
    GetBlocks(GetBlocksReader<'r>),
    SendBlock(SendBlockReader<'r>),
    InIBD(InIBDReader<'r>),
}
impl ::core::default::Default for SyncMessageUnion {
    fn default() -> Self {
        SyncMessageUnion::GetHeaders(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for SyncMessageUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SyncMessageUnion::GetHeaders(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetHeaders::NAME, item)
            }
            SyncMessageUnion::SendHeaders(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendHeaders::NAME, item)
            }
            SyncMessageUnion::GetBlocks(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlocks::NAME, item)
            }
            SyncMessageUnion::SendBlock(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendBlock::NAME, item)
            }
            SyncMessageUnion::InIBD(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, InIBD::NAME, item)
            }
        }
    }
}
impl<'r> ::core::fmt::Display for SyncMessageUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SyncMessageUnionReader::GetHeaders(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetHeaders::NAME, item)
            }
            SyncMessageUnionReader::SendHeaders(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendHeaders::NAME, item)
            }
            SyncMessageUnionReader::GetBlocks(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlocks::NAME, item)
            }
            SyncMessageUnionReader::SendBlock(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendBlock::NAME, item)
            }
            SyncMessageUnionReader::InIBD(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, InIBD::NAME, item)
            }
        }
    }
}
impl SyncMessageUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SyncMessageUnion::GetHeaders(ref item) => write!(f, "{}", item),
            SyncMessageUnion::SendHeaders(ref item) => write!(f, "{}", item),
            SyncMessageUnion::GetBlocks(ref item) => write!(f, "{}", item),
            SyncMessageUnion::SendBlock(ref item) => write!(f, "{}", item),
            SyncMessageUnion::InIBD(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> SyncMessageUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            SyncMessageUnionReader::GetHeaders(ref item) => write!(f, "{}", item),
            SyncMessageUnionReader::SendHeaders(ref item) => write!(f, "{}", item),
            SyncMessageUnionReader::GetBlocks(ref item) => write!(f, "{}", item),
            SyncMessageUnionReader::SendBlock(ref item) => write!(f, "{}", item),
            SyncMessageUnionReader::InIBD(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<GetHeaders> for SyncMessageUnion {
    fn from(item: GetHeaders) -> Self {
        SyncMessageUnion::GetHeaders(item)
    }
}
impl ::core::convert::From<SendHeaders> for SyncMessageUnion {
    fn from(item: SendHeaders) -> Self {
        SyncMessageUnion::SendHeaders(item)
    }
}
impl ::core::convert::From<GetBlocks> for SyncMessageUnion {
    fn from(item: GetBlocks) -> Self {
        SyncMessageUnion::GetBlocks(item)
    }
}
impl ::core::convert::From<SendBlock> for SyncMessageUnion {
    fn from(item: SendBlock) -> Self {
        SyncMessageUnion::SendBlock(item)
    }
}
impl ::core::convert::From<InIBD> for SyncMessageUnion {
    fn from(item: InIBD) -> Self {
        SyncMessageUnion::InIBD(item)
    }
}
impl<'r> ::core::convert::From<GetHeadersReader<'r>> for SyncMessageUnionReader<'r> {
    fn from(item: GetHeadersReader<'r>) -> Self {
        SyncMessageUnionReader::GetHeaders(item)
    }
}
impl<'r> ::core::convert::From<SendHeadersReader<'r>> for SyncMessageUnionReader<'r> {
    fn from(item: SendHeadersReader<'r>) -> Self {
        SyncMessageUnionReader::SendHeaders(item)
    }
}
impl<'r> ::core::convert::From<GetBlocksReader<'r>> for SyncMessageUnionReader<'r> {
    fn from(item: GetBlocksReader<'r>) -> Self {
        SyncMessageUnionReader::GetBlocks(item)
    }
}
impl<'r> ::core::convert::From<SendBlockReader<'r>> for SyncMessageUnionReader<'r> {
    fn from(item: SendBlockReader<'r>) -> Self {
        SyncMessageUnionReader::SendBlock(item)
    }
}
impl<'r> ::core::convert::From<InIBDReader<'r>> for SyncMessageUnionReader<'r> {
    fn from(item: InIBDReader<'r>) -> Self {
        SyncMessageUnionReader::InIBD(item)
    }
}
impl SyncMessageUnion {
    pub const NAME: &'static str = "SyncMessageUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            SyncMessageUnion::GetHeaders(item) => item.as_bytes(),
            SyncMessageUnion::SendHeaders(item) => item.as_bytes(),
            SyncMessageUnion::GetBlocks(item) => item.as_bytes(),
            SyncMessageUnion::SendBlock(item) => item.as_bytes(),
            SyncMessageUnion::InIBD(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            SyncMessageUnion::GetHeaders(item) => item.as_slice(),
            SyncMessageUnion::SendHeaders(item) => item.as_slice(),
            SyncMessageUnion::GetBlocks(item) => item.as_slice(),
            SyncMessageUnion::SendBlock(item) => item.as_slice(),
            SyncMessageUnion::InIBD(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            SyncMessageUnion::GetHeaders(_) => 0,
            SyncMessageUnion::SendHeaders(_) => 1,
            SyncMessageUnion::GetBlocks(_) => 2,
            SyncMessageUnion::SendBlock(_) => 3,
            SyncMessageUnion::InIBD(_) => 8,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            SyncMessageUnion::GetHeaders(_) => "GetHeaders",
            SyncMessageUnion::SendHeaders(_) => "SendHeaders",
            SyncMessageUnion::GetBlocks(_) => "GetBlocks",
            SyncMessageUnion::SendBlock(_) => "SendBlock",
            SyncMessageUnion::InIBD(_) => "InIBD",
        }
    }
    pub fn as_reader<'r>(&'r self) -> SyncMessageUnionReader<'r> {
        match self {
            SyncMessageUnion::GetHeaders(item) => item.as_reader().into(),
            SyncMessageUnion::SendHeaders(item) => item.as_reader().into(),
            SyncMessageUnion::GetBlocks(item) => item.as_reader().into(),
            SyncMessageUnion::SendBlock(item) => item.as_reader().into(),
            SyncMessageUnion::InIBD(item) => item.as_reader().into(),
        }
    }
}
impl<'r> SyncMessageUnionReader<'r> {
    pub const NAME: &'r str = "SyncMessageUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            SyncMessageUnionReader::GetHeaders(item) => item.as_slice(),
            SyncMessageUnionReader::SendHeaders(item) => item.as_slice(),
            SyncMessageUnionReader::GetBlocks(item) => item.as_slice(),
            SyncMessageUnionReader::SendBlock(item) => item.as_slice(),
            SyncMessageUnionReader::InIBD(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            SyncMessageUnionReader::GetHeaders(_) => 0,
            SyncMessageUnionReader::SendHeaders(_) => 1,
            SyncMessageUnionReader::GetBlocks(_) => 2,
            SyncMessageUnionReader::SendBlock(_) => 3,
            SyncMessageUnionReader::InIBD(_) => 8,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            SyncMessageUnionReader::GetHeaders(_) => "GetHeaders",
            SyncMessageUnionReader::SendHeaders(_) => "SendHeaders",
            SyncMessageUnionReader::GetBlocks(_) => "GetBlocks",
            SyncMessageUnionReader::SendBlock(_) => "SendBlock",
            SyncMessageUnionReader::InIBD(_) => "InIBD",
        }
    }
}
#[derive(Clone)]
pub struct GetHeaders(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetHeaders {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetHeaders {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetHeaders {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash_stop", self.hash_stop())?;
        write!(
            f,
            ", {}: {}",
            "block_locator_hashes",
            self.block_locator_hashes()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetHeaders {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        GetHeaders::new_unchecked(v)
    }
}
impl GetHeaders {
    const DEFAULT_VALUE: [u8; 48] = [
        48, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn hash_stop(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn block_locator_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetHeadersReader<'r> {
        GetHeadersReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetHeaders {
    type Builder = GetHeadersBuilder;
    const NAME: &'static str = "GetHeaders";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetHeaders(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetHeadersReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetHeadersReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .hash_stop(self.hash_stop())
            .block_locator_hashes(self.block_locator_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct GetHeadersReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetHeadersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetHeadersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetHeadersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "hash_stop", self.hash_stop())?;
        write!(
            f,
            ", {}: {}",
            "block_locator_hashes",
            self.block_locator_hashes()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetHeadersReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn hash_stop(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn block_locator_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetHeadersReader<'r> {
    type Entity = GetHeaders;
    const NAME: &'static str = "GetHeadersReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetHeadersReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetHeadersBuilder {
    pub(crate) hash_stop: Byte32,
    pub(crate) block_locator_hashes: Byte32Vec,
}
impl GetHeadersBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn hash_stop(mut self, v: Byte32) -> Self {
        self.hash_stop = v;
        self
    }
    pub fn block_locator_hashes(mut self, v: Byte32Vec) -> Self {
        self.block_locator_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for GetHeadersBuilder {
    type Entity = GetHeaders;
    const NAME: &'static str = "GetHeadersBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.hash_stop.as_slice().len()
            + self.block_locator_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.hash_stop.as_slice().len();
        offsets.push(total_size);
        total_size += self.block_locator_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.hash_stop.as_slice())?;
        writer.write_all(self.block_locator_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetHeaders::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetBlocks(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetBlocks {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetBlocks {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetBlocks {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hashes", self.block_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetBlocks {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        GetBlocks::new_unchecked(v)
    }
}
impl GetBlocks {
    const DEFAULT_VALUE: [u8; 12] = [12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetBlocksReader<'r> {
        GetBlocksReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetBlocks {
    type Builder = GetBlocksBuilder;
    const NAME: &'static str = "GetBlocks";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetBlocks(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlocksReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlocksReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().block_hashes(self.block_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct GetBlocksReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetBlocksReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetBlocksReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetBlocksReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block_hashes", self.block_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetBlocksReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetBlocksReader<'r> {
    type Entity = GetBlocks;
    const NAME: &'static str = "GetBlocksReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetBlocksReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32VecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetBlocksBuilder {
    pub(crate) block_hashes: Byte32Vec,
}
impl GetBlocksBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn block_hashes(mut self, v: Byte32Vec) -> Self {
        self.block_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for GetBlocksBuilder {
    type Entity = GetBlocks;
    const NAME: &'static str = "GetBlocksBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.block_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.block_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.block_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetBlocks::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SendHeaders(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SendHeaders {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SendHeaders {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SendHeaders {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "headers", self.headers())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SendHeaders {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SendHeaders::new_unchecked(v)
    }
}
impl SendHeaders {
    const DEFAULT_VALUE: [u8; 12] = [12, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn headers(&self) -> HeaderVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            HeaderVec::new_unchecked(self.0.slice(start..end))
        } else {
            HeaderVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SendHeadersReader<'r> {
        SendHeadersReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SendHeaders {
    type Builder = SendHeadersBuilder;
    const NAME: &'static str = "SendHeaders";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SendHeaders(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendHeadersReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendHeadersReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().headers(self.headers())
    }
}
#[derive(Clone, Copy)]
pub struct SendHeadersReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SendHeadersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SendHeadersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SendHeadersReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "headers", self.headers())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SendHeadersReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn headers(&self) -> HeaderVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            HeaderVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            HeaderVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SendHeadersReader<'r> {
    type Entity = SendHeaders;
    const NAME: &'static str = "SendHeadersReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SendHeadersReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HeaderVecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SendHeadersBuilder {
    pub(crate) headers: HeaderVec,
}
impl SendHeadersBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn headers(mut self, v: HeaderVec) -> Self {
        self.headers = v;
        self
    }
}
impl molecule::prelude::Builder for SendHeadersBuilder {
    type Entity = SendHeaders;
    const NAME: &'static str = "SendHeadersBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.headers.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.headers.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.headers.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SendHeaders::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SendBlock(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SendBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SendBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SendBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block", self.block())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SendBlock {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SendBlock::new_unchecked(v)
    }
}
impl SendBlock {
    const DEFAULT_VALUE: [u8; 248] = [
        248, 0, 0, 0, 8, 0, 0, 0, 240, 0, 0, 0, 20, 0, 0, 0, 228, 0, 0, 0, 232, 0, 0, 0, 236, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4,
        0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block(&self) -> Block {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Block::new_unchecked(self.0.slice(start..end))
        } else {
            Block::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SendBlockReader<'r> {
        SendBlockReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SendBlock {
    type Builder = SendBlockBuilder;
    const NAME: &'static str = "SendBlock";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SendBlock(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendBlockReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendBlockReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().block(self.block())
    }
}
#[derive(Clone, Copy)]
pub struct SendBlockReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SendBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SendBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SendBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "block", self.block())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SendBlockReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn block(&self) -> BlockReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            BlockReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BlockReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SendBlockReader<'r> {
    type Entity = SendBlock;
    const NAME: &'static str = "SendBlockReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SendBlockReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BlockReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SendBlockBuilder {
    pub(crate) block: Block,
}
impl SendBlockBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn block(mut self, v: Block) -> Self {
        self.block = v;
        self
    }
}
impl molecule::prelude::Builder for SendBlockBuilder {
    type Entity = SendBlock;
    const NAME: &'static str = "SendBlockBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.block.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.block.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.block.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SendBlock::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct FilteredBlock(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for FilteredBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for FilteredBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for FilteredBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "witnesses_root", self.witnesses_root())?;
        write!(f, ", {}: {}", "transactions", self.transactions())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for FilteredBlock {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        FilteredBlock::new_unchecked(v)
    }
}
impl FilteredBlock {
    const DEFAULT_VALUE: [u8; 284] = [
        28, 1, 0, 0, 20, 0, 0, 0, 228, 0, 0, 0, 4, 1, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 20, 0, 0, 0, 12,
        0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> Header {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Header::new_unchecked(self.0.slice(start..end))
    }
    pub fn witnesses_root(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn transactions(&self) -> TransactionVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        TransactionVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn proof(&self) -> MerkleProof {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            MerkleProof::new_unchecked(self.0.slice(start..end))
        } else {
            MerkleProof::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> FilteredBlockReader<'r> {
        FilteredBlockReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for FilteredBlock {
    type Builder = FilteredBlockBuilder;
    const NAME: &'static str = "FilteredBlock";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        FilteredBlock(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FilteredBlockReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FilteredBlockReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .header(self.header())
            .witnesses_root(self.witnesses_root())
            .transactions(self.transactions())
            .proof(self.proof())
    }
}
#[derive(Clone, Copy)]
pub struct FilteredBlockReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for FilteredBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for FilteredBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for FilteredBlockReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "witnesses_root", self.witnesses_root())?;
        write!(f, ", {}: {}", "transactions", self.transactions())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> FilteredBlockReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> HeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn witnesses_root(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn transactions(&self) -> TransactionVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        TransactionVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proof(&self) -> MerkleProofReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            MerkleProofReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            MerkleProofReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for FilteredBlockReader<'r> {
    type Entity = FilteredBlock;
    const NAME: &'static str = "FilteredBlockReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        FilteredBlockReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        TransactionVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        MerkleProofReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct FilteredBlockBuilder {
    pub(crate) header: Header,
    pub(crate) witnesses_root: Byte32,
    pub(crate) transactions: TransactionVec,
    pub(crate) proof: MerkleProof,
}
impl FilteredBlockBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn header(mut self, v: Header) -> Self {
        self.header = v;
        self
    }
    pub fn witnesses_root(mut self, v: Byte32) -> Self {
        self.witnesses_root = v;
        self
    }
    pub fn transactions(mut self, v: TransactionVec) -> Self {
        self.transactions = v;
        self
    }
    pub fn proof(mut self, v: MerkleProof) -> Self {
        self.proof = v;
        self
    }
}
impl molecule::prelude::Builder for FilteredBlockBuilder {
    type Entity = FilteredBlock;
    const NAME: &'static str = "FilteredBlockBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.header.as_slice().len()
            + self.witnesses_root.as_slice().len()
            + self.transactions.as_slice().len()
            + self.proof.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.header.as_slice().len();
        offsets.push(total_size);
        total_size += self.witnesses_root.as_slice().len();
        offsets.push(total_size);
        total_size += self.transactions.as_slice().len();
        offsets.push(total_size);
        total_size += self.proof.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.header.as_slice())?;
        writer.write_all(self.witnesses_root.as_slice())?;
        writer.write_all(self.transactions.as_slice())?;
        writer.write_all(self.proof.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        FilteredBlock::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct MerkleProof(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for MerkleProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for MerkleProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for MerkleProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "indices", self.indices())?;
        write!(f, ", {}: {}", "lemmas", self.lemmas())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for MerkleProof {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        MerkleProof::new_unchecked(v)
    }
}
impl MerkleProof {
    const DEFAULT_VALUE: [u8; 20] = [
        20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn indices(&self) -> Uint32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn lemmas(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> MerkleProofReader<'r> {
        MerkleProofReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for MerkleProof {
    type Builder = MerkleProofBuilder;
    const NAME: &'static str = "MerkleProof";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        MerkleProof(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MerkleProofReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        MerkleProofReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .indices(self.indices())
            .lemmas(self.lemmas())
    }
}
#[derive(Clone, Copy)]
pub struct MerkleProofReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for MerkleProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for MerkleProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for MerkleProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "indices", self.indices())?;
        write!(f, ", {}: {}", "lemmas", self.lemmas())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> MerkleProofReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn indices(&self) -> Uint32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn lemmas(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for MerkleProofReader<'r> {
    type Entity = MerkleProof;
    const NAME: &'static str = "MerkleProofReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        MerkleProofReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint32VecReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct MerkleProofBuilder {
    pub(crate) indices: Uint32Vec,
    pub(crate) lemmas: Byte32Vec,
}
impl MerkleProofBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn indices(mut self, v: Uint32Vec) -> Self {
        self.indices = v;
        self
    }
    pub fn lemmas(mut self, v: Byte32Vec) -> Self {
        self.lemmas = v;
        self
    }
}
impl molecule::prelude::Builder for MerkleProofBuilder {
    type Entity = MerkleProof;
    const NAME: &'static str = "MerkleProofBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.indices.as_slice().len()
            + self.lemmas.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.indices.as_slice().len();
        offsets.push(total_size);
        total_size += self.lemmas.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.indices.as_slice())?;
        writer.write_all(self.lemmas.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        MerkleProof::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct InIBD(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for InIBD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for InIBD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for InIBD {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ".. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for InIBD {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        InIBD::new_unchecked(v)
    }
}
impl InIBD {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub const FIELD_COUNT: usize = 0;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn as_reader<'r>(&'r self) -> InIBDReader<'r> {
        InIBDReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for InIBD {
    type Builder = InIBDBuilder;
    const NAME: &'static str = "InIBD";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        InIBD(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        InIBDReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        InIBDReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
    }
}
#[derive(Clone, Copy)]
pub struct InIBDReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for InIBDReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for InIBDReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for InIBDReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ".. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> InIBDReader<'r> {
    pub const FIELD_COUNT: usize = 0;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
}
impl<'r> molecule::prelude::Reader<'r> for InIBDReader<'r> {
    type Entity = InIBD;
    const NAME: &'static str = "InIBDReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        InIBDReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len > molecule::NUMBER_SIZE && !compatible {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, !0);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct InIBDBuilder {}
impl InIBDBuilder {
    pub const FIELD_COUNT: usize = 0;
}
impl molecule::prelude::Builder for InIBDBuilder {
    type Entity = InIBD;
    const NAME: &'static str = "InIBDBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(
            molecule::NUMBER_SIZE as molecule::Number,
        ))?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        InIBD::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct HeaderDigestVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for HeaderDigestVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for HeaderDigestVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for HeaderDigestVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for HeaderDigestVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        HeaderDigestVec::new_unchecked(v)
    }
}
impl HeaderDigestVec {
    const DEFAULT_VALUE: [u8; 4] = [0, 0, 0, 0];
    pub const ITEM_SIZE: usize = 120;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<HeaderDigest> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> HeaderDigest {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        HeaderDigest::new_unchecked(self.0.slice(start..end))
    }
    pub fn as_reader<'r>(&'r self) -> HeaderDigestVecReader<'r> {
        HeaderDigestVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for HeaderDigestVec {
    type Builder = HeaderDigestVecBuilder;
    const NAME: &'static str = "HeaderDigestVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        HeaderDigestVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderDigestVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        HeaderDigestVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct HeaderDigestVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for HeaderDigestVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for HeaderDigestVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for HeaderDigestVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> HeaderDigestVecReader<'r> {
    pub const ITEM_SIZE: usize = 120;
    pub fn total_size(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()
    }
    pub fn item_count(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<HeaderDigestReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> HeaderDigestReader<'r> {
        let start = molecule::NUMBER_SIZE + Self::ITEM_SIZE * idx;
        let end = start + Self::ITEM_SIZE;
        HeaderDigestReader::new_unchecked(&self.as_slice()[start..end])
    }
}
impl<'r> molecule::prelude::Reader<'r> for HeaderDigestVecReader<'r> {
    type Entity = HeaderDigestVec;
    const NAME: &'static str = "HeaderDigestVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        HeaderDigestVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], _compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_count = molecule::unpack_number(slice) as usize;
        if item_count == 0 {
            if slice_len != molecule::NUMBER_SIZE {
                return ve!(Self, TotalSizeNotMatch, molecule::NUMBER_SIZE, slice_len);
            }
            return Ok(());
        }
        let total_size = molecule::NUMBER_SIZE + Self::ITEM_SIZE * item_count;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct HeaderDigestVecBuilder(pub(crate) Vec<HeaderDigest>);
impl HeaderDigestVecBuilder {
    pub const ITEM_SIZE: usize = 120;
    pub fn set(mut self, v: Vec<HeaderDigest>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: HeaderDigest) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = HeaderDigest>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: HeaderDigest) -> Option<HeaderDigest> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for HeaderDigestVecBuilder {
    type Entity = HeaderDigestVec;
    const NAME: &'static str = "HeaderDigestVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.0.len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.len() as molecule::Number))?;
        for inner in &self.0[..] {
            writer.write_all(inner.as_slice())?;
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        HeaderDigestVec::new_unchecked(inner.into())
    }
}
pub struct HeaderDigestVecIterator(HeaderDigestVec, usize, usize);
impl ::core::iter::Iterator for HeaderDigestVecIterator {
    type Item = HeaderDigest;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for HeaderDigestVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for HeaderDigestVec {
    type Item = HeaderDigest;
    type IntoIter = HeaderDigestVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        HeaderDigestVecIterator(self, 0, len)
    }
}
impl<'r> HeaderDigestVecReader<'r> {
    pub fn iter<'t>(&'t self) -> HeaderDigestVecReaderIterator<'t, 'r> {
        HeaderDigestVecReaderIterator(&self, 0, self.len())
    }
}
pub struct HeaderDigestVecReaderIterator<'t, 'r>(&'t HeaderDigestVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for HeaderDigestVecReaderIterator<'t, 'r> {
    type Item = HeaderDigestReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for HeaderDigestVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct VerifiableHeader(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for VerifiableHeader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for VerifiableHeader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for VerifiableHeader {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "uncles_hash", self.uncles_hash())?;
        write!(f, ", {}: {}", "extension", self.extension())?;
        write!(f, ", {}: {}", "parent_chain_root", self.parent_chain_root())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for VerifiableHeader {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        VerifiableHeader::new_unchecked(v)
    }
}
impl VerifiableHeader {
    const DEFAULT_VALUE: [u8; 380] = [
        124, 1, 0, 0, 20, 0, 0, 0, 228, 0, 0, 0, 4, 1, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> Header {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Header::new_unchecked(self.0.slice(start..end))
    }
    pub fn uncles_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn extension(&self) -> BytesOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        BytesOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn parent_chain_root(&self) -> HeaderDigest {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            HeaderDigest::new_unchecked(self.0.slice(start..end))
        } else {
            HeaderDigest::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> VerifiableHeaderReader<'r> {
        VerifiableHeaderReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for VerifiableHeader {
    type Builder = VerifiableHeaderBuilder;
    const NAME: &'static str = "VerifiableHeader";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        VerifiableHeader(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        VerifiableHeaderReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        VerifiableHeaderReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .header(self.header())
            .uncles_hash(self.uncles_hash())
            .extension(self.extension())
            .parent_chain_root(self.parent_chain_root())
    }
}
#[derive(Clone, Copy)]
pub struct VerifiableHeaderReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for VerifiableHeaderReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for VerifiableHeaderReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for VerifiableHeaderReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "header", self.header())?;
        write!(f, ", {}: {}", "uncles_hash", self.uncles_hash())?;
        write!(f, ", {}: {}", "extension", self.extension())?;
        write!(f, ", {}: {}", "parent_chain_root", self.parent_chain_root())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> VerifiableHeaderReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn header(&self) -> HeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        HeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn uncles_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn extension(&self) -> BytesOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        BytesOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn parent_chain_root(&self) -> HeaderDigestReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            HeaderDigestReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            HeaderDigestReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for VerifiableHeaderReader<'r> {
    type Entity = VerifiableHeader;
    const NAME: &'static str = "VerifiableHeaderReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        VerifiableHeaderReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        HeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesOptReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        HeaderDigestReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct VerifiableHeaderBuilder {
    pub(crate) header: Header,
    pub(crate) uncles_hash: Byte32,
    pub(crate) extension: BytesOpt,
    pub(crate) parent_chain_root: HeaderDigest,
}
impl VerifiableHeaderBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn header(mut self, v: Header) -> Self {
        self.header = v;
        self
    }
    pub fn uncles_hash(mut self, v: Byte32) -> Self {
        self.uncles_hash = v;
        self
    }
    pub fn extension(mut self, v: BytesOpt) -> Self {
        self.extension = v;
        self
    }
    pub fn parent_chain_root(mut self, v: HeaderDigest) -> Self {
        self.parent_chain_root = v;
        self
    }
}
impl molecule::prelude::Builder for VerifiableHeaderBuilder {
    type Entity = VerifiableHeader;
    const NAME: &'static str = "VerifiableHeaderBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.header.as_slice().len()
            + self.uncles_hash.as_slice().len()
            + self.extension.as_slice().len()
            + self.parent_chain_root.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.header.as_slice().len();
        offsets.push(total_size);
        total_size += self.uncles_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.extension.as_slice().len();
        offsets.push(total_size);
        total_size += self.parent_chain_root.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.header.as_slice())?;
        writer.write_all(self.uncles_hash.as_slice())?;
        writer.write_all(self.extension.as_slice())?;
        writer.write_all(self.parent_chain_root.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        VerifiableHeader::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct VerifiableHeaderVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for VerifiableHeaderVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for VerifiableHeaderVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for VerifiableHeaderVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for VerifiableHeaderVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        VerifiableHeaderVec::new_unchecked(v)
    }
}
impl VerifiableHeaderVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<VerifiableHeader> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> VerifiableHeader {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            VerifiableHeader::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            VerifiableHeader::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> VerifiableHeaderVecReader<'r> {
        VerifiableHeaderVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for VerifiableHeaderVec {
    type Builder = VerifiableHeaderVecBuilder;
    const NAME: &'static str = "VerifiableHeaderVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        VerifiableHeaderVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        VerifiableHeaderVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        VerifiableHeaderVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct VerifiableHeaderVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for VerifiableHeaderVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for VerifiableHeaderVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for VerifiableHeaderVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> VerifiableHeaderVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<VerifiableHeaderReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> VerifiableHeaderReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            VerifiableHeaderReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            VerifiableHeaderReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for VerifiableHeaderVecReader<'r> {
    type Entity = VerifiableHeaderVec;
    const NAME: &'static str = "VerifiableHeaderVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        VerifiableHeaderVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            VerifiableHeaderReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct VerifiableHeaderVecBuilder(pub(crate) Vec<VerifiableHeader>);
impl VerifiableHeaderVecBuilder {
    pub fn set(mut self, v: Vec<VerifiableHeader>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: VerifiableHeader) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = VerifiableHeader>>(
        mut self,
        iter: T,
    ) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: VerifiableHeader) -> Option<VerifiableHeader> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for VerifiableHeaderVecBuilder {
    type Entity = VerifiableHeaderVec;
    const NAME: &'static str = "VerifiableHeaderVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        VerifiableHeaderVec::new_unchecked(inner.into())
    }
}
pub struct VerifiableHeaderVecIterator(VerifiableHeaderVec, usize, usize);
impl ::core::iter::Iterator for VerifiableHeaderVecIterator {
    type Item = VerifiableHeader;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for VerifiableHeaderVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for VerifiableHeaderVec {
    type Item = VerifiableHeader;
    type IntoIter = VerifiableHeaderVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        VerifiableHeaderVecIterator(self, 0, len)
    }
}
impl<'r> VerifiableHeaderVecReader<'r> {
    pub fn iter<'t>(&'t self) -> VerifiableHeaderVecReaderIterator<'t, 'r> {
        VerifiableHeaderVecReaderIterator(&self, 0, self.len())
    }
}
pub struct VerifiableHeaderVecReaderIterator<'t, 'r>(
    &'t VerifiableHeaderVecReader<'r>,
    usize,
    usize,
);
impl<'t: 'r, 'r> ::core::iter::Iterator for VerifiableHeaderVecReaderIterator<'t, 'r> {
    type Item = VerifiableHeaderReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for VerifiableHeaderVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct FilteredBlockVec(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for FilteredBlockVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for FilteredBlockVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for FilteredBlockVec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl ::core::default::Default for FilteredBlockVec {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        FilteredBlockVec::new_unchecked(v)
    }
}
impl FilteredBlockVec {
    const DEFAULT_VALUE: [u8; 4] = [4, 0, 0, 0];
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<FilteredBlock> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> FilteredBlock {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            FilteredBlock::new_unchecked(self.0.slice(start..))
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            FilteredBlock::new_unchecked(self.0.slice(start..end))
        }
    }
    pub fn as_reader<'r>(&'r self) -> FilteredBlockVecReader<'r> {
        FilteredBlockVecReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for FilteredBlockVec {
    type Builder = FilteredBlockVecBuilder;
    const NAME: &'static str = "FilteredBlockVec";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        FilteredBlockVec(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FilteredBlockVecReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        FilteredBlockVecReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().extend(self.into_iter())
    }
}
#[derive(Clone, Copy)]
pub struct FilteredBlockVecReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for FilteredBlockVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for FilteredBlockVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for FilteredBlockVecReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} [", Self::NAME)?;
        for i in 0..self.len() {
            if i == 0 {
                write!(f, "{}", self.get_unchecked(i))?;
            } else {
                write!(f, ", {}", self.get_unchecked(i))?;
            }
        }
        write!(f, "]")
    }
}
impl<'r> FilteredBlockVecReader<'r> {
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn item_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn len(&self) -> usize {
        self.item_count()
    }
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }
    pub fn get(&self, idx: usize) -> Option<FilteredBlockReader<'r>> {
        if idx >= self.len() {
            None
        } else {
            Some(self.get_unchecked(idx))
        }
    }
    pub fn get_unchecked(&self, idx: usize) -> FilteredBlockReader<'r> {
        let slice = self.as_slice();
        let start_idx = molecule::NUMBER_SIZE * (1 + idx);
        let start = molecule::unpack_number(&slice[start_idx..]) as usize;
        if idx == self.len() - 1 {
            FilteredBlockReader::new_unchecked(&self.as_slice()[start..])
        } else {
            let end_idx = start_idx + molecule::NUMBER_SIZE;
            let end = molecule::unpack_number(&slice[end_idx..]) as usize;
            FilteredBlockReader::new_unchecked(&self.as_slice()[start..end])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for FilteredBlockVecReader<'r> {
    type Entity = FilteredBlockVec;
    const NAME: &'static str = "FilteredBlockVecReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        FilteredBlockVecReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len == molecule::NUMBER_SIZE {
            return Ok(());
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(
                Self,
                TotalSizeNotMatch,
                molecule::NUMBER_SIZE * 2,
                slice_len
            );
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        for pair in offsets.windows(2) {
            let start = pair[0];
            let end = pair[1];
            FilteredBlockReader::verify(&slice[start..end], compatible)?;
        }
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct FilteredBlockVecBuilder(pub(crate) Vec<FilteredBlock>);
impl FilteredBlockVecBuilder {
    pub fn set(mut self, v: Vec<FilteredBlock>) -> Self {
        self.0 = v;
        self
    }
    pub fn push(mut self, v: FilteredBlock) -> Self {
        self.0.push(v);
        self
    }
    pub fn extend<T: ::core::iter::IntoIterator<Item = FilteredBlock>>(mut self, iter: T) -> Self {
        for elem in iter {
            self.0.push(elem);
        }
        self
    }
    pub fn replace(&mut self, index: usize, v: FilteredBlock) -> Option<FilteredBlock> {
        self.0
            .get_mut(index)
            .map(|item| ::core::mem::replace(item, v))
    }
}
impl molecule::prelude::Builder for FilteredBlockVecBuilder {
    type Entity = FilteredBlockVec;
    const NAME: &'static str = "FilteredBlockVecBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (self.0.len() + 1)
            + self
                .0
                .iter()
                .map(|inner| inner.as_slice().len())
                .sum::<usize>()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let item_count = self.0.len();
        if item_count == 0 {
            writer.write_all(&molecule::pack_number(
                molecule::NUMBER_SIZE as molecule::Number,
            ))?;
        } else {
            let (total_size, offsets) = self.0.iter().fold(
                (
                    molecule::NUMBER_SIZE * (item_count + 1),
                    Vec::with_capacity(item_count),
                ),
                |(start, mut offsets), inner| {
                    offsets.push(start);
                    (start + inner.as_slice().len(), offsets)
                },
            );
            writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
            for offset in offsets.into_iter() {
                writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
            }
            for inner in self.0.iter() {
                writer.write_all(inner.as_slice())?;
            }
        }
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        FilteredBlockVec::new_unchecked(inner.into())
    }
}
pub struct FilteredBlockVecIterator(FilteredBlockVec, usize, usize);
impl ::core::iter::Iterator for FilteredBlockVecIterator {
    type Item = FilteredBlock;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl ::core::iter::ExactSizeIterator for FilteredBlockVecIterator {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
impl ::core::iter::IntoIterator for FilteredBlockVec {
    type Item = FilteredBlock;
    type IntoIter = FilteredBlockVecIterator;
    fn into_iter(self) -> Self::IntoIter {
        let len = self.len();
        FilteredBlockVecIterator(self, 0, len)
    }
}
impl<'r> FilteredBlockVecReader<'r> {
    pub fn iter<'t>(&'t self) -> FilteredBlockVecReaderIterator<'t, 'r> {
        FilteredBlockVecReaderIterator(&self, 0, self.len())
    }
}
pub struct FilteredBlockVecReaderIterator<'t, 'r>(&'t FilteredBlockVecReader<'r>, usize, usize);
impl<'t: 'r, 'r> ::core::iter::Iterator for FilteredBlockVecReaderIterator<'t, 'r> {
    type Item = FilteredBlockReader<'t>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.1 >= self.2 {
            None
        } else {
            let ret = self.0.get_unchecked(self.1);
            self.1 += 1;
            Some(ret)
        }
    }
}
impl<'t: 'r, 'r> ::core::iter::ExactSizeIterator for FilteredBlockVecReaderIterator<'t, 'r> {
    fn len(&self) -> usize {
        self.2 - self.1
    }
}
#[derive(Clone)]
pub struct LightClientMessage(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for LightClientMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for LightClientMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for LightClientMessage {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl ::core::default::Default for LightClientMessage {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        LightClientMessage::new_unchecked(v)
    }
}
impl LightClientMessage {
    const DEFAULT_VALUE: [u8; 13] = [0, 0, 0, 0, 9, 0, 0, 0, 8, 0, 0, 0, 0];
    pub const ITEMS_COUNT: usize = 8;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> LightClientMessageUnion {
        let inner = self.0.slice(molecule::NUMBER_SIZE..);
        match self.item_id() {
            0 => GetLastState::new_unchecked(inner).into(),
            1 => SendLastState::new_unchecked(inner).into(),
            2 => GetLastStateProof::new_unchecked(inner).into(),
            3 => SendLastStateProof::new_unchecked(inner).into(),
            4 => GetBlocksProof::new_unchecked(inner).into(),
            5 => SendBlocksProof::new_unchecked(inner).into(),
            6 => GetTransactionsProof::new_unchecked(inner).into(),
            7 => SendTransactionsProof::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
    pub fn as_reader<'r>(&'r self) -> LightClientMessageReader<'r> {
        LightClientMessageReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for LightClientMessage {
    type Builder = LightClientMessageBuilder;
    const NAME: &'static str = "LightClientMessage";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        LightClientMessage(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LightClientMessageReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        LightClientMessageReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().set(self.to_enum())
    }
}
#[derive(Clone, Copy)]
pub struct LightClientMessageReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for LightClientMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for LightClientMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for LightClientMessageReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}(", Self::NAME)?;
        self.to_enum().display_inner(f)?;
        write!(f, ")")
    }
}
impl<'r> LightClientMessageReader<'r> {
    pub const ITEMS_COUNT: usize = 8;
    pub fn item_id(&self) -> molecule::Number {
        molecule::unpack_number(self.as_slice())
    }
    pub fn to_enum(&self) -> LightClientMessageUnionReader<'r> {
        let inner = &self.as_slice()[molecule::NUMBER_SIZE..];
        match self.item_id() {
            0 => GetLastStateReader::new_unchecked(inner).into(),
            1 => SendLastStateReader::new_unchecked(inner).into(),
            2 => GetLastStateProofReader::new_unchecked(inner).into(),
            3 => SendLastStateProofReader::new_unchecked(inner).into(),
            4 => GetBlocksProofReader::new_unchecked(inner).into(),
            5 => SendBlocksProofReader::new_unchecked(inner).into(),
            6 => GetTransactionsProofReader::new_unchecked(inner).into(),
            7 => SendTransactionsProofReader::new_unchecked(inner).into(),
            _ => panic!("{}: invalid data", Self::NAME),
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for LightClientMessageReader<'r> {
    type Entity = LightClientMessage;
    const NAME: &'static str = "LightClientMessageReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        LightClientMessageReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let item_id = molecule::unpack_number(slice);
        let inner_slice = &slice[molecule::NUMBER_SIZE..];
        match item_id {
            0 => GetLastStateReader::verify(inner_slice, compatible),
            1 => SendLastStateReader::verify(inner_slice, compatible),
            2 => GetLastStateProofReader::verify(inner_slice, compatible),
            3 => SendLastStateProofReader::verify(inner_slice, compatible),
            4 => GetBlocksProofReader::verify(inner_slice, compatible),
            5 => SendBlocksProofReader::verify(inner_slice, compatible),
            6 => GetTransactionsProofReader::verify(inner_slice, compatible),
            7 => SendTransactionsProofReader::verify(inner_slice, compatible),
            _ => ve!(Self, UnknownItem, Self::ITEMS_COUNT, item_id),
        }?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct LightClientMessageBuilder(pub(crate) LightClientMessageUnion);
impl LightClientMessageBuilder {
    pub const ITEMS_COUNT: usize = 8;
    pub fn set<I>(mut self, v: I) -> Self
    where
        I: ::core::convert::Into<LightClientMessageUnion>,
    {
        self.0 = v.into();
        self
    }
}
impl molecule::prelude::Builder for LightClientMessageBuilder {
    type Entity = LightClientMessage;
    const NAME: &'static str = "LightClientMessageBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE + self.0.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        writer.write_all(&molecule::pack_number(self.0.item_id()))?;
        writer.write_all(self.0.as_slice())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        LightClientMessage::new_unchecked(inner.into())
    }
}
#[derive(Debug, Clone)]
pub enum LightClientMessageUnion {
    GetLastState(GetLastState),
    SendLastState(SendLastState),
    GetLastStateProof(GetLastStateProof),
    SendLastStateProof(SendLastStateProof),
    GetBlocksProof(GetBlocksProof),
    SendBlocksProof(SendBlocksProof),
    GetTransactionsProof(GetTransactionsProof),
    SendTransactionsProof(SendTransactionsProof),
}
#[derive(Debug, Clone, Copy)]
pub enum LightClientMessageUnionReader<'r> {
    GetLastState(GetLastStateReader<'r>),
    SendLastState(SendLastStateReader<'r>),
    GetLastStateProof(GetLastStateProofReader<'r>),
    SendLastStateProof(SendLastStateProofReader<'r>),
    GetBlocksProof(GetBlocksProofReader<'r>),
    SendBlocksProof(SendBlocksProofReader<'r>),
    GetTransactionsProof(GetTransactionsProofReader<'r>),
    SendTransactionsProof(SendTransactionsProofReader<'r>),
}
impl ::core::default::Default for LightClientMessageUnion {
    fn default() -> Self {
        LightClientMessageUnion::GetLastState(::core::default::Default::default())
    }
}
impl ::core::fmt::Display for LightClientMessageUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            LightClientMessageUnion::GetLastState(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetLastState::NAME, item)
            }
            LightClientMessageUnion::SendLastState(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendLastState::NAME, item)
            }
            LightClientMessageUnion::GetLastStateProof(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetLastStateProof::NAME, item)
            }
            LightClientMessageUnion::SendLastStateProof(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendLastStateProof::NAME, item)
            }
            LightClientMessageUnion::GetBlocksProof(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlocksProof::NAME, item)
            }
            LightClientMessageUnion::SendBlocksProof(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendBlocksProof::NAME, item)
            }
            LightClientMessageUnion::GetTransactionsProof(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetTransactionsProof::NAME,
                    item
                )
            }
            LightClientMessageUnion::SendTransactionsProof(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    SendTransactionsProof::NAME,
                    item
                )
            }
        }
    }
}
impl<'r> ::core::fmt::Display for LightClientMessageUnionReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            LightClientMessageUnionReader::GetLastState(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetLastState::NAME, item)
            }
            LightClientMessageUnionReader::SendLastState(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendLastState::NAME, item)
            }
            LightClientMessageUnionReader::GetLastStateProof(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetLastStateProof::NAME, item)
            }
            LightClientMessageUnionReader::SendLastStateProof(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendLastStateProof::NAME, item)
            }
            LightClientMessageUnionReader::GetBlocksProof(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, GetBlocksProof::NAME, item)
            }
            LightClientMessageUnionReader::SendBlocksProof(ref item) => {
                write!(f, "{}::{}({})", Self::NAME, SendBlocksProof::NAME, item)
            }
            LightClientMessageUnionReader::GetTransactionsProof(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    GetTransactionsProof::NAME,
                    item
                )
            }
            LightClientMessageUnionReader::SendTransactionsProof(ref item) => {
                write!(
                    f,
                    "{}::{}({})",
                    Self::NAME,
                    SendTransactionsProof::NAME,
                    item
                )
            }
        }
    }
}
impl LightClientMessageUnion {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            LightClientMessageUnion::GetLastState(ref item) => write!(f, "{}", item),
            LightClientMessageUnion::SendLastState(ref item) => write!(f, "{}", item),
            LightClientMessageUnion::GetLastStateProof(ref item) => write!(f, "{}", item),
            LightClientMessageUnion::SendLastStateProof(ref item) => write!(f, "{}", item),
            LightClientMessageUnion::GetBlocksProof(ref item) => write!(f, "{}", item),
            LightClientMessageUnion::SendBlocksProof(ref item) => write!(f, "{}", item),
            LightClientMessageUnion::GetTransactionsProof(ref item) => write!(f, "{}", item),
            LightClientMessageUnion::SendTransactionsProof(ref item) => write!(f, "{}", item),
        }
    }
}
impl<'r> LightClientMessageUnionReader<'r> {
    pub(crate) fn display_inner(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            LightClientMessageUnionReader::GetLastState(ref item) => write!(f, "{}", item),
            LightClientMessageUnionReader::SendLastState(ref item) => write!(f, "{}", item),
            LightClientMessageUnionReader::GetLastStateProof(ref item) => write!(f, "{}", item),
            LightClientMessageUnionReader::SendLastStateProof(ref item) => write!(f, "{}", item),
            LightClientMessageUnionReader::GetBlocksProof(ref item) => write!(f, "{}", item),
            LightClientMessageUnionReader::SendBlocksProof(ref item) => write!(f, "{}", item),
            LightClientMessageUnionReader::GetTransactionsProof(ref item) => write!(f, "{}", item),
            LightClientMessageUnionReader::SendTransactionsProof(ref item) => write!(f, "{}", item),
        }
    }
}
impl ::core::convert::From<GetLastState> for LightClientMessageUnion {
    fn from(item: GetLastState) -> Self {
        LightClientMessageUnion::GetLastState(item)
    }
}
impl ::core::convert::From<SendLastState> for LightClientMessageUnion {
    fn from(item: SendLastState) -> Self {
        LightClientMessageUnion::SendLastState(item)
    }
}
impl ::core::convert::From<GetLastStateProof> for LightClientMessageUnion {
    fn from(item: GetLastStateProof) -> Self {
        LightClientMessageUnion::GetLastStateProof(item)
    }
}
impl ::core::convert::From<SendLastStateProof> for LightClientMessageUnion {
    fn from(item: SendLastStateProof) -> Self {
        LightClientMessageUnion::SendLastStateProof(item)
    }
}
impl ::core::convert::From<GetBlocksProof> for LightClientMessageUnion {
    fn from(item: GetBlocksProof) -> Self {
        LightClientMessageUnion::GetBlocksProof(item)
    }
}
impl ::core::convert::From<SendBlocksProof> for LightClientMessageUnion {
    fn from(item: SendBlocksProof) -> Self {
        LightClientMessageUnion::SendBlocksProof(item)
    }
}
impl ::core::convert::From<GetTransactionsProof> for LightClientMessageUnion {
    fn from(item: GetTransactionsProof) -> Self {
        LightClientMessageUnion::GetTransactionsProof(item)
    }
}
impl ::core::convert::From<SendTransactionsProof> for LightClientMessageUnion {
    fn from(item: SendTransactionsProof) -> Self {
        LightClientMessageUnion::SendTransactionsProof(item)
    }
}
impl<'r> ::core::convert::From<GetLastStateReader<'r>> for LightClientMessageUnionReader<'r> {
    fn from(item: GetLastStateReader<'r>) -> Self {
        LightClientMessageUnionReader::GetLastState(item)
    }
}
impl<'r> ::core::convert::From<SendLastStateReader<'r>> for LightClientMessageUnionReader<'r> {
    fn from(item: SendLastStateReader<'r>) -> Self {
        LightClientMessageUnionReader::SendLastState(item)
    }
}
impl<'r> ::core::convert::From<GetLastStateProofReader<'r>> for LightClientMessageUnionReader<'r> {
    fn from(item: GetLastStateProofReader<'r>) -> Self {
        LightClientMessageUnionReader::GetLastStateProof(item)
    }
}
impl<'r> ::core::convert::From<SendLastStateProofReader<'r>> for LightClientMessageUnionReader<'r> {
    fn from(item: SendLastStateProofReader<'r>) -> Self {
        LightClientMessageUnionReader::SendLastStateProof(item)
    }
}
impl<'r> ::core::convert::From<GetBlocksProofReader<'r>> for LightClientMessageUnionReader<'r> {
    fn from(item: GetBlocksProofReader<'r>) -> Self {
        LightClientMessageUnionReader::GetBlocksProof(item)
    }
}
impl<'r> ::core::convert::From<SendBlocksProofReader<'r>> for LightClientMessageUnionReader<'r> {
    fn from(item: SendBlocksProofReader<'r>) -> Self {
        LightClientMessageUnionReader::SendBlocksProof(item)
    }
}
impl<'r> ::core::convert::From<GetTransactionsProofReader<'r>>
    for LightClientMessageUnionReader<'r>
{
    fn from(item: GetTransactionsProofReader<'r>) -> Self {
        LightClientMessageUnionReader::GetTransactionsProof(item)
    }
}
impl<'r> ::core::convert::From<SendTransactionsProofReader<'r>>
    for LightClientMessageUnionReader<'r>
{
    fn from(item: SendTransactionsProofReader<'r>) -> Self {
        LightClientMessageUnionReader::SendTransactionsProof(item)
    }
}
impl LightClientMessageUnion {
    pub const NAME: &'static str = "LightClientMessageUnion";
    pub fn as_bytes(&self) -> molecule::bytes::Bytes {
        match self {
            LightClientMessageUnion::GetLastState(item) => item.as_bytes(),
            LightClientMessageUnion::SendLastState(item) => item.as_bytes(),
            LightClientMessageUnion::GetLastStateProof(item) => item.as_bytes(),
            LightClientMessageUnion::SendLastStateProof(item) => item.as_bytes(),
            LightClientMessageUnion::GetBlocksProof(item) => item.as_bytes(),
            LightClientMessageUnion::SendBlocksProof(item) => item.as_bytes(),
            LightClientMessageUnion::GetTransactionsProof(item) => item.as_bytes(),
            LightClientMessageUnion::SendTransactionsProof(item) => item.as_bytes(),
        }
    }
    pub fn as_slice(&self) -> &[u8] {
        match self {
            LightClientMessageUnion::GetLastState(item) => item.as_slice(),
            LightClientMessageUnion::SendLastState(item) => item.as_slice(),
            LightClientMessageUnion::GetLastStateProof(item) => item.as_slice(),
            LightClientMessageUnion::SendLastStateProof(item) => item.as_slice(),
            LightClientMessageUnion::GetBlocksProof(item) => item.as_slice(),
            LightClientMessageUnion::SendBlocksProof(item) => item.as_slice(),
            LightClientMessageUnion::GetTransactionsProof(item) => item.as_slice(),
            LightClientMessageUnion::SendTransactionsProof(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            LightClientMessageUnion::GetLastState(_) => 0,
            LightClientMessageUnion::SendLastState(_) => 1,
            LightClientMessageUnion::GetLastStateProof(_) => 2,
            LightClientMessageUnion::SendLastStateProof(_) => 3,
            LightClientMessageUnion::GetBlocksProof(_) => 4,
            LightClientMessageUnion::SendBlocksProof(_) => 5,
            LightClientMessageUnion::GetTransactionsProof(_) => 6,
            LightClientMessageUnion::SendTransactionsProof(_) => 7,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            LightClientMessageUnion::GetLastState(_) => "GetLastState",
            LightClientMessageUnion::SendLastState(_) => "SendLastState",
            LightClientMessageUnion::GetLastStateProof(_) => "GetLastStateProof",
            LightClientMessageUnion::SendLastStateProof(_) => "SendLastStateProof",
            LightClientMessageUnion::GetBlocksProof(_) => "GetBlocksProof",
            LightClientMessageUnion::SendBlocksProof(_) => "SendBlocksProof",
            LightClientMessageUnion::GetTransactionsProof(_) => "GetTransactionsProof",
            LightClientMessageUnion::SendTransactionsProof(_) => "SendTransactionsProof",
        }
    }
    pub fn as_reader<'r>(&'r self) -> LightClientMessageUnionReader<'r> {
        match self {
            LightClientMessageUnion::GetLastState(item) => item.as_reader().into(),
            LightClientMessageUnion::SendLastState(item) => item.as_reader().into(),
            LightClientMessageUnion::GetLastStateProof(item) => item.as_reader().into(),
            LightClientMessageUnion::SendLastStateProof(item) => item.as_reader().into(),
            LightClientMessageUnion::GetBlocksProof(item) => item.as_reader().into(),
            LightClientMessageUnion::SendBlocksProof(item) => item.as_reader().into(),
            LightClientMessageUnion::GetTransactionsProof(item) => item.as_reader().into(),
            LightClientMessageUnion::SendTransactionsProof(item) => item.as_reader().into(),
        }
    }
}
impl<'r> LightClientMessageUnionReader<'r> {
    pub const NAME: &'r str = "LightClientMessageUnionReader";
    pub fn as_slice(&self) -> &'r [u8] {
        match self {
            LightClientMessageUnionReader::GetLastState(item) => item.as_slice(),
            LightClientMessageUnionReader::SendLastState(item) => item.as_slice(),
            LightClientMessageUnionReader::GetLastStateProof(item) => item.as_slice(),
            LightClientMessageUnionReader::SendLastStateProof(item) => item.as_slice(),
            LightClientMessageUnionReader::GetBlocksProof(item) => item.as_slice(),
            LightClientMessageUnionReader::SendBlocksProof(item) => item.as_slice(),
            LightClientMessageUnionReader::GetTransactionsProof(item) => item.as_slice(),
            LightClientMessageUnionReader::SendTransactionsProof(item) => item.as_slice(),
        }
    }
    pub fn item_id(&self) -> molecule::Number {
        match self {
            LightClientMessageUnionReader::GetLastState(_) => 0,
            LightClientMessageUnionReader::SendLastState(_) => 1,
            LightClientMessageUnionReader::GetLastStateProof(_) => 2,
            LightClientMessageUnionReader::SendLastStateProof(_) => 3,
            LightClientMessageUnionReader::GetBlocksProof(_) => 4,
            LightClientMessageUnionReader::SendBlocksProof(_) => 5,
            LightClientMessageUnionReader::GetTransactionsProof(_) => 6,
            LightClientMessageUnionReader::SendTransactionsProof(_) => 7,
        }
    }
    pub fn item_name(&self) -> &str {
        match self {
            LightClientMessageUnionReader::GetLastState(_) => "GetLastState",
            LightClientMessageUnionReader::SendLastState(_) => "SendLastState",
            LightClientMessageUnionReader::GetLastStateProof(_) => "GetLastStateProof",
            LightClientMessageUnionReader::SendLastStateProof(_) => "SendLastStateProof",
            LightClientMessageUnionReader::GetBlocksProof(_) => "GetBlocksProof",
            LightClientMessageUnionReader::SendBlocksProof(_) => "SendBlocksProof",
            LightClientMessageUnionReader::GetTransactionsProof(_) => "GetTransactionsProof",
            LightClientMessageUnionReader::SendTransactionsProof(_) => "SendTransactionsProof",
        }
    }
}
#[derive(Clone)]
pub struct GetLastState(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetLastState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetLastState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetLastState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "subscribe", self.subscribe())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetLastState {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        GetLastState::new_unchecked(v)
    }
}
impl GetLastState {
    const DEFAULT_VALUE: [u8; 9] = [9, 0, 0, 0, 8, 0, 0, 0, 0];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn subscribe(&self) -> Bool {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Bool::new_unchecked(self.0.slice(start..end))
        } else {
            Bool::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetLastStateReader<'r> {
        GetLastStateReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetLastState {
    type Builder = GetLastStateBuilder;
    const NAME: &'static str = "GetLastState";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetLastState(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetLastStateReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetLastStateReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().subscribe(self.subscribe())
    }
}
#[derive(Clone, Copy)]
pub struct GetLastStateReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetLastStateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetLastStateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetLastStateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "subscribe", self.subscribe())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetLastStateReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn subscribe(&self) -> BoolReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            BoolReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BoolReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetLastStateReader<'r> {
    type Entity = GetLastState;
    const NAME: &'static str = "GetLastStateReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetLastStateReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        BoolReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetLastStateBuilder {
    pub(crate) subscribe: Bool,
}
impl GetLastStateBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn subscribe(mut self, v: Bool) -> Self {
        self.subscribe = v;
        self
    }
}
impl molecule::prelude::Builder for GetLastStateBuilder {
    type Entity = GetLastState;
    const NAME: &'static str = "GetLastStateBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.subscribe.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.subscribe.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.subscribe.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetLastState::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SendLastState(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SendLastState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SendLastState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SendLastState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_header", self.last_header())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SendLastState {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SendLastState::new_unchecked(v)
    }
}
impl SendLastState {
    const DEFAULT_VALUE: [u8; 388] = [
        132, 1, 0, 0, 8, 0, 0, 0, 124, 1, 0, 0, 20, 0, 0, 0, 228, 0, 0, 0, 4, 1, 0, 0, 4, 1, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_header(&self) -> VerifiableHeader {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            VerifiableHeader::new_unchecked(self.0.slice(start..end))
        } else {
            VerifiableHeader::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SendLastStateReader<'r> {
        SendLastStateReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SendLastState {
    type Builder = SendLastStateBuilder;
    const NAME: &'static str = "SendLastState";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SendLastState(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendLastStateReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendLastStateReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().last_header(self.last_header())
    }
}
#[derive(Clone, Copy)]
pub struct SendLastStateReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SendLastStateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SendLastStateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SendLastStateReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_header", self.last_header())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SendLastStateReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_header(&self) -> VerifiableHeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            VerifiableHeaderReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            VerifiableHeaderReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SendLastStateReader<'r> {
    type Entity = SendLastState;
    const NAME: &'static str = "SendLastStateReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SendLastStateReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        VerifiableHeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SendLastStateBuilder {
    pub(crate) last_header: VerifiableHeader,
}
impl SendLastStateBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn last_header(mut self, v: VerifiableHeader) -> Self {
        self.last_header = v;
        self
    }
}
impl molecule::prelude::Builder for SendLastStateBuilder {
    type Entity = SendLastState;
    const NAME: &'static str = "SendLastStateBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.last_header.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.last_header.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.last_header.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SendLastState::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetLastStateProof(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetLastStateProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetLastStateProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetLastStateProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_hash", self.last_hash())?;
        write!(f, ", {}: {}", "start_hash", self.start_hash())?;
        write!(f, ", {}: {}", "start_number", self.start_number())?;
        write!(f, ", {}: {}", "last_n_blocks", self.last_n_blocks())?;
        write!(
            f,
            ", {}: {}",
            "difficulty_boundary",
            self.difficulty_boundary()
        )?;
        write!(f, ", {}: {}", "difficulties", self.difficulties())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetLastStateProof {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        GetLastStateProof::new_unchecked(v)
    }
}
impl GetLastStateProof {
    const DEFAULT_VALUE: [u8; 144] = [
        144, 0, 0, 0, 28, 0, 0, 0, 60, 0, 0, 0, 92, 0, 0, 0, 100, 0, 0, 0, 108, 0, 0, 0, 140, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn start_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn start_number(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn last_n_blocks(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn difficulty_boundary(&self) -> Uint256 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint256::new_unchecked(self.0.slice(start..end))
    }
    pub fn difficulties(&self) -> Uint256Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Uint256Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Uint256Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetLastStateProofReader<'r> {
        GetLastStateProofReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetLastStateProof {
    type Builder = GetLastStateProofBuilder;
    const NAME: &'static str = "GetLastStateProof";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetLastStateProof(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetLastStateProofReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetLastStateProofReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .last_hash(self.last_hash())
            .start_hash(self.start_hash())
            .start_number(self.start_number())
            .last_n_blocks(self.last_n_blocks())
            .difficulty_boundary(self.difficulty_boundary())
            .difficulties(self.difficulties())
    }
}
#[derive(Clone, Copy)]
pub struct GetLastStateProofReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetLastStateProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetLastStateProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetLastStateProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_hash", self.last_hash())?;
        write!(f, ", {}: {}", "start_hash", self.start_hash())?;
        write!(f, ", {}: {}", "start_number", self.start_number())?;
        write!(f, ", {}: {}", "last_n_blocks", self.last_n_blocks())?;
        write!(
            f,
            ", {}: {}",
            "difficulty_boundary",
            self.difficulty_boundary()
        )?;
        write!(f, ", {}: {}", "difficulties", self.difficulties())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetLastStateProofReader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn start_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn start_number(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn last_n_blocks(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn difficulty_boundary(&self) -> Uint256Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Uint256Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn difficulties(&self) -> Uint256VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            Uint256VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint256VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetLastStateProofReader<'r> {
    type Entity = GetLastStateProof;
    const NAME: &'static str = "GetLastStateProofReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetLastStateProofReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint64Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint64Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Uint256Reader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        Uint256VecReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetLastStateProofBuilder {
    pub(crate) last_hash: Byte32,
    pub(crate) start_hash: Byte32,
    pub(crate) start_number: Uint64,
    pub(crate) last_n_blocks: Uint64,
    pub(crate) difficulty_boundary: Uint256,
    pub(crate) difficulties: Uint256Vec,
}
impl GetLastStateProofBuilder {
    pub const FIELD_COUNT: usize = 6;
    pub fn last_hash(mut self, v: Byte32) -> Self {
        self.last_hash = v;
        self
    }
    pub fn start_hash(mut self, v: Byte32) -> Self {
        self.start_hash = v;
        self
    }
    pub fn start_number(mut self, v: Uint64) -> Self {
        self.start_number = v;
        self
    }
    pub fn last_n_blocks(mut self, v: Uint64) -> Self {
        self.last_n_blocks = v;
        self
    }
    pub fn difficulty_boundary(mut self, v: Uint256) -> Self {
        self.difficulty_boundary = v;
        self
    }
    pub fn difficulties(mut self, v: Uint256Vec) -> Self {
        self.difficulties = v;
        self
    }
}
impl molecule::prelude::Builder for GetLastStateProofBuilder {
    type Entity = GetLastStateProof;
    const NAME: &'static str = "GetLastStateProofBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.last_hash.as_slice().len()
            + self.start_hash.as_slice().len()
            + self.start_number.as_slice().len()
            + self.last_n_blocks.as_slice().len()
            + self.difficulty_boundary.as_slice().len()
            + self.difficulties.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.last_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.start_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.start_number.as_slice().len();
        offsets.push(total_size);
        total_size += self.last_n_blocks.as_slice().len();
        offsets.push(total_size);
        total_size += self.difficulty_boundary.as_slice().len();
        offsets.push(total_size);
        total_size += self.difficulties.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.last_hash.as_slice())?;
        writer.write_all(self.start_hash.as_slice())?;
        writer.write_all(self.start_number.as_slice())?;
        writer.write_all(self.last_n_blocks.as_slice())?;
        writer.write_all(self.difficulty_boundary.as_slice())?;
        writer.write_all(self.difficulties.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetLastStateProof::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SendLastStateProof(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SendLastStateProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SendLastStateProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SendLastStateProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_header", self.last_header())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        write!(f, ", {}: {}", "headers", self.headers())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SendLastStateProof {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SendLastStateProof::new_unchecked(v)
    }
}
impl SendLastStateProof {
    const DEFAULT_VALUE: [u8; 404] = [
        148, 1, 0, 0, 16, 0, 0, 0, 140, 1, 0, 0, 144, 1, 0, 0, 124, 1, 0, 0, 20, 0, 0, 0, 228, 0,
        0, 0, 4, 1, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_header(&self) -> VerifiableHeader {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        VerifiableHeader::new_unchecked(self.0.slice(start..end))
    }
    pub fn proof(&self) -> HeaderDigestVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HeaderDigestVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn headers(&self) -> VerifiableHeaderVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            VerifiableHeaderVec::new_unchecked(self.0.slice(start..end))
        } else {
            VerifiableHeaderVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SendLastStateProofReader<'r> {
        SendLastStateProofReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SendLastStateProof {
    type Builder = SendLastStateProofBuilder;
    const NAME: &'static str = "SendLastStateProof";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SendLastStateProof(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendLastStateProofReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendLastStateProofReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .last_header(self.last_header())
            .proof(self.proof())
            .headers(self.headers())
    }
}
#[derive(Clone, Copy)]
pub struct SendLastStateProofReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SendLastStateProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SendLastStateProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SendLastStateProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_header", self.last_header())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        write!(f, ", {}: {}", "headers", self.headers())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SendLastStateProofReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_header(&self) -> VerifiableHeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        VerifiableHeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proof(&self) -> HeaderDigestVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HeaderDigestVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn headers(&self) -> VerifiableHeaderVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            VerifiableHeaderVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            VerifiableHeaderVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SendLastStateProofReader<'r> {
    type Entity = SendLastStateProof;
    const NAME: &'static str = "SendLastStateProofReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SendLastStateProofReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        VerifiableHeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        HeaderDigestVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        VerifiableHeaderVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SendLastStateProofBuilder {
    pub(crate) last_header: VerifiableHeader,
    pub(crate) proof: HeaderDigestVec,
    pub(crate) headers: VerifiableHeaderVec,
}
impl SendLastStateProofBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn last_header(mut self, v: VerifiableHeader) -> Self {
        self.last_header = v;
        self
    }
    pub fn proof(mut self, v: HeaderDigestVec) -> Self {
        self.proof = v;
        self
    }
    pub fn headers(mut self, v: VerifiableHeaderVec) -> Self {
        self.headers = v;
        self
    }
}
impl molecule::prelude::Builder for SendLastStateProofBuilder {
    type Entity = SendLastStateProof;
    const NAME: &'static str = "SendLastStateProofBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.last_header.as_slice().len()
            + self.proof.as_slice().len()
            + self.headers.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.last_header.as_slice().len();
        offsets.push(total_size);
        total_size += self.proof.as_slice().len();
        offsets.push(total_size);
        total_size += self.headers.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.last_header.as_slice())?;
        writer.write_all(self.proof.as_slice())?;
        writer.write_all(self.headers.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SendLastStateProof::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetBlocksProof(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetBlocksProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetBlocksProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetBlocksProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_hash", self.last_hash())?;
        write!(f, ", {}: {}", "block_hashes", self.block_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetBlocksProof {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        GetBlocksProof::new_unchecked(v)
    }
}
impl GetBlocksProof {
    const DEFAULT_VALUE: [u8; 48] = [
        48, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn block_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetBlocksProofReader<'r> {
        GetBlocksProofReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetBlocksProof {
    type Builder = GetBlocksProofBuilder;
    const NAME: &'static str = "GetBlocksProof";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetBlocksProof(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlocksProofReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetBlocksProofReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .last_hash(self.last_hash())
            .block_hashes(self.block_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct GetBlocksProofReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetBlocksProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetBlocksProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetBlocksProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_hash", self.last_hash())?;
        write!(f, ", {}: {}", "block_hashes", self.block_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetBlocksProofReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn block_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetBlocksProofReader<'r> {
    type Entity = GetBlocksProof;
    const NAME: &'static str = "GetBlocksProofReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetBlocksProofReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetBlocksProofBuilder {
    pub(crate) last_hash: Byte32,
    pub(crate) block_hashes: Byte32Vec,
}
impl GetBlocksProofBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn last_hash(mut self, v: Byte32) -> Self {
        self.last_hash = v;
        self
    }
    pub fn block_hashes(mut self, v: Byte32Vec) -> Self {
        self.block_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for GetBlocksProofBuilder {
    type Entity = GetBlocksProof;
    const NAME: &'static str = "GetBlocksProofBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.last_hash.as_slice().len()
            + self.block_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.last_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.block_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.last_hash.as_slice())?;
        writer.write_all(self.block_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetBlocksProof::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SendBlocksProof(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SendBlocksProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SendBlocksProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SendBlocksProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_header", self.last_header())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        write!(f, ", {}: {}", "headers", self.headers())?;
        write!(
            f,
            ", {}: {}",
            "missing_block_hashes",
            self.missing_block_hashes()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SendBlocksProof {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SendBlocksProof::new_unchecked(v)
    }
}
impl SendBlocksProof {
    const DEFAULT_VALUE: [u8; 412] = [
        156, 1, 0, 0, 20, 0, 0, 0, 144, 1, 0, 0, 148, 1, 0, 0, 152, 1, 0, 0, 124, 1, 0, 0, 20, 0,
        0, 0, 228, 0, 0, 0, 4, 1, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_header(&self) -> VerifiableHeader {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        VerifiableHeader::new_unchecked(self.0.slice(start..end))
    }
    pub fn proof(&self) -> HeaderDigestVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HeaderDigestVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn headers(&self) -> HeaderVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        HeaderVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn missing_block_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SendBlocksProofReader<'r> {
        SendBlocksProofReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SendBlocksProof {
    type Builder = SendBlocksProofBuilder;
    const NAME: &'static str = "SendBlocksProof";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SendBlocksProof(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendBlocksProofReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendBlocksProofReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .last_header(self.last_header())
            .proof(self.proof())
            .headers(self.headers())
            .missing_block_hashes(self.missing_block_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct SendBlocksProofReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SendBlocksProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SendBlocksProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SendBlocksProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_header", self.last_header())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        write!(f, ", {}: {}", "headers", self.headers())?;
        write!(
            f,
            ", {}: {}",
            "missing_block_hashes",
            self.missing_block_hashes()
        )?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SendBlocksProofReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_header(&self) -> VerifiableHeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        VerifiableHeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proof(&self) -> HeaderDigestVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HeaderDigestVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn headers(&self) -> HeaderVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        HeaderVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn missing_block_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SendBlocksProofReader<'r> {
    type Entity = SendBlocksProof;
    const NAME: &'static str = "SendBlocksProofReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SendBlocksProofReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        VerifiableHeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        HeaderDigestVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        HeaderVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SendBlocksProofBuilder {
    pub(crate) last_header: VerifiableHeader,
    pub(crate) proof: HeaderDigestVec,
    pub(crate) headers: HeaderVec,
    pub(crate) missing_block_hashes: Byte32Vec,
}
impl SendBlocksProofBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn last_header(mut self, v: VerifiableHeader) -> Self {
        self.last_header = v;
        self
    }
    pub fn proof(mut self, v: HeaderDigestVec) -> Self {
        self.proof = v;
        self
    }
    pub fn headers(mut self, v: HeaderVec) -> Self {
        self.headers = v;
        self
    }
    pub fn missing_block_hashes(mut self, v: Byte32Vec) -> Self {
        self.missing_block_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for SendBlocksProofBuilder {
    type Entity = SendBlocksProof;
    const NAME: &'static str = "SendBlocksProofBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.last_header.as_slice().len()
            + self.proof.as_slice().len()
            + self.headers.as_slice().len()
            + self.missing_block_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.last_header.as_slice().len();
        offsets.push(total_size);
        total_size += self.proof.as_slice().len();
        offsets.push(total_size);
        total_size += self.headers.as_slice().len();
        offsets.push(total_size);
        total_size += self.missing_block_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.last_header.as_slice())?;
        writer.write_all(self.proof.as_slice())?;
        writer.write_all(self.headers.as_slice())?;
        writer.write_all(self.missing_block_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SendBlocksProof::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SendBlocksProofV1(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SendBlocksProofV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SendBlocksProofV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SendBlocksProofV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_header", self.last_header())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        write!(f, ", {}: {}", "headers", self.headers())?;
        write!(
            f,
            ", {}: {}",
            "missing_block_hashes",
            self.missing_block_hashes()
        )?;
        write!(
            f,
            ", {}: {}",
            "blocks_uncles_hash",
            self.blocks_uncles_hash()
        )?;
        write!(f, ", {}: {}", "blocks_extension", self.blocks_extension())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SendBlocksProofV1 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SendBlocksProofV1::new_unchecked(v)
    }
}
impl SendBlocksProofV1 {
    const DEFAULT_VALUE: [u8; 428] = [
        172, 1, 0, 0, 28, 0, 0, 0, 152, 1, 0, 0, 156, 1, 0, 0, 160, 1, 0, 0, 164, 1, 0, 0, 168, 1,
        0, 0, 124, 1, 0, 0, 20, 0, 0, 0, 228, 0, 0, 0, 4, 1, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_header(&self) -> VerifiableHeader {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        VerifiableHeader::new_unchecked(self.0.slice(start..end))
    }
    pub fn proof(&self) -> HeaderDigestVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HeaderDigestVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn headers(&self) -> HeaderVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        HeaderVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn missing_block_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn blocks_uncles_hash(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn blocks_extension(&self) -> BytesOptVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            BytesOptVec::new_unchecked(self.0.slice(start..end))
        } else {
            BytesOptVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SendBlocksProofV1Reader<'r> {
        SendBlocksProofV1Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SendBlocksProofV1 {
    type Builder = SendBlocksProofV1Builder;
    const NAME: &'static str = "SendBlocksProofV1";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SendBlocksProofV1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendBlocksProofV1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendBlocksProofV1Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .last_header(self.last_header())
            .proof(self.proof())
            .headers(self.headers())
            .missing_block_hashes(self.missing_block_hashes())
            .blocks_uncles_hash(self.blocks_uncles_hash())
            .blocks_extension(self.blocks_extension())
    }
}
#[derive(Clone, Copy)]
pub struct SendBlocksProofV1Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SendBlocksProofV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SendBlocksProofV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SendBlocksProofV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_header", self.last_header())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        write!(f, ", {}: {}", "headers", self.headers())?;
        write!(
            f,
            ", {}: {}",
            "missing_block_hashes",
            self.missing_block_hashes()
        )?;
        write!(
            f,
            ", {}: {}",
            "blocks_uncles_hash",
            self.blocks_uncles_hash()
        )?;
        write!(f, ", {}: {}", "blocks_extension", self.blocks_extension())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SendBlocksProofV1Reader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_header(&self) -> VerifiableHeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        VerifiableHeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proof(&self) -> HeaderDigestVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HeaderDigestVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn headers(&self) -> HeaderVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        HeaderVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn missing_block_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn blocks_uncles_hash(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn blocks_extension(&self) -> BytesOptVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            BytesOptVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesOptVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SendBlocksProofV1Reader<'r> {
    type Entity = SendBlocksProofV1;
    const NAME: &'static str = "SendBlocksProofV1Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SendBlocksProofV1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        VerifiableHeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        HeaderDigestVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        HeaderVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        BytesOptVecReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SendBlocksProofV1Builder {
    pub(crate) last_header: VerifiableHeader,
    pub(crate) proof: HeaderDigestVec,
    pub(crate) headers: HeaderVec,
    pub(crate) missing_block_hashes: Byte32Vec,
    pub(crate) blocks_uncles_hash: Byte32Vec,
    pub(crate) blocks_extension: BytesOptVec,
}
impl SendBlocksProofV1Builder {
    pub const FIELD_COUNT: usize = 6;
    pub fn last_header(mut self, v: VerifiableHeader) -> Self {
        self.last_header = v;
        self
    }
    pub fn proof(mut self, v: HeaderDigestVec) -> Self {
        self.proof = v;
        self
    }
    pub fn headers(mut self, v: HeaderVec) -> Self {
        self.headers = v;
        self
    }
    pub fn missing_block_hashes(mut self, v: Byte32Vec) -> Self {
        self.missing_block_hashes = v;
        self
    }
    pub fn blocks_uncles_hash(mut self, v: Byte32Vec) -> Self {
        self.blocks_uncles_hash = v;
        self
    }
    pub fn blocks_extension(mut self, v: BytesOptVec) -> Self {
        self.blocks_extension = v;
        self
    }
}
impl molecule::prelude::Builder for SendBlocksProofV1Builder {
    type Entity = SendBlocksProofV1;
    const NAME: &'static str = "SendBlocksProofV1Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.last_header.as_slice().len()
            + self.proof.as_slice().len()
            + self.headers.as_slice().len()
            + self.missing_block_hashes.as_slice().len()
            + self.blocks_uncles_hash.as_slice().len()
            + self.blocks_extension.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.last_header.as_slice().len();
        offsets.push(total_size);
        total_size += self.proof.as_slice().len();
        offsets.push(total_size);
        total_size += self.headers.as_slice().len();
        offsets.push(total_size);
        total_size += self.missing_block_hashes.as_slice().len();
        offsets.push(total_size);
        total_size += self.blocks_uncles_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.blocks_extension.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.last_header.as_slice())?;
        writer.write_all(self.proof.as_slice())?;
        writer.write_all(self.headers.as_slice())?;
        writer.write_all(self.missing_block_hashes.as_slice())?;
        writer.write_all(self.blocks_uncles_hash.as_slice())?;
        writer.write_all(self.blocks_extension.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SendBlocksProofV1::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct GetTransactionsProof(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for GetTransactionsProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for GetTransactionsProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for GetTransactionsProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_hash", self.last_hash())?;
        write!(f, ", {}: {}", "tx_hashes", self.tx_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for GetTransactionsProof {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        GetTransactionsProof::new_unchecked(v)
    }
}
impl GetTransactionsProof {
    const DEFAULT_VALUE: [u8; 48] = [
        48, 0, 0, 0, 12, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_hash(&self) -> Byte32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32::new_unchecked(self.0.slice(start..end))
    }
    pub fn tx_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> GetTransactionsProofReader<'r> {
        GetTransactionsProofReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for GetTransactionsProof {
    type Builder = GetTransactionsProofBuilder;
    const NAME: &'static str = "GetTransactionsProof";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        GetTransactionsProof(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetTransactionsProofReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        GetTransactionsProofReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .last_hash(self.last_hash())
            .tx_hashes(self.tx_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct GetTransactionsProofReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for GetTransactionsProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for GetTransactionsProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for GetTransactionsProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_hash", self.last_hash())?;
        write!(f, ", {}: {}", "tx_hashes", self.tx_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> GetTransactionsProofReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_hash(&self) -> Byte32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Byte32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn tx_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for GetTransactionsProofReader<'r> {
    type Entity = GetTransactionsProof;
    const NAME: &'static str = "GetTransactionsProofReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        GetTransactionsProofReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Byte32Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct GetTransactionsProofBuilder {
    pub(crate) last_hash: Byte32,
    pub(crate) tx_hashes: Byte32Vec,
}
impl GetTransactionsProofBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn last_hash(mut self, v: Byte32) -> Self {
        self.last_hash = v;
        self
    }
    pub fn tx_hashes(mut self, v: Byte32Vec) -> Self {
        self.tx_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for GetTransactionsProofBuilder {
    type Entity = GetTransactionsProof;
    const NAME: &'static str = "GetTransactionsProofBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.last_hash.as_slice().len()
            + self.tx_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.last_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.tx_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.last_hash.as_slice())?;
        writer.write_all(self.tx_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        GetTransactionsProof::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SendTransactionsProof(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SendTransactionsProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SendTransactionsProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SendTransactionsProof {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_header", self.last_header())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        write!(f, ", {}: {}", "filtered_blocks", self.filtered_blocks())?;
        write!(f, ", {}: {}", "missing_tx_hashes", self.missing_tx_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SendTransactionsProof {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SendTransactionsProof::new_unchecked(v)
    }
}
impl SendTransactionsProof {
    const DEFAULT_VALUE: [u8; 412] = [
        156, 1, 0, 0, 20, 0, 0, 0, 144, 1, 0, 0, 148, 1, 0, 0, 152, 1, 0, 0, 124, 1, 0, 0, 20, 0,
        0, 0, 228, 0, 0, 0, 4, 1, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_header(&self) -> VerifiableHeader {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        VerifiableHeader::new_unchecked(self.0.slice(start..end))
    }
    pub fn proof(&self) -> HeaderDigestVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HeaderDigestVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn filtered_blocks(&self) -> FilteredBlockVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        FilteredBlockVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn missing_tx_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Byte32Vec::new_unchecked(self.0.slice(start..end))
        } else {
            Byte32Vec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SendTransactionsProofReader<'r> {
        SendTransactionsProofReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SendTransactionsProof {
    type Builder = SendTransactionsProofBuilder;
    const NAME: &'static str = "SendTransactionsProof";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SendTransactionsProof(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendTransactionsProofReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendTransactionsProofReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .last_header(self.last_header())
            .proof(self.proof())
            .filtered_blocks(self.filtered_blocks())
            .missing_tx_hashes(self.missing_tx_hashes())
    }
}
#[derive(Clone, Copy)]
pub struct SendTransactionsProofReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SendTransactionsProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SendTransactionsProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SendTransactionsProofReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_header", self.last_header())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        write!(f, ", {}: {}", "filtered_blocks", self.filtered_blocks())?;
        write!(f, ", {}: {}", "missing_tx_hashes", self.missing_tx_hashes())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SendTransactionsProofReader<'r> {
    pub const FIELD_COUNT: usize = 4;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_header(&self) -> VerifiableHeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        VerifiableHeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proof(&self) -> HeaderDigestVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HeaderDigestVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn filtered_blocks(&self) -> FilteredBlockVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        FilteredBlockVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn missing_tx_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[20..]) as usize;
            Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Byte32VecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SendTransactionsProofReader<'r> {
    type Entity = SendTransactionsProof;
    const NAME: &'static str = "SendTransactionsProofReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SendTransactionsProofReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        VerifiableHeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        HeaderDigestVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        FilteredBlockVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SendTransactionsProofBuilder {
    pub(crate) last_header: VerifiableHeader,
    pub(crate) proof: HeaderDigestVec,
    pub(crate) filtered_blocks: FilteredBlockVec,
    pub(crate) missing_tx_hashes: Byte32Vec,
}
impl SendTransactionsProofBuilder {
    pub const FIELD_COUNT: usize = 4;
    pub fn last_header(mut self, v: VerifiableHeader) -> Self {
        self.last_header = v;
        self
    }
    pub fn proof(mut self, v: HeaderDigestVec) -> Self {
        self.proof = v;
        self
    }
    pub fn filtered_blocks(mut self, v: FilteredBlockVec) -> Self {
        self.filtered_blocks = v;
        self
    }
    pub fn missing_tx_hashes(mut self, v: Byte32Vec) -> Self {
        self.missing_tx_hashes = v;
        self
    }
}
impl molecule::prelude::Builder for SendTransactionsProofBuilder {
    type Entity = SendTransactionsProof;
    const NAME: &'static str = "SendTransactionsProofBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.last_header.as_slice().len()
            + self.proof.as_slice().len()
            + self.filtered_blocks.as_slice().len()
            + self.missing_tx_hashes.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.last_header.as_slice().len();
        offsets.push(total_size);
        total_size += self.proof.as_slice().len();
        offsets.push(total_size);
        total_size += self.filtered_blocks.as_slice().len();
        offsets.push(total_size);
        total_size += self.missing_tx_hashes.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.last_header.as_slice())?;
        writer.write_all(self.proof.as_slice())?;
        writer.write_all(self.filtered_blocks.as_slice())?;
        writer.write_all(self.missing_tx_hashes.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SendTransactionsProof::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct SendTransactionsProofV1(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for SendTransactionsProofV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for SendTransactionsProofV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for SendTransactionsProofV1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_header", self.last_header())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        write!(f, ", {}: {}", "filtered_blocks", self.filtered_blocks())?;
        write!(f, ", {}: {}", "missing_tx_hashes", self.missing_tx_hashes())?;
        write!(
            f,
            ", {}: {}",
            "blocks_uncles_hash",
            self.blocks_uncles_hash()
        )?;
        write!(f, ", {}: {}", "blocks_extension", self.blocks_extension())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for SendTransactionsProofV1 {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        SendTransactionsProofV1::new_unchecked(v)
    }
}
impl SendTransactionsProofV1 {
    const DEFAULT_VALUE: [u8; 428] = [
        172, 1, 0, 0, 28, 0, 0, 0, 152, 1, 0, 0, 156, 1, 0, 0, 160, 1, 0, 0, 164, 1, 0, 0, 168, 1,
        0, 0, 124, 1, 0, 0, 20, 0, 0, 0, 228, 0, 0, 0, 4, 1, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_header(&self) -> VerifiableHeader {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        VerifiableHeader::new_unchecked(self.0.slice(start..end))
    }
    pub fn proof(&self) -> HeaderDigestVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HeaderDigestVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn filtered_blocks(&self) -> FilteredBlockVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        FilteredBlockVec::new_unchecked(self.0.slice(start..end))
    }
    pub fn missing_tx_hashes(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn blocks_uncles_hash(&self) -> Byte32Vec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte32Vec::new_unchecked(self.0.slice(start..end))
    }
    pub fn blocks_extension(&self) -> BytesOptVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            BytesOptVec::new_unchecked(self.0.slice(start..end))
        } else {
            BytesOptVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> SendTransactionsProofV1Reader<'r> {
        SendTransactionsProofV1Reader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for SendTransactionsProofV1 {
    type Builder = SendTransactionsProofV1Builder;
    const NAME: &'static str = "SendTransactionsProofV1";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        SendTransactionsProofV1(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendTransactionsProofV1Reader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        SendTransactionsProofV1Reader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .last_header(self.last_header())
            .proof(self.proof())
            .filtered_blocks(self.filtered_blocks())
            .missing_tx_hashes(self.missing_tx_hashes())
            .blocks_uncles_hash(self.blocks_uncles_hash())
            .blocks_extension(self.blocks_extension())
    }
}
#[derive(Clone, Copy)]
pub struct SendTransactionsProofV1Reader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for SendTransactionsProofV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for SendTransactionsProofV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for SendTransactionsProofV1Reader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "last_header", self.last_header())?;
        write!(f, ", {}: {}", "proof", self.proof())?;
        write!(f, ", {}: {}", "filtered_blocks", self.filtered_blocks())?;
        write!(f, ", {}: {}", "missing_tx_hashes", self.missing_tx_hashes())?;
        write!(
            f,
            ", {}: {}",
            "blocks_uncles_hash",
            self.blocks_uncles_hash()
        )?;
        write!(f, ", {}: {}", "blocks_extension", self.blocks_extension())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> SendTransactionsProofV1Reader<'r> {
    pub const FIELD_COUNT: usize = 6;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn last_header(&self) -> VerifiableHeaderReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        VerifiableHeaderReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn proof(&self) -> HeaderDigestVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        HeaderDigestVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn filtered_blocks(&self) -> FilteredBlockVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        FilteredBlockVecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn missing_tx_hashes(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn blocks_uncles_hash(&self) -> Byte32VecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Byte32VecReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn blocks_extension(&self) -> BytesOptVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[28..]) as usize;
            BytesOptVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesOptVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for SendTransactionsProofV1Reader<'r> {
    type Entity = SendTransactionsProofV1;
    const NAME: &'static str = "SendTransactionsProofV1Reader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        SendTransactionsProofV1Reader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        VerifiableHeaderReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        HeaderDigestVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        FilteredBlockVecReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        Byte32VecReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        BytesOptVecReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct SendTransactionsProofV1Builder {
    pub(crate) last_header: VerifiableHeader,
    pub(crate) proof: HeaderDigestVec,
    pub(crate) filtered_blocks: FilteredBlockVec,
    pub(crate) missing_tx_hashes: Byte32Vec,
    pub(crate) blocks_uncles_hash: Byte32Vec,
    pub(crate) blocks_extension: BytesOptVec,
}
impl SendTransactionsProofV1Builder {
    pub const FIELD_COUNT: usize = 6;
    pub fn last_header(mut self, v: VerifiableHeader) -> Self {
        self.last_header = v;
        self
    }
    pub fn proof(mut self, v: HeaderDigestVec) -> Self {
        self.proof = v;
        self
    }
    pub fn filtered_blocks(mut self, v: FilteredBlockVec) -> Self {
        self.filtered_blocks = v;
        self
    }
    pub fn missing_tx_hashes(mut self, v: Byte32Vec) -> Self {
        self.missing_tx_hashes = v;
        self
    }
    pub fn blocks_uncles_hash(mut self, v: Byte32Vec) -> Self {
        self.blocks_uncles_hash = v;
        self
    }
    pub fn blocks_extension(mut self, v: BytesOptVec) -> Self {
        self.blocks_extension = v;
        self
    }
}
impl molecule::prelude::Builder for SendTransactionsProofV1Builder {
    type Entity = SendTransactionsProofV1;
    const NAME: &'static str = "SendTransactionsProofV1Builder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.last_header.as_slice().len()
            + self.proof.as_slice().len()
            + self.filtered_blocks.as_slice().len()
            + self.missing_tx_hashes.as_slice().len()
            + self.blocks_uncles_hash.as_slice().len()
            + self.blocks_extension.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.last_header.as_slice().len();
        offsets.push(total_size);
        total_size += self.proof.as_slice().len();
        offsets.push(total_size);
        total_size += self.filtered_blocks.as_slice().len();
        offsets.push(total_size);
        total_size += self.missing_tx_hashes.as_slice().len();
        offsets.push(total_size);
        total_size += self.blocks_uncles_hash.as_slice().len();
        offsets.push(total_size);
        total_size += self.blocks_extension.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.last_header.as_slice())?;
        writer.write_all(self.proof.as_slice())?;
        writer.write_all(self.filtered_blocks.as_slice())?;
        writer.write_all(self.missing_tx_hashes.as_slice())?;
        writer.write_all(self.blocks_uncles_hash.as_slice())?;
        writer.write_all(self.blocks_extension.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        SendTransactionsProofV1::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Time(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Time {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Time {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Time {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "timestamp", self.timestamp())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Time {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Time::new_unchecked(v)
    }
}
impl Time {
    const DEFAULT_VALUE: [u8; 16] = [16, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn timestamp(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Uint64::new_unchecked(self.0.slice(start..end))
        } else {
            Uint64::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> TimeReader<'r> {
        TimeReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Time {
    type Builder = TimeBuilder;
    const NAME: &'static str = "Time";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Time(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TimeReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        TimeReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder().timestamp(self.timestamp())
    }
}
#[derive(Clone, Copy)]
pub struct TimeReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for TimeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for TimeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for TimeReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "timestamp", self.timestamp())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> TimeReader<'r> {
    pub const FIELD_COUNT: usize = 1;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn timestamp(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[8..]) as usize;
            Uint64Reader::new_unchecked(&self.as_slice()[start..end])
        } else {
            Uint64Reader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for TimeReader<'r> {
    type Entity = Time;
    const NAME: &'static str = "TimeReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        TimeReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct TimeBuilder {
    pub(crate) timestamp: Uint64,
}
impl TimeBuilder {
    pub const FIELD_COUNT: usize = 1;
    pub fn timestamp(mut self, v: Uint64) -> Self {
        self.timestamp = v;
        self
    }
}
impl molecule::prelude::Builder for TimeBuilder {
    type Entity = Time;
    const NAME: &'static str = "TimeBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1) + self.timestamp.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.timestamp.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.timestamp.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Time::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct RawAlert(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for RawAlert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for RawAlert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for RawAlert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "notice_until", self.notice_until())?;
        write!(f, ", {}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "cancel", self.cancel())?;
        write!(f, ", {}: {}", "priority", self.priority())?;
        write!(f, ", {}: {}", "message", self.message())?;
        write!(f, ", {}: {}", "min_version", self.min_version())?;
        write!(f, ", {}: {}", "max_version", self.max_version())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for RawAlert {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        RawAlert::new_unchecked(v)
    }
}
impl RawAlert {
    const DEFAULT_VALUE: [u8; 56] = [
        56, 0, 0, 0, 32, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0,
        56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn notice_until(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn id(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn cancel(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn priority(&self) -> Uint32 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32::new_unchecked(self.0.slice(start..end))
    }
    pub fn message(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn min_version(&self) -> BytesOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        BytesOpt::new_unchecked(self.0.slice(start..end))
    }
    pub fn max_version(&self) -> BytesOpt {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            BytesOpt::new_unchecked(self.0.slice(start..end))
        } else {
            BytesOpt::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> RawAlertReader<'r> {
        RawAlertReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for RawAlert {
    type Builder = RawAlertBuilder;
    const NAME: &'static str = "RawAlert";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        RawAlert(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RawAlertReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        RawAlertReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .notice_until(self.notice_until())
            .id(self.id())
            .cancel(self.cancel())
            .priority(self.priority())
            .message(self.message())
            .min_version(self.min_version())
            .max_version(self.max_version())
    }
}
#[derive(Clone, Copy)]
pub struct RawAlertReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for RawAlertReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for RawAlertReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for RawAlertReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "notice_until", self.notice_until())?;
        write!(f, ", {}: {}", "id", self.id())?;
        write!(f, ", {}: {}", "cancel", self.cancel())?;
        write!(f, ", {}: {}", "priority", self.priority())?;
        write!(f, ", {}: {}", "message", self.message())?;
        write!(f, ", {}: {}", "min_version", self.min_version())?;
        write!(f, ", {}: {}", "max_version", self.max_version())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> RawAlertReader<'r> {
    pub const FIELD_COUNT: usize = 7;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn notice_until(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn id(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn cancel(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        let end = molecule::unpack_number(&slice[16..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn priority(&self) -> Uint32Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[16..]) as usize;
        let end = molecule::unpack_number(&slice[20..]) as usize;
        Uint32Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn message(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[20..]) as usize;
        let end = molecule::unpack_number(&slice[24..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn min_version(&self) -> BytesOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[24..]) as usize;
        let end = molecule::unpack_number(&slice[28..]) as usize;
        BytesOptReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn max_version(&self) -> BytesOptReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[28..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[32..]) as usize;
            BytesOptReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesOptReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for RawAlertReader<'r> {
    type Entity = RawAlert;
    const NAME: &'static str = "RawAlertReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        RawAlertReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        Uint32Reader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Uint32Reader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Uint32Reader::verify(&slice[offsets[3]..offsets[4]], compatible)?;
        BytesReader::verify(&slice[offsets[4]..offsets[5]], compatible)?;
        BytesOptReader::verify(&slice[offsets[5]..offsets[6]], compatible)?;
        BytesOptReader::verify(&slice[offsets[6]..offsets[7]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct RawAlertBuilder {
    pub(crate) notice_until: Uint64,
    pub(crate) id: Uint32,
    pub(crate) cancel: Uint32,
    pub(crate) priority: Uint32,
    pub(crate) message: Bytes,
    pub(crate) min_version: BytesOpt,
    pub(crate) max_version: BytesOpt,
}
impl RawAlertBuilder {
    pub const FIELD_COUNT: usize = 7;
    pub fn notice_until(mut self, v: Uint64) -> Self {
        self.notice_until = v;
        self
    }
    pub fn id(mut self, v: Uint32) -> Self {
        self.id = v;
        self
    }
    pub fn cancel(mut self, v: Uint32) -> Self {
        self.cancel = v;
        self
    }
    pub fn priority(mut self, v: Uint32) -> Self {
        self.priority = v;
        self
    }
    pub fn message(mut self, v: Bytes) -> Self {
        self.message = v;
        self
    }
    pub fn min_version(mut self, v: BytesOpt) -> Self {
        self.min_version = v;
        self
    }
    pub fn max_version(mut self, v: BytesOpt) -> Self {
        self.max_version = v;
        self
    }
}
impl molecule::prelude::Builder for RawAlertBuilder {
    type Entity = RawAlert;
    const NAME: &'static str = "RawAlertBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.notice_until.as_slice().len()
            + self.id.as_slice().len()
            + self.cancel.as_slice().len()
            + self.priority.as_slice().len()
            + self.message.as_slice().len()
            + self.min_version.as_slice().len()
            + self.max_version.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.notice_until.as_slice().len();
        offsets.push(total_size);
        total_size += self.id.as_slice().len();
        offsets.push(total_size);
        total_size += self.cancel.as_slice().len();
        offsets.push(total_size);
        total_size += self.priority.as_slice().len();
        offsets.push(total_size);
        total_size += self.message.as_slice().len();
        offsets.push(total_size);
        total_size += self.min_version.as_slice().len();
        offsets.push(total_size);
        total_size += self.max_version.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.notice_until.as_slice())?;
        writer.write_all(self.id.as_slice())?;
        writer.write_all(self.cancel.as_slice())?;
        writer.write_all(self.priority.as_slice())?;
        writer.write_all(self.message.as_slice())?;
        writer.write_all(self.min_version.as_slice())?;
        writer.write_all(self.max_version.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        RawAlert::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Alert(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Alert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Alert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Alert {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "raw", self.raw())?;
        write!(f, ", {}: {}", "signatures", self.signatures())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Alert {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Alert::new_unchecked(v)
    }
}
impl Alert {
    const DEFAULT_VALUE: [u8; 72] = [
        72, 0, 0, 0, 12, 0, 0, 0, 68, 0, 0, 0, 56, 0, 0, 0, 32, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0,
        48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn raw(&self) -> RawAlert {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        RawAlert::new_unchecked(self.0.slice(start..end))
    }
    pub fn signatures(&self) -> BytesVec {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BytesVec::new_unchecked(self.0.slice(start..end))
        } else {
            BytesVec::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> AlertReader<'r> {
        AlertReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Alert {
    type Builder = AlertBuilder;
    const NAME: &'static str = "Alert";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Alert(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AlertReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        AlertReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .raw(self.raw())
            .signatures(self.signatures())
    }
}
#[derive(Clone, Copy)]
pub struct AlertReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for AlertReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for AlertReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for AlertReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "raw", self.raw())?;
        write!(f, ", {}: {}", "signatures", self.signatures())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> AlertReader<'r> {
    pub const FIELD_COUNT: usize = 2;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn raw(&self) -> RawAlertReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        RawAlertReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn signatures(&self) -> BytesVecReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[12..]) as usize;
            BytesVecReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesVecReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for AlertReader<'r> {
    type Entity = Alert;
    const NAME: &'static str = "AlertReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        AlertReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        RawAlertReader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesVecReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct AlertBuilder {
    pub(crate) raw: RawAlert,
    pub(crate) signatures: BytesVec,
}
impl AlertBuilder {
    pub const FIELD_COUNT: usize = 2;
    pub fn raw(mut self, v: RawAlert) -> Self {
        self.raw = v;
        self
    }
    pub fn signatures(mut self, v: BytesVec) -> Self {
        self.signatures = v;
        self
    }
}
impl molecule::prelude::Builder for AlertBuilder {
    type Entity = Alert;
    const NAME: &'static str = "AlertBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.raw.as_slice().len()
            + self.signatures.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.raw.as_slice().len();
        offsets.push(total_size);
        total_size += self.signatures.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.raw.as_slice())?;
        writer.write_all(self.signatures.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Alert::new_unchecked(inner.into())
    }
}
#[derive(Clone)]
pub struct Identify(molecule::bytes::Bytes);
impl ::core::fmt::LowerHex for Identify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl ::core::fmt::Debug for Identify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl ::core::fmt::Display for Identify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "flag", self.flag())?;
        write!(f, ", {}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "client_version", self.client_version())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl ::core::default::Default for Identify {
    fn default() -> Self {
        let v = molecule::bytes::Bytes::from_static(&Self::DEFAULT_VALUE);
        Identify::new_unchecked(v)
    }
}
impl Identify {
    const DEFAULT_VALUE: [u8; 32] = [
        32, 0, 0, 0, 16, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0,
    ];
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn flag(&self) -> Uint64 {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64::new_unchecked(self.0.slice(start..end))
    }
    pub fn name(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        Bytes::new_unchecked(self.0.slice(start..end))
    }
    pub fn client_version(&self) -> Bytes {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            Bytes::new_unchecked(self.0.slice(start..end))
        } else {
            Bytes::new_unchecked(self.0.slice(start..))
        }
    }
    pub fn as_reader<'r>(&'r self) -> IdentifyReader<'r> {
        IdentifyReader::new_unchecked(self.as_slice())
    }
}
impl molecule::prelude::Entity for Identify {
    type Builder = IdentifyBuilder;
    const NAME: &'static str = "Identify";
    fn new_unchecked(data: molecule::bytes::Bytes) -> Self {
        Identify(data)
    }
    fn as_bytes(&self) -> molecule::bytes::Bytes {
        self.0.clone()
    }
    fn as_slice(&self) -> &[u8] {
        &self.0[..]
    }
    fn from_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        IdentifyReader::from_slice(slice).map(|reader| reader.to_entity())
    }
    fn from_compatible_slice(slice: &[u8]) -> molecule::error::VerificationResult<Self> {
        IdentifyReader::from_compatible_slice(slice).map(|reader| reader.to_entity())
    }
    fn new_builder() -> Self::Builder {
        ::core::default::Default::default()
    }
    fn as_builder(self) -> Self::Builder {
        Self::new_builder()
            .flag(self.flag())
            .name(self.name())
            .client_version(self.client_version())
    }
}
#[derive(Clone, Copy)]
pub struct IdentifyReader<'r>(&'r [u8]);
impl<'r> ::core::fmt::LowerHex for IdentifyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use molecule::hex_string;
        if f.alternate() {
            write!(f, "0x")?;
        }
        write!(f, "{}", hex_string(self.as_slice()))
    }
}
impl<'r> ::core::fmt::Debug for IdentifyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{}({:#x})", Self::NAME, self)
    }
}
impl<'r> ::core::fmt::Display for IdentifyReader<'r> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        write!(f, "{} {{ ", Self::NAME)?;
        write!(f, "{}: {}", "flag", self.flag())?;
        write!(f, ", {}: {}", "name", self.name())?;
        write!(f, ", {}: {}", "client_version", self.client_version())?;
        let extra_count = self.count_extra_fields();
        if extra_count != 0 {
            write!(f, ", .. ({} fields)", extra_count)?;
        }
        write!(f, " }}")
    }
}
impl<'r> IdentifyReader<'r> {
    pub const FIELD_COUNT: usize = 3;
    pub fn total_size(&self) -> usize {
        molecule::unpack_number(self.as_slice()) as usize
    }
    pub fn field_count(&self) -> usize {
        if self.total_size() == molecule::NUMBER_SIZE {
            0
        } else {
            (molecule::unpack_number(&self.as_slice()[molecule::NUMBER_SIZE..]) as usize / 4) - 1
        }
    }
    pub fn count_extra_fields(&self) -> usize {
        self.field_count() - Self::FIELD_COUNT
    }
    pub fn has_extra_fields(&self) -> bool {
        Self::FIELD_COUNT != self.field_count()
    }
    pub fn flag(&self) -> Uint64Reader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[4..]) as usize;
        let end = molecule::unpack_number(&slice[8..]) as usize;
        Uint64Reader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn name(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[8..]) as usize;
        let end = molecule::unpack_number(&slice[12..]) as usize;
        BytesReader::new_unchecked(&self.as_slice()[start..end])
    }
    pub fn client_version(&self) -> BytesReader<'r> {
        let slice = self.as_slice();
        let start = molecule::unpack_number(&slice[12..]) as usize;
        if self.has_extra_fields() {
            let end = molecule::unpack_number(&slice[16..]) as usize;
            BytesReader::new_unchecked(&self.as_slice()[start..end])
        } else {
            BytesReader::new_unchecked(&self.as_slice()[start..])
        }
    }
}
impl<'r> molecule::prelude::Reader<'r> for IdentifyReader<'r> {
    type Entity = Identify;
    const NAME: &'static str = "IdentifyReader";
    fn to_entity(&self) -> Self::Entity {
        Self::Entity::new_unchecked(self.as_slice().to_owned().into())
    }
    fn new_unchecked(slice: &'r [u8]) -> Self {
        IdentifyReader(slice)
    }
    fn as_slice(&self) -> &'r [u8] {
        self.0
    }
    fn verify(slice: &[u8], compatible: bool) -> molecule::error::VerificationResult<()> {
        use molecule::verification_error as ve;
        let slice_len = slice.len();
        if slice_len < molecule::NUMBER_SIZE {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE, slice_len);
        }
        let total_size = molecule::unpack_number(slice) as usize;
        if slice_len != total_size {
            return ve!(Self, TotalSizeNotMatch, total_size, slice_len);
        }
        if slice_len < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, HeaderIsBroken, molecule::NUMBER_SIZE * 2, slice_len);
        }
        let offset_first = molecule::unpack_number(&slice[molecule::NUMBER_SIZE..]) as usize;
        if offset_first % molecule::NUMBER_SIZE != 0 || offset_first < molecule::NUMBER_SIZE * 2 {
            return ve!(Self, OffsetsNotMatch);
        }
        if slice_len < offset_first {
            return ve!(Self, HeaderIsBroken, offset_first, slice_len);
        }
        let field_count = offset_first / molecule::NUMBER_SIZE - 1;
        if field_count < Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        } else if !compatible && field_count > Self::FIELD_COUNT {
            return ve!(Self, FieldCountNotMatch, Self::FIELD_COUNT, field_count);
        };
        let mut offsets: Vec<usize> = slice[molecule::NUMBER_SIZE..offset_first]
            .chunks_exact(molecule::NUMBER_SIZE)
            .map(|x| molecule::unpack_number(x) as usize)
            .collect();
        offsets.push(total_size);
        if offsets.windows(2).any(|i| i[0] > i[1]) {
            return ve!(Self, OffsetsNotMatch);
        }
        Uint64Reader::verify(&slice[offsets[0]..offsets[1]], compatible)?;
        BytesReader::verify(&slice[offsets[1]..offsets[2]], compatible)?;
        BytesReader::verify(&slice[offsets[2]..offsets[3]], compatible)?;
        Ok(())
    }
}
#[derive(Debug, Default)]
pub struct IdentifyBuilder {
    pub(crate) flag: Uint64,
    pub(crate) name: Bytes,
    pub(crate) client_version: Bytes,
}
impl IdentifyBuilder {
    pub const FIELD_COUNT: usize = 3;
    pub fn flag(mut self, v: Uint64) -> Self {
        self.flag = v;
        self
    }
    pub fn name(mut self, v: Bytes) -> Self {
        self.name = v;
        self
    }
    pub fn client_version(mut self, v: Bytes) -> Self {
        self.client_version = v;
        self
    }
}
impl molecule::prelude::Builder for IdentifyBuilder {
    type Entity = Identify;
    const NAME: &'static str = "IdentifyBuilder";
    fn expected_length(&self) -> usize {
        molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1)
            + self.flag.as_slice().len()
            + self.name.as_slice().len()
            + self.client_version.as_slice().len()
    }
    fn write<W: molecule::io::Write>(&self, writer: &mut W) -> molecule::io::Result<()> {
        let mut total_size = molecule::NUMBER_SIZE * (Self::FIELD_COUNT + 1);
        let mut offsets = Vec::with_capacity(Self::FIELD_COUNT);
        offsets.push(total_size);
        total_size += self.flag.as_slice().len();
        offsets.push(total_size);
        total_size += self.name.as_slice().len();
        offsets.push(total_size);
        total_size += self.client_version.as_slice().len();
        writer.write_all(&molecule::pack_number(total_size as molecule::Number))?;
        for offset in offsets.into_iter() {
            writer.write_all(&molecule::pack_number(offset as molecule::Number))?;
        }
        writer.write_all(self.flag.as_slice())?;
        writer.write_all(self.name.as_slice())?;
        writer.write_all(self.client_version.as_slice())?;
        Ok(())
    }
    fn build(&self) -> Self::Entity {
        let mut inner = Vec::with_capacity(self.expected_length());
        self.write(&mut inner)
            .unwrap_or_else(|_| panic!("{} build should be ok", Self::NAME));
        Identify::new_unchecked(inner.into())
    }
}
